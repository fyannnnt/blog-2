{"pages":[{"title":"WecTeam | 京东社交电商前端团队","text":"维C团简介维C团(WecTeam)是京东社交电商部一群热爱技术、乐于分享的前端工程师自发成立的一个前端技术团队，希望通过技术实践总结、新技术探秘、Bug深度分析、优质英文资料引入等方式，参与和推动前端技术的发展，为公司及行业带来价值！ 联系我们","link":"/about/index.html"}],"posts":[{"title":"CSS Houdini实现动态波浪纹","text":"作者：黄浩群 CSS Houdini 号称 CSS 领域最令人振奋的革新。CSS 本身长期欠缺语法特性，可拓展性几乎为零，并且新特性的支持效率太低，兼容性差。而 Houdini 直接将 CSS 的 API 暴露给开发者，以往完全黑盒的浏览器解析流开始对外开放，开发者可以自定义属于自己的 CSS 属性，从而定制和扩展浏览器的展示行为。 背景我们知道，浏览器在渲染页面时，首先会解析页面的 HTML 和 CSS，生成渲染树（rendering tree），再经由布局（layout）和绘制（painting），呈现出整个页面内容。在 Houdini 出现之前，这个流程上我们能操作的空间少之甚少，尤其是 layout 和 painting 环节，可以说是完全封闭，使得我们很难通过 polyfill 等类似的手段为欠支持的 CSS 特性提供兼容。而另一方面，语法特性的缺失也极大地限制了 CSS 的编程灵活性，社区中 sass、less、stylus 等 CSS 预处理技术的出现大多都源于这个原因，它们都希望通过预编译，突破 CSS 的局限性，让 CSS 拥有更强大的组织和编写能力。所以慢慢地，我们都不再手写 CSS，更方便、更灵活的 CSS 扩展语言成了 web 开发的主角。看到这样的情况，CSS Houdini 终于坐不住了。 什么是 CSS Houdini？CSS Houdini 对外开放了浏览器解析流程的一系列 API，这些 API 允许开发者介入浏览器的 CSS engine 运作，带来了更多的 CSS 解决方案。 CSS Houdini 目前主要提供了以下几个 API： CSS Properties and Values API 允许在 CSS 中定义变量和使用变量，是目前支持程度最高的一个 API。CSS 变量以 -- 开头，通过 var() 调用： 1234div { --font-color: #9e4a9b; color: var(--font-color);} 此外，CSS 变量也可以在其他节点中使用，只不过是有作用域限制的，也就是说自身定义的 CSS 变量只能被自身或自身的子节点使用： 123456.container { --font-color: #9e4a9b;}.container .text { color: var(--font-color);} 定义和使用 CSS 变量可以让我们的 CSS 代码变得更加简洁明了，比如我们可以单纯通过改变变量来改变 box-shadow 的颜色： 1234567.text { --box-shadow-color: #3a4ba2; box-shadow: 0 0 30px var(--box-shadow-color);}.text:hover { --box-shadow-color: #7f2c2b;} Painting API 允许开发者编写自己的 Paint Module，自定义诸如 background-image 这类的绘制属性。自定义的重点在于，”怎么画” 的逻辑需要我们来描述，因此我们利用 registerPaint 来描述我们的绘制逻辑： 12345registerPaint('rect', class { paint(ctx, size, properties, args) { // @TODO }}); registerPaint 方法注册了一个 Paint 类 rect 以供调用，这个类的核心在于它的 paint 方法。paint 方法用于描述自定义的绘制逻辑，它接收四个参数： ctx：一个 Canvas 的 Context 对象，因此 paint 中的绘制方式跟 canvas 绘制是一样的。 size：包含节点的尺寸信息，同时也是 canvas 可绘制范围（画板）的尺寸信息。 properties：包含节点的 CSS 属性，需要调用静态方法 inputProperties 声明注入。 args: CSS 中调用 Paint 类时传入的参数，需要调用静态方法 inputArguments 声明注入。 编写完 Paint 类之后，我们在 CSS 中只需要这样调用，就能应用到我们自定义的绘制逻辑： 123.wrapper { background-image: paint(rect);} Painting API 目前在高版本 Chrome、Opera 浏览器已有支持，且实现起来比较简单，后边我们还将通过 demo 进一步演示。 Layout API允许开发者编写自己的 Layout Module，自定义诸如 display 这类的布局属性。同样的，”如何布局” 的逻辑需要我们自己编写： 1234567891011registerLayout('block-like', class { layout(children, edges, constraints, properties, breakToken) { // @TODO return { // inlineSize: number, // blockSize: number, // autoBlockSize: number, // childFragments: sequence&lt;LayoutFragment&gt; } }}) registerLayout 方法用于注册一个 Layout 类以供调用，它的 layout 方法用于描述自定义的布局逻辑，最终返回一个包含布局后的位置尺寸信息和子节点序列信息的对象，引擎将根据这个对象进行布局渲染。 同样的，调用时只需： 123.wrapper { display: layout('block-like');} 因此利用 Layout API，你完全可以实现对 flex 布局的手工兼容。相比 Painting，Layout 的编写显得更加复杂，涉及到盒模型的深入概念，且支持度不高，这里就不细讲了。 WorkletsregisterPaint、registerLayout 这些 API 在全局上并不存在，为什么可以直接调用呢？这是因为上述的 JS 代码并不是直接执行的，而是通过 Worklets 载入执行的。Worklets 类似于 Web Worker，是一个运行于主代码之外的独立工作进程，但比 Worker 更为轻量，负责 CSS 渲染任务是最合适的了。和 Web Worker 一样，Worklets 拥有一个隔离于主进程的全局空间，在这个空间里，没有 window 对象，却有 registerPaint、registerLayout 这些全局 API。因此，我们需要这样引入自定义 JS 代码： 123if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\");} 123if (\"layoutWorklet\" in CSS) { CSS.layoutWorklet.addModule(\"layoutworklet.js\");} 基础：三步用上 Painting API我们来自定义 background-image 属性，它将用于给作用节点绘制一个矩形背景，背景色值由该节点上的一个 CSS 变量 --rect-color 指定。 1、编写一个 Paint 类：新建一个 paintworklet.js，利用 registerPaint 方法注册一个 Paint 类 rect，定义属性的绘制逻辑： 12345678910registerPaint(\"rect\", class { static get inputProperties() { return [\"--rect-color\"]; } paint(ctx, geom, properties) { const color = properties.get(\"--rect-color\")[0]; ctx.fillStyle = color; ctx.fillRect(0, 0, geom.width, geom.height); }}); 上边定义了一个名为 rect 的 Paint 类，当 rect 被使用时，会实例化 rect 并自动触发 paint 方法执行渲染。paint 方法中，我们获取节点 CSS 定义的 --rect-color 变量，并将元素的背景填充为指定颜色。由于需要使用属性 --rect-color，我们需要在静态方法 inputProperties 中声明。 2、Worklets 加载 Paint 类：HTML 中通过 Worklets 载入上一步骤实现的 paintworklet.js 并注册 Paint 类： 123456&lt;div class=\"rect\"&gt;&lt;/div&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); }&lt;/script&gt; 3、使用 Paint 类：CSS 中使用的时候，只需要调用 paint 方法： 123456.rect { width: 100vw; height: 100vh; background-image: paint(rect); --rect-color: rgb(255, 64, 129);} 可以看得出利用 CSS Houdini，我们可以像操作 canvas 一样灵活自如地实现我们想要的样式功能。 进阶：实现动态波纹根据上述步骤，我们演示一下如何用 CSS Painting API 实现一个动态波浪的效果： 1234567891011121314151617181920212223242526&lt;!-- index.html --&gt;&lt;div id=\"wave\"&gt;&lt;/div&gt;&lt;style&gt; #wave { width: 20%; height: 70vh; margin: 10vh auto; background-color: #ff3e81; background-image: paint(wave); }&lt;/style&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); const wave = document.querySelector(\"#wave\"); let tick = 0; requestAnimationFrame(function raf(now) { tick += 1; wave.style.cssText = `--animation-tick: ${tick};`; requestAnimationFrame(raf); }); }&lt;/script&gt; 12345678910111213141516171819202122232425262728// paintworklet.jsregisterPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { let tick = Number(properties.get('--animation-tick')); const { width, height } = geom; const initY = height * 0.4; tick = tick * 2; ctx.beginPath(); ctx.moveTo(0, initY + Math.sin(tick / 20) * 10); for (let i = 1; i &lt;= width; i++) { ctx.lineTo(i, initY + Math.sin((i + tick) / 20) * 10); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + Math.sin(tick / 20) * 10); ctx.closePath(); ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fill(); }}) paintworklet 中，利用 sin 函数绘制波浪线，由于 AnimationWorklets 尚处于实验阶段，开放较少，这里我们在 worklet 外部用 requestAnimationFrame API 来做动画驱动，让波浪纹动起来。完成后能看到下边这样的效果。 然而事实上这个效果略显僵硬，sin 函数太过于规则了，现实中的波浪应该是不规则波动的，这种不规则主要体现在两个方面： 1）波纹高度（Y）随位置（X）变化而不规则变化 把图按照 x-y 正交分解之后，我们希望的不规则，可以认为是固定某一时刻，随着 x 轴变化，波纹高度 y 呈现不规则变化； 2）固定某点（X 固定），波纹高度（Y）随时间推进而不规则变化动态过程需要考虑时间维度，我们希望的不规则，还需要体现在时间的影响中，比如风吹过的前一秒和后一秒，同一个位置的波浪高度肯定是不规则变化的。 提到不规则，有朋友可能想到了用 Math.random 方法，然而这里的不规则并不适合用随机数来实现，因为前后两次取的随机数是不连续的，而前后两个点的波浪是连续的。这个不难理解，你见过长成锯齿状的波浪吗？又或者你见过上一刻 10 米高、下一刻就掉到 2 米的波浪吗？ 为了实现这种连续不规则的特征，我们弃用 sin 函数，引入了一个包 simplex-noise。由于影响波高的有两个维度，位置 X 和时间 T，这里需要用到 noise2D 方法，它提前在一个三维的空间中，构建了一个连续的不规则曲面： 123456789101112131415161718192021222324252627282930313233343536373839404142// paintworklet.jsimport SimplexNoise from 'simplex-noise';const sim = new SimplexNoise(() =&gt; 1);registerPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { const tick = Number(properties.get('--animation-tick')); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.4)', 0.004, tick, 15, 0.4); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.5)', 0.006, tick, 12, 0.4); } /** * 绘制波纹 */ drawWave(ctx, geom, fillColor, ratio, tick, amp, ih) { const { width, height } = geom; const initY = height * ih; const speedT = tick * ratio; ctx.beginPath(); for (let x = 0, speedX = 0; x &lt;= width; x++) { speedX += ratio * 1; var y = initY + sim.noise2D(speedX, speedT) * amp; ctx[x === 0 ? 'moveTo' : 'lineTo'](x, y); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + sim.noise2D(0, speedT) * amp); ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill(); }}) 修改峰值和偏置项等参数，可以再画多一个不一样的波浪纹，效果如下，完工！ 参考文章 CSS Painting API Level 1CSS Layout API Level 1CSS 魔術師 Houdini API 介紹","link":"/2019/07/12/CSS Houdini实现动态波浪纹/"},{"title":"Javascript抽象语法树上篇(基础篇)","text":"作者：陈晓强 一、基础为什么要了解抽象语法树日常工作中，我们会碰到js代码解析的场景，比如分析代码中require了哪些包，有些什么关键API调用，大部分情况使用正则表达式来处理，可一旦场景复杂，或者依赖于代码上下文时，正则就很难处理了，这时候就要用到抽象语法树。常见的uglify、eslint、babel、webpack等等都是基于抽象语法树来处理的，如此强大，有必要好好了解一下。 什么是抽象语法树抽象语法树即：Abstract Syntax Tree。简称AST，见下图。 图中code先经过parse转换成一个树状数据结构 接着对树中节点进行转换，图中将叶子节点对换位置 将树状结构通过generate再生成code 图中树状数据结构即AST，从这个过程可以看到将代码转成AST后，通过操作节点来改变代码。 如何获得抽象语法树获得抽象语法树的过程为：代码 =&gt; 词法分析 =&gt; 语法分析 =&gt; AST词法分析：把字符串形式的代码转换为令牌（tokens）流。语法分析：把一个令牌流转换成 AST 的形式。这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。如下图，代码为一个简单的函数声明。词法分析阶段，将代码作为字符串输入获得关键词，图中function、square、(、)、{、}等都被识别为关键词(稍微回忆下编译原理，字符挨个入栈，符合一定规则即出栈)。语法分析阶段，对关键词的组合形成一个个节点，如n*n这3个关键词组合成二元表达式，关键词return与二元表达式组合成return语句。最后组合成一个函数声明语句。 二、规范如何获得AST已经简单介绍了，那AST最终应该以什么样的数据结构存在呢，先看看上述函数声明的AST结构 那解析的依据是什么，为什么要以上图的结构出现，业界已经有了一套成熟的规范。 规范起源在v8引擎之前，最早js引擎是SpiderMonkey，第一个版本由js作者Brendan Eich设计，后交给Mozilla组织维护。js引擎在执行js文件时，都会先将js代码转换成抽象语法树(AST)。有一天，一位Mozilla工程师在FireFox中公开了这个将代码转成AST的解析器Api，也就是Parser_API[1]，后来被人整理到github项目estree[2]，慢慢的成了业界的规范。 规范解读上面提到的Parser_API是规范的原文，中文版:Parser_API[3]，但读起来并不太友好，推荐直接读整理后的git项目estree，打开项目地址，如下图其中最下面的es5.md为ES5规范，仅列出ES5的内容，es2015.md为ES6规范，但只列出了针对ES5新增的内容，依次类推，最后的es2019.md即ES10是对ES9的补充，仅有一条规则。 打开最基础的es5.md，可以看到所有语法基础，这里跟大家一起读一下大类，细分类别就略过了。读规范时可以使用https://astexplorer.net/ 辅助阅读，可以实时输出AST。 Node objects Programs Identifier Literal Functions Statements Declarations Expressions Patterns Node objects1234interface Node { type: string; loc: SourceLocation | null;} 定义AST中节点基本类型，其他所有具体节点都需要实现以上接口，即每个节点都必须包含type、loc两个字段 type字段表示不同的节点类型，下边会再讲一下各个类型的情况，分别对应了 JavaScript 中的什么语法。你可以从这个字段看出这个节点实现了哪个接口loc字段表示源码的位置信息，如果没有相关信息的话为 null，否则是一个对象，包含了开始和结束的位置。接口如下 12345interface SourceLocation { source: string | null; start: Position; end: Position;} 每个 Position 对象包含了行（从1开始）和列（从0开始）信息，接口如下 1234interface Position { line: number; // &gt;= 1 column: number; // &gt;= 0} Programs1234interface Program &lt;: Node { type: \"Program\"; body: [ Directive | Statement ];} 一棵完整的程序代码树，一般作为根节点 Identifier1234interface Identifier &lt;: Expression, Pattern { type: \"Identifier\"; name: string;} 标识符，我们写代码时自定义的名称，如变量名、函数名、属性名。 Literal1234interface Literal &lt;: Expression { type: \"Literal\"; value: string | boolean | null | number | RegExp;} 字面量，如“hello”、true、null、100、/\\d/这些，注意字面量本身也是一个表达式语句(ExpressionStatement) Functions12345interface Function &lt;: Node { id: Identifier | null; params: [ Pattern ]; body: FunctionBody;} 一个函数声明或者表达式，id是函数名，params是标识符数组，body是函数体，也是一个语句块。 Statements1interface Statement &lt;: Node { } 语句，子类有很多，块语句、if/switch语句、return语句、for/while语句、with语句等等 Declarations1interface Declaration &lt;: Statement { } 声明，子类主要有变量申明、函数声明。 Expressions1interface Expression &lt;: Node { } 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式(a = 1)等等 Patterns1interface Pattern &lt;: Node { } 模式，主要在 ES6 的解构赋值中有意义(let {name} = user，其中{name}部分为ObjectPattern)，在 ES5 中，可以理解为和Identifier 差不多的东西。 三、现状通过以上规范解读，知道了最终要生成的AST以什么样的结构存在，对于javascript的解析，业界已经有很多成熟的解析器，可以将js代码转换成符合规范的AST Esprima，比较经典，出现的比较早 Acorn，fork自Esprima，代码更精简。webpack使用acorn进行模块解析 UglifyJS2，主要用于代码压缩 babylon，babel解析器，fork自Acorn，目前最新版本是babylon7,对应npm包@babel/parser Espree，eslint默认的解析器，由于遵循同一套规范，也可以使用babel的解析器替代 flow、shift等等 AST基础篇介绍完毕，下篇将从实践的角度继续介绍 References[1] Parser_API：https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API[2] estree：https://github.com/estree/estree[3] Parser_API(中文)：https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API","link":"/2019/07/19/Javascript抽象语法树上篇(基础篇)/"},{"title":"【译】Web内容如何影响电池的使用","text":"原文地址：https://webkit.org/blog/8970/how-web-content-can-affect-power-usage/原文作者：Benjamin Poulain &amp; Simon Fraser译者：刘辉 校验：李刚松 现在用户上网大多使用移动设备或者笔记本电脑。对这两者来说，电池寿命都很重要。在这篇文章里，我们将讨论影响电池寿命的因素，以及作为一个web开发者，我们如何让网页耗电更少，以便用户有更多时间来关注我们的内容。 是什么在耗电？移动设备的电力消耗有以下几个因素： CPU （核心处理器） GPU （图形处理） 网络 （wifi或者蜂窝移动网络） 屏幕 屏幕功耗相对稳定，并且主要由用户控制（通过屏幕使用时间和亮度），但是对于其他组件，例如CPU，GPU，网络模块，功耗是动态变化的，而且变化范围很大。 系统根据当前正在处理的任务调整CPU和GPU性能，包括在Web浏览器中用户正在交互的网页以及使用Web内容的其他应用程序。这是通过打开或关闭某些组件以及通过更改其时钟频率来完成的。总的来说，芯片所需的性能越高，其功率效率就越低。硬件可以非常快速地提升到高性能（但是需要很大的功率），然后迅速恢复到更高效的低功耗状态。 良好用电的一般原则为了最大限度地延长电池寿命，你必须尽量减少硬件处于高功率状态的时间，让硬件尽可能的处于空闲状态。 对于web开发者来说，有三种交互场景需要注意： 用户主动与内容交互 页面处于前台，但是用户没有交互 页面处于后台 高效的用户交互用户交互的时候肯定会耗电。页面需要快速的加载，并且能够快速的响应触摸。在大多数场景中，减少首次渲染时间也会降低功耗。不过，在初始页面加载后继续加载资源和运行脚本时要小心。我们要尽快让系统返回空闲状态。总的来说，浏览器已经完成了布局和渲染，js执行的越少，耗电越少。 一旦页面加载完，用户可能会滚屏或者点击页面，这同样会产生耗电（主要是CPU和GPU）,这是必要的消耗。要确保尽快返回空闲状态。并且，最好使用浏览器本身提供的功能。- 举例：普通的页面滚动肯定比用js自定义的滚动更高效。 让空闲状态耗电趋向于零当用户没有和页面交互时，尽可能的使页面不耗电，例如： 尽量少用定时器以避免唤醒CPU,可以把基于定时器的任务合并，使用尽可能少的定时器。大量滥用定时器会导致CPU被频繁唤醒，这比把这些任务合并处理要糟糕的多。 最大限度地减少动画内容，如动画图像和自动播放视频。要特别注意”loading”用的gif图片或css动画，这些动画会不断触发渲染，即使看不到也会触发。IntersectionObserver可以用来在可见时才运行动画。 尽量用css做动画和过渡，这些动画不可见时，浏览器会进行优化，并且css动画比js动画要高效的多。 避免通过轮询来获取服务器更新，可以用websocket或者持久连接来代替轮询。 看起来处于空闲状态的页面，如果正在后台进行工作，其用户交互的响应效率也会降低，因此最小化后台活动也可以提高响应能力以及电池寿命。 页面在后台时CPU零使用这几种场景时，页面变为非活动状态(不是用户的首要焦点)，例如： 用户切换到其他tab 用户切换到其他app 浏览器窗口最小化 浏览器窗口失去焦点 浏览器窗口在其他窗口后面 窗口所在的空间不是当前空间（MacOS才有空间的概念） 当页面不活动时，webkit会自动做以下处理来减少耗电： 停止调用requestAnimationFrame CSS和SVG动画会暂停 定时器会节流 此外，WebKit利用操作系统提供的能力来最大限度地提高效率： 在iOS上，不用的选项卡(tab页)会完全暂停。 在macOS上，选项卡会响应App Nap功能，这意味着不可视更新的选项卡的Web进程优先级较低，并且其计时器会做节流处理。 但是，页面可以通过计时器（setTimeout和setInterval），消息，网络事件等触发CPU唤醒。页面在后台时应避免这些唤醒，有两个API对此有用： 页面可见性API提供了一种响应页面转换为后台或前台的方法。这是一种避免页面在后台时更新UI的好方法。用visibilitychange事件，在页面可见时更新页面内容。 页面失去焦点时会发出blur事件。这时，页面依然可见，但是不是聚焦窗口。可以考虑暂停动画。 查找问题最简单的方式就是用浏览器控制台的时间线功能。页面在后台时，时间线记录中不应该有任何事件发生。 找到问题所在现在我们知道了web页面主要的耗电因素，并且给出了一些创建高效页面的一般规则。 接下来讨论一下怎样找出并解决导致功耗过大的问题。 脚本如上所述，现代CPU能够把功率从空闲态的非常低提升到非常高来满足用户交互和其他任务的要求。 也正因为如此，CPU是导致电池寿命减少的主要原因。页面加载期间CPU要做一连串工作包括加载、解析、渲染资源，并且执行js。在大多数现代web页面上，执行js花费的时间远远高出浏览器用在其余加载过程中花费的时间。因为尽量减少js执行时间对省电有最大的效益。 测量CPU使用的最佳方法是使用Web Inspector，就像之前文章里所说的，时间线面板可以显示任意选定时间范围内的CPU活动。 为了高效地使用CPU，WebKit尽可能在多核上分配工作（使用Workers的页面也可以使用多核）。Web Inspector提供与页面主线程同时运行的线程的细分图表。例如，以下屏幕截图显示了滚动具有复杂渲染和视频播放的页面时的线程： 在寻找优化点时，应关注主线程，因为js运行在主线程上（除非您正在使用Workers）。我们可以使用时间线面板的 “JavaScript and Events” 项来了解触发脚本的内容。也许你在响应用户或滚动事件或从requestAnimationFrame触发隐藏元素的更新时做了太多工作。你需要了解你在页面上使用的JavaScript库和第三方脚本所做的工作。如果要深入挖掘，你可以使用Web Inspector的JavaScript profiler来查看时间都用在哪些地方。 “WebKit线程”中的活动主要由与JavaScript相关的工作触发：JIT编译和垃圾收集。因此减少运行的脚本数量并减少短生命周期的JavaScript对象可以降低webkit线程的活动。 WebKit调用的各种其他系统框架都使用线程，“Other thread” 包括了这些工作; “Other thread” 最主要的工作是渲染，我们将在下面讨论。 渲染主线程CPU使用也可以通过大量布局和绘制来触发；这些通常由脚本触发，但是除了transform，opacity和filter之外的属性的CSS动画也可以触发它们。查看时间线面板的 “Layout and Rendering” 项将帮助你了解导致活动的原因。 如果 “Layout and Rendering” 显示的渲染过程不能清楚展示页面正在发生什么变化，可以启用 Paint Flashing： 这部分渲染将用红色背景的高亮显示，你可以滚动页面查看。注意，WebKit会保留一些“透视”图块以允许平滑滚动，因此视口中不可见的图形仍然可以正常工作以使屏幕外图块保持最新。如果渲染展示在时间轴中，说明它正在工作。 除了导致CPU耗电外，渲染通常还会触发GPU工作。macOS和iOS上的WebKit使用GPU进行渲染，因此触发渲染可以显着增加耗电。额外的CPU使用通常显示在时间线面板 “CPU” 项中的 “Other threads” 下。 GPU还用于canvas渲染，包括2D画布和WebGL / WebGPU。为了最小限度使用绘图，canvas上显示的内容没有变化时不要调用canvas API，并尝试优化canvas绘制代码。 许多Mac笔记本电脑都有两个GPU，一个与CPU相同内核的集成GPU，功能不强但功耗低，一个功能更强大但是功耗也更高的独立GPU。 WebKit默认使用集成GPU；你可以使用powerPreference上下文创建参数请求独立GPU，但只有在你可以证明电源成本合理时才执行此操作。 网络无线网络会以意想不到的方式影响电池寿命。手机有功能更强大的无线模块（WiFi和蜂窝网络芯片）和更小的电池，因此受到的影响最大。 遗憾的是，在实验室外测量网络的功率影响并不容易，但可以通过遵循一些简单的规则来减少。 降低网络功耗的最直接方法是最大限度地利用浏览器的缓存。 减少页面加载时间的所有最佳实践也可以通过减少无线模块需要打开的时间来使电池受益。 另一个重要方面是在时间上将网络请求组合在一起。每当有新请求到来时，操作系统都需要打开无线模块，连接到基站或蜂窝塔，并传输字节。在发送分组之后，在发送更多分组的情况下，无线电保持供电少量时间。 如果页面非经常性的发送少量数据，则开销可能会大于传输数据所需的能量。 可以从 Web Inspector 的时间线面板的 “Network Requests” 项中发现此类问题。例如，以下屏幕截图显示了几秒钟内发送的四个单独请求： 同时发送所有请求将提高网络用电效率。 总结我们可以对网页做很多优化来延长电池寿命。 在Web Inspector中测量对电池影响并降低损耗非常重要。 这样做可以改善用户体验并延长电池寿命。 提高电池寿命的最直接方法是最大限度地降低CPU使用率。 新的Web Inspector提供了强大的工具可以全程监控。 为了让电池寿命更长，我们要： 在空闲时将CPU使用率降至零 在用户交互期间最大化性能以快速恢复空闲","link":"/2019/09/17/【译】Web内容如何影响电池的使用/"},{"title":"Javascript抽象语法树下篇(实践篇)","text":"作者：陈晓强 上篇已经对AST基础做了介绍，本篇介绍AST的运用 AST应用的三个要点 需要一个解析器，将代码转换为AST 需要一个遍历器，能够遍历AST,并能够方便的对AST节点进行增删改查等操作 需要一个代码生成器，能够将AST转换为代码 esprima与babel常用的满足上述3个要点的工具包有两个，一个是esprima，一个是babel esprima相关包及使用如下 1234567891011const esprima = require('esprima'); // code =&gt; astconst estraverse = require('estraverse'); //ast遍历const escodegen = require('escodegen'); // ast =&gt; codelet code = 'const a = 1';const ast = esprima.parseScript(code);estraverse.traverse(ast, { enter: function (node) { //节点操作 }});const transformCode = escodegen.generate(ast); babel相关包及使用如下 123456789101112const parser = require('@babel/parser'); //code =&gt; astconst traverse = require('@babel/traverse').default; // ast遍历，节点增删改查，作用域处理等const generate = require('@babel/generator').default; // ast =&gt; codeconst t = require('@babel/types'); // 用于AST节点的Lodash式工具库,各节点构造、验证等let code = 'const a = 1';let ast = parser.parse(sourceCode);traverse(ast, { enter (path) { //节点操作 }})const transformCode = escodegen.generate(ast); 目前babel不管是从生态上还是文档上比esprima要好很多，因此推荐大家使用babel工具，本文示例也使用babel来做演示。 使用babel工具操作AST如上一章节所示 @babel/parser用于将代码转换为AST @babel/traverse用于对AST的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将AST转换成代码 @babel/types 用于AST节点操作的Lodash式工具库,各节点构造、验证等 更多api详见babel手册[1] 下面通过简单案例来介绍如何操作AST，注意案例只是示例，由于篇幅对部分边界问题只会注释说明，实际开发过程中需要考虑周全。 案例1:去掉代码中的console.log()实现代码 123456789101112131415161718192021const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `function square(n) { console.log(n); console.warn(n); return n * n;}`let ast = parser.parse(sourceCode);traverse(ast, { CallExpression(path) { let { callee } = path.node; if (callee.type === ‘MemberExpression’ &amp;&amp; callee.object.name === ‘console’ &amp;&amp; callee.property.name === ‘log’ ) { path.remove(); // 注意考虑对象挂载的识别，如global.console.log()，此时remove后剩下global.,会导致语法错误，此时可以判断父节点类型来排除 } }})console.log(generate(ast).code); 处理结果 12345function square(n) {- console.log(n); console.warn(n); return n * n;} 此案例涉及知识点 如何通过traverse遍历特定节点 识别出console.log()在规范中属于函数调用表达式,节点类型为CallExpression。 console.log本身即callee是在对象console上的一个方法，因此console.log是一个成员表达式，类型为MemberExpression。 MemberExpression根据规范有一个object属性代表被访问的对象，有一个property代表访问的成员。 通过path.remove()api可以对节点进行删除。 可以通过https://astexplorer.net/ 来辅助对代码节点的识别。注意选择babylon7，即babe7,对应@babel/parser 案例2:变量混淆实现代码 12345678910111213141516171819const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `function square(number) { console.warn(number); return number * number;}`let ast = parser.parse(sourceCode);traverse(ast, { FunctionDeclaration(path) { let unia = path.scope.generateUidIdentifier(\"a\"); path.scope.rename(\"number\",unia.name); }})console.log(generate(ast).code); 处理结果 1234567-function square(number) {+ function square(_a) {- console.warn(number);+ console.warn(_a);- return number * number;+ return _a * _a;} 此案例涉及知识点 path.scope保存了当前作用域的相关信息 可以通过api对作用域内的变量名进行批量修改操作 通过path.scope可以获得当前作用域唯一标识符，避免变量名冲突 案例3:转换箭头函数并去掉未使用参数实现代码 123456789101112131415161718192021222324252627const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(1); },200)});`let ast = parser.parse(sourceCode);traverse(ast, { ArrowFunctionExpression (path) { let { id, params, body } = path.node; for(let key in path.scope.bindings){ //注意考虑箭头函数的this特性，若发现函数体中有this调用，则需要在当前作用域绑定其父作用域的this if(!path.scope.bindings[key].referenced){ params = params.filter(param=&gt;{ return param.name!==key; }) } } path.replaceWith(t.functionExpression(id, params, body)); }})console.log(generate(ast).code); 处理结果 1234567-new Promise((resolve,reject)=&gt;{+new Promise(function(resolve){- setTimeout(()=&gt;{+ setTimeout(function(){ resolve(1); },200)}); 此案例涉及知识点 箭头函数节点：ArrowFunctionExpression 通过path.scope可以识别变量引用情况，是否有被引用，被哪些路径引用 通过@babel/types可以很方便的构建任意类型节点 通过path.replaceWith()可以进行节点替换 案例4:京东购物小程序的Tree-shaking删掉小程序中的冗余代码，部分实现代码示例如下 1234567891011121314151617181920212223242526272829const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `export function square (x) { return x * x;}export function cube (x) { return x * x * x;}`let ast = parser.parse(sourceCode);traverse(ast, { ExportNamedDeclaration (path) { let unused = ['cube'] // 借助webpack，我们能获得导出的方法中，哪些是没有被使用过的 let { declaration = {} } = path.node; if (declaration.type === 'FunctionDeclaration') { unused.forEach(exportItem =&gt; { // references=1表示仅有一次引用，即export的引用，没有在别处调用 if (declaration.id.name === exportItem &amp;&amp; path.scope.bindings[exportItem].references === 1) { path.remove(); } }); } }})console.log(generate(ast).code); 处理结果 123456export function square (x) { return x * x;}-export function cube (x) {- return x * x * x;-} 此案例涉及知识点 export节点：ExportNamedDeclaration 案例5:将代码转换成svg流程图此案例是git上一个比较有意思的开源项目，通过AST将代码转换为svg流程图，详见js-code-to-svg-flowchart[2] 可以体验一下：demo[3] 通过以上示例，可以看到通过AST我们可以对代码任意蹂躏，做出很多有意思的事情 AST在其他语言的应用除了Javascript，其他语言如HTML、CSS、SQL等也有广泛的AST应用。如下图，可以在这里找到对应语言的解析器，开启AST之门。 结语在上述AST网站中，可以看到HTML的解析器有个vue选项，读过vue源码的同学应该知道vue模板在转换成HTML之前会先将模板转换成AST然后生成render function进而生成VirtualDOM。我们平时开发对AST使用比较少，但其实到处都能见到AST的影子：babel、webpack、eslint、taro等等。希望能抛砖引玉，使同学们在各自团队产出更多基于AST的优秀工具、项目。 References[1] babel手册：https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md[2] js-code-to-svg-flowchart：https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart[3] demo：https://bogdan-lyashenko.github.io/js-code-to-svg-flowchart/docs/live-editor/index.html","link":"/2019/07/20/Javascript抽象语法树下篇(实践篇)/"},{"title":"手把手教你写webpack loader","text":"作者：黄浩群 一、什么是 loaderloader 和 plugins 是 webpack 系统的两大重要组成元素。依靠对 loader、plugins 的不同组合搭配，我们可以灵活定制出高度适配自身业务的打包构建流程。 loader 是 webpack 容纳各类资源的一个重要手段，它用于对模块的源代码进行转换，允许你在 import 或加载模块时预处理文件，利用 loader，我们可以将各种类型的资源转换成 webpack 本质接受的资源类型，如 javascript。 二、如何编写一个 yaml-loader1、YAMLyaml 语言多用于编写配置文件，结构与 JSON 类似，但语法格式比 JSON 更加方便简洁。yaml 支持注释，大小写敏感，使用缩进来表示层级关系： 123456789101112131415161718192021#对象 version: 1.2.4#数组author: - Mike - Hankle#常量name: \"my project\" #定义一个字符串limit: 30 #定义一个数值es6: true #定义一个布尔值openkey: Null #定义一个null#锚点引用server: base: &amp;base port: 8005 dev: ip: 120.168.117.21 &lt;&lt;: *base gamma: ip: 120.168.117.22 &lt;&lt;: *base 等同于： 123456789101112131415161718192021{ \"version\": \"1.2.4\", \"author\": [\"Mike\", \"Hankle\"], \"name\": \"my project\", \"limit\": 30, \"es6\": true, \"openkey\": null, \"server\": { \"base\": { \"port\": 8005 }, \"dev\": { \"ip\": \"120.168.117.21\", \"port\": 8005 }, \"gamma\": { \"ip\": \"120.168.117.22\", \"port\": 8005 } }} 在基于 webpack 构建的应用中，如果希望能够引用 yaml 文件中的数据，就需要一个 yaml-loader 来支持编译。一般情况下，你都能在 npm 上找到可用的 loader，但如果万一没有对应的支持，或者你希望有一些自定义的转换，那么就需要自己编写一个 webpack loader 了。 2、loader 的原理loader 是一个 node 模块，它导出为一个函数，用于在转换资源时调用。该函数接收一个 String/Buffer 类型的入参，并返回一个 String/Buffer 类型的返回值。一个最简单的 loader 是这样的： 1234// loaders/yaml-loader.jsmodule.exports = function(source) { return source;}; loader 支持管道式传递，对同一类型的文件，我们可以使用多个 loader 进行处理，这批 loader 将按照“从下到上、从右到左”的顺序执行，并以前一个 loader 的返回值作为后一个 loader 的入参。这个机制无非是希望我们在编写 loader 的时候能够尽量避免重复造轮子，只关注需要实现的核心功能。因此配置的时候，我们可以引入 json-loader： 123456789101112131415161718192021// webpack.config.jsconst path = require(\"path\");module.exports = { // ... module: { rules: [ { test: /\\.yml$/, use: [ { loader: \"json-loader\" }, { loader: path.resolve(__dirname, \"./loaders/yaml-loader.js\") } ] } ] }}; 3、开始这样一来，我们需要的 yaml-loader，就只做一件事情：将 yaml 的数据转化成为一个 JSON 字符串。因此，我们可以很简单地实现这样一个 yaml-loader： 123456789101112var yaml = require(\"js-yaml\");module.exports = function(source) { this.cacheable &amp;&amp; this.cacheable(); try { var res = yaml.safeLoad(source); return JSON.stringify(res, undefined, \"\\t\"); } catch (err) { this.emitError(err); return null; }}; 就是这么简单。但是可能有朋友会问，这里是因为有个现成的模块 js-yaml，可以直接将 yaml 转换成 JavaScript 对象，万一没有这个模块，该怎么做呢？是的，loader 的核心工作其实就是字符串的处理，这是个相当恶心的活儿，尤其是在这类语法转换的场景上，对源代码的字符串处理将变得极其复杂。这个情况下，我们可以考虑另外一种解法，借助 AST 语法树，来协助我们更加便捷地操作转换。 4、利用 AST 作源码转换yaml-ast-parser 是一个将 yaml 转换成 AST 语法树的 node 模块，我们把字符串解析的工作交给了 AST parser，而操作 AST 语法树远比操作字符串要简单、方便得多： 1234567891011121314151617181920212223const yaml = require(\"yaml-ast-parser\");class YamlParser { constructor(source) { this.data = yaml.load(source); this.parse(); } parse() { // parse ast into javascript object }}module.exports = function(source) { this.cacheable &amp;&amp; this.cacheable(); try { const parser = new YamlParser(source); return JSON.stringify(parser.data, undefined, \"\\t\"); } catch (err) { this.emitError(err); return null; }}; 这里我们可以利用 AST parser 提供的方法直接转化出 json，如果没有或者有所定制，也可以手动实现一下 parse 的过程，仅仅只是一个树结构的迭代遍历而已，关键步骤是对 AST 语法树的各类型节点分别进行处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const yaml = require(\"yaml-ast-parser\");const types = yaml.Kind;class YamlParser { // ... parse() { this.data = this.traverse(this.data); } traverse(node) { const type = types[node.kind]; switch (type) { // 对象 case \"MAP\": { const ret = {}; node.mappings.forEach(mapping =&gt; { Object.assign(ret, this.traverse(mapping)); }); return ret; } // 键值对 case \"MAPPING\": { let ret = {}; // 验证 const keyValid = yaml.determineScalarType(node.key) == yaml.ScalarType.string; if (!keyValid) { throw Error(\"键值非法\"); } if (node.key.value == \"&lt;&lt;\" &amp;&amp; types[node.value.kind] === \"ANCHOR_REF\") { // 引用合并 ret = this.traverse(node.value); } else { ret[node.key.value] = this.traverse(node.value); } return ret; } // 常量 case \"SCALAR\": { return node.valueObject !== undefined ? node.valueObject : node.value; } // 数组 case \"SEQ\": { const ret = []; node.items.forEach(item =&gt; { ret.push(this.traverse(item)); }); return ret; } // 锚点引用 case \"ANCHOR_REF\": { return this.traverse(node.value); } default: throw Error(\"unvalid node\"); } }}// ... 当然这样的实现略为粗糙，正常来说，一些完备的 AST parser 一般都会自带遍历方法（traverse），这样的方法都是有做过优化的，我们可以直接调用，尽量避免自己手动实现。 按照相同的做法，你还可以实现一个 markdown-loader，甚至更为复杂的 vue-loader。 三、loader 的一些开发技巧1、单一任务只做一件事情，做好一件事情。loader 的管道（pipeline）设计正是希望能够将任务拆解并独立成一个个子任务，由多个 loader 分别处理，以此来保证每个 loader 的可复用性。因此我们在开发 loader 前一定要先给 loader 一个准确的功能定位，从通用的角度出发去设计，避免做多余的事。 2、无状态loader 应该是不保存状态的。这样的好处一方面是使我们 loader 中的数据流简单清晰，另一方面是保证 loader 具有良好可测性。因此我们的 loader 每次运行都不应该依赖于自身之前的编译结果，也不应该通过除出入参外的其他方式与其他编译模块进行数据交流。当然，这并不代表 loader 必须是一个无任何副作用的纯函数，loader 支持异步，因此是可以在 loader 中有 I/O 操作的。 3、尽可能使用缓存在开发时，loader 可能会被不断地执行，合理的缓存能够降低重复编译带来的成本。loader 执行时默认是开启缓存的，这样一来， webpack 在编译过程中执行到判断是否需要重编译 loader 实例的时候，会直接跳过 rebuild 环节，节省不必要重建带来的开销。 当且仅当有你的 loader 有其他不稳定的外部依赖（如 I/O 接口依赖）时，可以关闭缓存： 1this.cacheable &amp;&amp; this.cacheable(false);","link":"/2019/09/17/手把手教你写webpack-loader/"},{"title":"前端资源治理（一）","text":"作者：李刚松 0.也谈前端工程化随着前端技术的飞速发展，前端需要一种更加工程化的方式解决前端开发日益复杂的问题。前端工程化本质也是软件工程的一种，由于软件工程并无严格的定义(或者说缺乏统一的定义)，因此前端工程化的内涵其实相当宽泛，一般来说，前端工程化重点关注的是研发和维护效率，所有最终目的是这个的，都可以算作前端工程化的范畴。前端工程化近几年也是技术热点，基本上大型前端技术交流会议都有此专题，从规范、组件、编译及构建、工作流、持续集成、监控等多个维度都有涉及，笔者尝试从前端资源治理的角度谈一下前端工程化,本文是系列文章的第一篇，主要讲问题及解决的思路，不涉及具体的实现细节。 1.前端资源治理的含义首先，这里所说的前端资源，并非是仅指js、css、图片等静态资源，页面、后端接口、配置数据、监控点等，都可以纳入前端资源的定义的范畴。 在工作中，你是否会碰到以下问题： 同事或者领导发现某个页面有bug，需要在微信群或者内部沟通工具大群里问是谁负责？可能还要挨个艾特各个TL，需要各个TL确认。 某个组件要升级，但是不知道那些页面使用了，需要在沟通群里问或者搜项目源代码，逐个找到负责人。 某个大型营销活动突然要换一个新的氛围logo，但是不知道哪些页面使用了旧logo，需要安排巡检，人肉去找出来。 告警发现某个重要页面的出现了内容空窗，原因是运营同学没有及时补充运营数据，但是不知道是哪个运营负责，需要在微信大群或者内部沟通工具大群里问。 大促来临，某个重要页面的流量预计有10倍或者20倍的增长，要通知各个接口的同学做扩容和容灾准备，需要手工梳理页面的依赖的接口列表。 某个限时的页面已经到点下线，但是仍然有流量，不知道流量入口在哪里。 我要在统计系统上查看某个页面的性能数据，但是该系统是以页面名字而不是地址来查找的，查找过程找的人老眼昏花。 某个后端接口要升级或者要下线，需要分析nginx的访问日志找到页面地址，然后再拉各个TL，逐个确认都是哪些同事负责。 等等等 上面的问题一般是大型复杂业务场景（通常是多个团队合作开发，业务复杂，页面成百上千甚至上万）下才有的，如果你所在的团队也有上面的问题，那么我认为你也需要对前端的资源进行治理。 那么什么是前端资源治理呢？笔者对其的定义是： 将前端相关的页面、js/css/图片/字体、接口、配置、监控点等的依赖关系进行收集、存储和管理，并将割裂的组件系统、配置系统、监控系统、业务系统等进行重构和整合，最终形成以页面管理为基础的统一的有序的平台，所有关联信息都能够被查询和检索，最终实现整体协作效率的提升。 此处使用“治理”而不是“管理”的原因，“治理”一词更强调合作整改的过程。在很多互联网企业，通常已经有一些独立的组件系统、配置系统、监控系统等，但是这些系统很多都是独立的碎片化的系统，彼此都是割裂的，割裂意味着缺乏协同，进而影响研发效率。因此，前端资源治理的一个关键词是“整合”，整合已有的系统。 第二个关键词是“关联关系管理”，前端相关的页面、组件、js/css/图片/字体、接口、配置、监控点及负责人等，他们是存在关联关系的，比如页面是谁负责的、谁修改的、引用了哪些组件、图片、字体、接口、在什么地方配置数据、监控点都有哪些等，我们需要把这些关联关系在管理端记录下来，并提供检索和查询。 2.前端资源治理的实现前端资源信息看似繁杂，js、css、图片、页面、后端接口、配置数据、监控点等，但是他们有一个串联的锚点，这个锚点就是页面，不管是H5、小程序，还是原生APP，不管是从研发的角度，还是从反馈问题的角度，基本上都是以页面为单位进行的，其他的如组件、CSS、图片、接口、配置等，都是被页面引用的，都可以通过页面串联起来的，下图可以清晰的表达出这些依赖关系。 因此，实现前端资源治理的第一个要点是做好页面管理，把页面自身的信息，如页面名称、页面地址、负责人、修改时间等信息进行提取、存储,使之能够被查询和检索。在页面管理基础之上，我们还要把js、css、图片、页面、后端接口、配置数据、监控点等各个前端资源之间的关联关系也要存储和管理起来，使之能够被查询和检索。 关联关系从来源上讲，主要有以下几种来源： 代码静态分析产生。通常包括页面信息自身、页面跟js/css/图片等的依赖关系、页面跟接口的依赖关系等。 管理端配置产生。通常包括页面跟监控系统的配置、页面的运营配置数据等 统计数据产生。通常包括页面来源数据等。 2.1 页面信息的提取前端资源治理的第一要点是页面信息管理，因此必须能够拿到页面基本信息。页面基本信息应该包括哪些呢？通常来说，至少应该包括页面URL、页面名称、页面创建人、创建时间等几个字段。 当前的前端页面开发，不管是H5、小程序，还是原生APP，通常会经过编译构建的过程（通常是命令行工具或者IDE，比如基于gulp和webpack的工作流工具），在构建完成阶段可以提取出页面的基本信息。以下是编译构建提取页面信息的流程： 页面的编译构建流程，一般分为两种： 独立构建。常见于H5，此种场景一般是一个人负责一个页面，不存在多人协作的情况，也不需要git分支管理啥的，开发完成即可走构建流程，只需要在构建完成的时候分析即可，页面的URL、页面标题、创建人、创建时间等信息比较容易提取，比如页面修改人可以取自命令行工具的用户登录身份（命令行工具可以做类似于NPM的login功能，登录后记录用户身份ID）、页面标题可以解析页面html的title的内容（小程序下则解析自页面json文件的navigationBarTitleText字段）等。 持续集成构建。这种一般是需要多人协作的H5、小程序、原生APP等，一般涉及到分支管理和合并的问题，同一个页面可能被多人修改，因此页面信息中的用户信息部分提取相对复杂，需要分析git log信息才能拿到，其他的信息字段提取逻辑与独立构建情况相同。以下是一个典型的多人协作的页面的git log信息。 对于上面的情况，我们可以考虑定一个规则，比如取最近的5条log，并移除持续集成系统生成的log，管理端存储的时候回，以用户名+时间为key，去掉重复的部分。 构建流程分析出页面基本信息后，需提交到管理端保存，所以管理端需要提供post接口。管理端以此为基础，形成”页面管理系统“。 2.2 代码静态分析出的关联关系构建流程除可以分析基本信息外，还可以分析出页面的版本信息，比如页面依赖的组件依赖表、静态资源依赖表(js/css/图片)、接口依赖表、修改人、修改时间等。静态依赖分析通常有3种方式： 基于AST的依赖分析。AST就是抽象语法树，目前前端对他的研究和使用越来越广泛，webpack内部就使用了acorn这个AST分析库。借助于webpack强大的模块解析和依赖分析能力，我们可以拿到js与npm组件、css与背景图等之间的关联关系（可以在webpack的after-resolve钩子中进行分析）。另外，除了构建前的依赖关系，我们还可以拿到构建处理后的资源依赖关系（可以在webpac的emit钩子中进行分析），前者我们称为引用依赖关系（包括静态资源依赖表、组件依赖表），后者我们称为发布依赖关系。 基于DOM操作的依赖分析。webpack并不是以html为入口的，但是实际上我们的开发的入口可以认为就是页面，借助于JsDom等强大的类库，我们可以用我们熟悉的前端的DOM操作来分析html页面对js、css、图片等的依赖关系。 基于正则匹配的依赖分析。页面对于接口的依赖分析，由于这种是非明确的代码依赖关系，所以一般通过正则匹配来解析。一般对代码有一定的约束规则，比如不用用变量拼接接口地址。这个解析不会如AST那么精确，但是只要约定规则，基本上都能满足需求。可以考虑把此类实现封装为webpack的loader。上面的第一种和第三种的分析，都应该是一个递归分析过程，最终生成页面的静态资源依赖表、组件依赖表、接口依赖表等。这些信息提交到管理端进行保存。 2.3 管理系统之间的关联关系在很多互联网企业，通常已经有一些独立的成熟的CMS系统（如给运营用的内容配置系统，配置活动时间、商品ID等）、监控系统（如测速系统、业务监控系统、异常监控系统）等，通常这些系统由不同的团队开发，而且经常都有一个叫做”页面管理”的东西，且要手工配置页面地址。这些系统中的监控点配置、运营配置等信息，都是以页面维度进行创建和使用的，但是这些信息很难通过对前端代码静态分析的方法进行提取（比如运营配置信息，这个可以是前端直接使用，也可能是后端使用，要分析的话两端代码都要分析，比较麻烦）。我们的思路应该是在管理端通过页面管理来进行关联，实质上是要做系统整合。 整合的思路也比较简单，就是原来各个系统废弃掉原来自身的”页面管理“，而是使用前面静态分析提取到的统一的页面管理，监控系统、运营配置系统等系统都可以以此为入口进入，从而把页面相关的各个管理系统关联起来，进而把各种能力串联。 2.4 统计数据产生的关联关系对于大型应用来说，一般都有一些业务统计数据，最典型的就是点击流数据了。这种数据既不在代码中，也不在管理端配置，而且通过统计和分析才能拿到。前面提到的“某个限时的页面已经到点下线，但是仍然有流量，不知道流量入口在哪里”这种问题的解决，其实依赖于点击流的统计分析数据了，点击流系统一般都有“来源分析”，这种数据也不是敏感数据，所以可以考虑跟页面管理做关联和整合，或者提供API给页面管理系统。另外还有一个例子就是，接口和页面的关联关系，前面提到通过静态分析得到的页面和接口的依赖表有可能不够准确，但是接口访问Web Server的时候，一般都有access.log，可以通过access.log来做分析，拿到比较完整的页面依赖的接口信息，以及接口依赖的页面信息，有些接口的调用需要有open api的那种注册调用机制，就另当别论了。 2.5 关联关系的查询和存储管理端应该提供正反两个方向的查询和检索能力： 正向查询。通过页面来查询依赖的组件、静态资源(js/css/图片)、后端接口等。此种比较简单，因为提交的时候已经有完整的依赖信息，只需要提供简单的查询。 反向查询。通过组件、静态资源、接口、运营配置信息、监控配置信息等，反查有哪些页面依赖。 对于关联关系的存储，用关系型DB的话，一般只能使用like查询，可能要扫描全表，因而性能比较差，可以考虑存储到MongoDB中创建索引，或者存储到ElasticSearch中建立索引。 2.6 其他前面提到的，其实有一个假设的前提“只有一个Web应用，且接口都是前端发起的”，但是对于其他情况，思路是类似的： 多应用（业务）。多应用情况，通常要在页面管理的上一层加上“应用管理”，即页面属于哪一个应用(业务)。对于同一个页面投放在不同应用的场景，可能页面还得加上渠道标识。 页面直出（服务端渲染）。对于页面直出逻辑的代码，做前面类似的分析即可。另外，本文主要是探讨从前端视角考虑问题，所以关联核心是页面管理，但是从整体技术架构视角，可能就不是了。 3.结语本文探讨了前端资源治理的含义以及要解决的问题，并介绍了实现前端资源治理的思路，是笔者近期在前端工程化方面的思考，部分已经完成，部分正在推进。本文并不涉及实现的细节，细节在后面的系列文章中进一步讲解。前端治理的两个关键点，一个是系统整合，一个是关联关系管理，整体串联的核心是页面管理。","link":"/2019/09/24/前端资源治理（一）/"},{"title":"碰撞检测的向量实现","text":"作者： 吴冠禧 注：1、本文只讨论2d图形碰撞检测。2、本文讨论圆形与圆形，矩形与矩形、圆形与矩形碰撞检测的向量实现 前言2D游戏中，通常使用矩形、圆形等来代替复杂图形的相交检测。因为这两种形状的碰撞检测速度是最快的。其中矩形包围盒又可以分为轴对齐包围盒（AABB, Axis Aligned Bounding Box）与转向包围盒（OBB, Oriented Bounding Box）。AABB与OBB的区别在于，AABB中的矩形的其中一条边和坐标轴平行，OBB的计算复杂度要高于AABB。根据不同的使用场景，可以用不同的方案。 如上图，明显皮卡超适合用包围盒，精灵球适合用包围球。 向量向量作为一种数学工具，在碰撞检测中发挥很大作用，后面的计算都是通过向量来完成，所以先来复习一下向量。 向量的代数表示向量的代数表示指在指定了一个坐标系之后，用一个向量在该坐标系下的坐标来表示该向量，兼具了符号的抽象性和几何形象性，因而具有最高的实用性，被广泛采用于需要定量分析的情形。 对于自由向量，将向量的起点平移到坐标原点后，向量就可以用一个坐标系下的一个点来表示，该点的坐标值即向量的终点坐标。 123456789// 二维平面向量class Vector2d{ constructor(vx=1,vy=1){ this.vx = vx; this.vy = vy; }}const vecA = new Vector2d(1,2);const vecB = new Vector2d(3,1); 向量运算加法：向量的加法满足平行四边形法则和三角形法则。具体的，两向量相加还是一个向量，分别是x与y两个分量的相加。 123456// 向量的加法运算static add(vec,vec2){ const vx = vec.vx + vec2.vx; const vy = vec.vy + vec2.vy; return new Vector2d(vx,vy);} 减法：两个向量a和b的相减得到的向量可以表示为a和b的起点重合后，从b的终点指向a的终点的向量： 123456// 向量的减法运算static sub(vec,vec2){ const vx = vec.vx - vec2.vx; const vy = vec.vy - vec2.vy; return new Vector2d(vx,vy);} 大小：向量的大小，是其各个分量的平方和开方。 1234// 获取向量长度length(){ return Math.sqrt(this.vx * this.vx + this.vy * this.vy);} 点积：从代数角度看，先对两个数字序列中的每组对应元素求积，再对所有积求和，结果即为点积。 1234// 向量的数量积static dot(vec,vec2){ return vec.vx * vec2.vx + vec.vy * vec2.vy;} 旋转：向量的旋转可以用旋转矩阵求解 12345678//向量的旋转 static rotate(vec,angle){ const cosVal = Math.cos(angle); const sinVal = Math.sin(angle); const vx = vec.vx * cosVal - vec.vy * sinVal; const vy = vec.vx * sinVal + vec.vy * cosVal; return new Vector2d(vx,vy);} 圆圆形比较简单，只要确认圆心x,y和半径r就行了,然后推导出圆心向量。 123456789class Circle{ // x,y是圆的圆心 r是半径 constructor(x=0,y=0,r=1){ this.x = x; this.y = y; this.r = r; } get P(){ return new Vector2d(this.x,this.y) } // 圆心向量} 矩形矩形就较为复杂，定义一个矩形需要中心坐标的x,y、两边长w和h，还有根据中心的旋转角度rotation 12345678910export class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; }} 两圆相交 两圆相交比较简单，只需判断两圆心之间的距离小于两圆的半径之和。 两圆心距离可以用圆心向量相减，然后求相减向量的长度。 12345678circleCircleIntersect(circle1,circle2){ const P1 = circle1.P; const P2 = circle2.P; const r1 = circle1.r; const r2 = circle2.r; const u = Vector2d.sub(P1,P2); return u.length() &lt;= r1 + r2 ;} 圆和矩形相交涉及到矩形的相交问题都先要判断是否轴对称。 矩形轴对称 先看轴对称的情况，下面是来自知乎问题怎样判断平面上一个矩形和一个圆形是否有重叠？「Milo Yip」的回答搬运： 设c为矩形中心，h为矩形半長，p为圆心，r为半径。 方法是计算圆心与矩形的最短距离 u，若 u 的长度小于 r 则两者相交。 首先利用绝对值把 p - c 转移到第一象限，下图显示不同象限的圆心也能映射至第一象限，这不影响相交测试的结果： 然后，把 v 减去 h，负数的分量设置为0，就得到圆心与矩形最短距离的矢量 u。下图展示了4种情况，红色的u是结果。 最后要比较 u 和 r 的长度，若距离少于 r，则两者相交。可以只求 u 的长度平方是否小于 r 的平方。 下面我用js实现一下： 其中矩形的四个顶点命名为A1，A2，A3，A4，矩形在第一象限的半長h等于CA3 1234567891011121314151617181920212223class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量}rectCircleIntersect(rect,circle){ const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = circle.P; const h = Vector2d.sub(A3,C); // 矩形半长 const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 矩形非轴对称 这个问题其实也很好解决，将矩形中心视为旋转中心，将矩形和圆形一起反向旋转将矩形转为轴对称，然后就可以套用上面的解法。 矩形中心到圆心向量为是CP 反向旋转θ度得向量CP’ 然后根据向量得三角形定律得OP’ = OC + CP’ 后面就代入矩形是轴对称的公式进行计算 12345678910111213141516171819202122232425262728293031323334353637class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}p(rect,circle){ const rotation = rect.rotation; const C = rect.C; let P; if (rotation % 360 === 0) { P = circle.P; // 轴对称直接输出P } else { P = Vector2d.add(C,Vector2d.rotate(Vector2d.sub(circle.P,C),rect._rotation*-1)); // 非轴对称，计算P‘ } return P;}rectCircleIntersect(rect,circle){ const rotation = rect.rotation; const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = p(rect,circle); const h = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 查看Demo1 https://rococolate.github.io/blog/gom/test1.html 两矩形相交两矩形都轴对称AABB 想象一下两个矩形A和B，B贴着A的边走了一圈，B的矩形中心的轨迹是一个新的矩形，这样就简化成新矩形与B中心点这一点的相交问题，又因为点可以看成是半径为0的圆，所以问题又转换为圆形和矩形相交。 1234567891011121314151617181920212223242526class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}AABBrectRectIntersect(rect1,rect2){ const P = rect2.C; const w2 = rect2.w; const h2 = rect2.h; const {w,h,x,y} = rect1; const C = rect1.C; const A3 = new Vector2d(x+w/2+w2/2,y+h/2+h2/2); // 新矩形的半长 const H = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - H.vx,0),Math.max(v.vy - H.vy,0)); return u.lengthSquared() === 0; // 点可以看成是半径为0的圆} 两矩形相交非轴对称OBB 两个矩形的OBB检测使用分离轴定理（Separating Axis Theorem） 分离轴定理：通过判断任意两个矩形 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 因为矩形的对边平行，所以只要判断四条对称轴上的投影即可。 如何投影？这里补充一下向量点积的几何意义。 在欧几里得空间中，点积可以直观地定义为 A·B = |A||B|cosθ ,其中|A|cosθ是A到B的投影，如果B是单位向量，那么A·B就是A到单位向量B的投影 回到矩形，将矩形4个顶点都投影到对称轴上，我们分别将其点乘即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } get _A1(){ return new Vector2d(this.x-this.w/2,this.y-this.h/2); } // 4角顶点 get _A2(){ return new Vector2d(this.x+this.w/2,this.y-this.h/2); } get _A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } get _A4(){ return new Vector2d(this.x-this.w/2,this.y+this.h/2); } get _axisX(){ return new Vector2d(1,0); } // 未旋转时的对称轴X get _axisY(){ return new Vector2d(0,1); } // 未旋转时的对称轴Y get _CA1(){ return Vector2d.sub(this._A1,this.C); } get _CA2(){ return Vector2d.sub(this._A2,this.C); } get _CA3(){ return Vector2d.sub(this._A3,this.C); } get _CA4(){ return Vector2d.sub(this._A4,this.C); } get _rotation(){ return this.rotation / 180 * Math.PI; } get A1(){ return this.rotation % 360 === 0 ? this._A1 : Vector2d.add(this.C,Vector2d.rotate(this._CA1,this._rotation)); } // 计算上旋转后4角顶点 get A2(){ return this.rotation % 360 === 0 ? this._A2 : Vector2d.add(this.C,Vector2d.rotate(this._CA2,this._rotation)); } get A3(){ return this.rotation % 360 === 0 ? this._A3 : Vector2d.add(this.C,Vector2d.rotate(this._CA3,this._rotation)); } get A4(){ return this.rotation % 360 === 0 ? this._A4 : Vector2d.add(this.C,Vector2d.rotate(this._CA4,this._rotation)); } get axisX(){ return this.rotation % 360 === 0 ? this._axisX : Vector2d.rotate(this._axisX,this._rotation); } // 计算上旋转后的对称轴X get axisY(){ return this.rotation % 360 === 0 ? this._axisY : Vector2d.rotate(this._axisY,this._rotation); } // 计算上旋转后的对称轴Y get _vertexs(){ return [this._A1,this._A2,this._A3,this._A4]; } get vertexs(){ return [this.A1,this.A2,this.A3,this.A4]; } // 4角顶点数组}OBBrectRectIntersect(rect1,rect2){ const rect1AxisX = rect1.axisX; const rect1AxisY = rect1.axisY; const rect2AxisX = rect2.axisX; const rect2AxisY = rect2.axisY; if (!cross(rect1,rect2,rect1AxisX)) return false; // 一旦有不相交的轴就可以return false if (!cross(rect1,rect2,rect1AxisY)) return false; if (!cross(rect1,rect2,rect2AxisX)) return false; if (!cross(rect1,rect2,rect2AxisY)) return false; return true; // 4轴投影都相交 return true}cross(rect1,rect2,axis){ const vertexs1ScalarProjection = rect1.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形1的4个顶点投影并排序 const vertexs2ScalarProjection = rect2.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形2的4个顶点投影并排序 const rect1Min = vertexs1ScalarProjection[0]; // 矩形1最小长度 const rect1Max = vertexs1ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形1最大长度 const rect2Min = vertexs2ScalarProjection[0]; // 矩形2最小长度 const rect2Max = vertexs2ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形2最大长度 return rect1Max &gt;= rect2Min &amp;&amp; rect2Max &gt;= rect1Min; // 相交判断 } 最后放上一个相交的应用Demo https://rococolate.github.io/blog/gom/test2.html,Demo里的形状都可以拖拽，当碰到其他形状时会变透明。 参考文章第十五章：碰撞检测 http://blog.jmecn.net/chapter-15-collision-detection/ 方块的战争：浅谈格斗游戏的精髓 http://daily.zhihu.com/story/4761397 怎样判断平面上一个矩形和一个圆形是否有重叠？ https://www.zhihu.com/question/24251545 “等一下，我碰！”——常见的2D碰撞检测 https://aotu.io/notes/2017/02/16/2d-collision-detection/index.html 码农干货系列【1】–方向包围盒(OBB)碰撞检测 https://www.cnblogs.com/iamzhanglei/archive/2012/06/07/2539751.html Rotation matrix https://en.wikipedia.org/wiki/Rotation_matrix 数量积 https://zh.wikipedia.org/wiki/%E7%82%B9%E7%A7%AF 向量 https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F","link":"/2019/06/27/collision-detection/"},{"title":"【译】在生产环境中使用原生JavaScript模块","text":"原文地址：https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/原文作者：PHILIP WALTON译者：龚亮 ，校对：刘辉声明：本翻译仅做学习交流使用，转载请注明来源 两年前，我写了一篇有关module/nomodule技术的文章，这项技术允许你在编写ES2015+代码时，使用打包器和转换器生成两个版本的代码库，一个具有现代语法的版本（通过&lt;script type=&quot;module&quot;&gt;加载）和一个使用ES5语法的版本（通过&lt;script nomodule&gt;加载）。该技术允许你向支持模块（译者注：指ECMA制定的标准的export/import模块语法及其加载机制，又称为ES Module、ESM、ES6 Module、ES2015 Module，下文中将出现很多”模块”一词，都是这个含义）的浏览器发送更少的代码，现在大多数Web框架和CLI都支持它。 但是那时候，尽管能够在生产中部署现代JavaScript，大多数浏览器也都支持模块，我仍然建议打包你的代码。 为什么？主要是因为我觉得在浏览器中加载模块很慢。尽管像HTTP/2这样的新协议理论上有效地支持加载大量小文件，但当时的所有性能研究都认为使用打包器更有效。 其实当时的研究是不完整的。该研究所使用的模块测试示例由部署到生产环境中未优化和未缩小的源文件组成。它并没有将优化后的模块包与优化后的原始脚本进行比较。 不过，当时并没有更好的方法来部署模块(译者注：指遵循ES2015模块规范的文件)。但是现在，打包技术取得了一些最新进展，可以将生产代码部署为ES2015模块(包含静态导入和动态导入)，从而获得比非模块(译者注：指除ES2015模块外的传统部署方式)更好的性能。实际上，这个站点(译者注：指原文章所在的网站)已经在生产环境中使用原生模块好几个月了。 对模块的误解与我交流过的很多人都认为模块（译者注：指遵循ES2015模块规范的部署方式）是大规模生产环境下应用程序的一个选择罢了。他们中的许多人引用了我刚刚提到的研究，并建议不要在生产环境中使用模块，除非: …小型web应用程序，总共只有不到100个模块，依赖树相对较浅(即最大深度小于5)。 如果你曾经查看过node_modules目录，可能知道即使是小型应用程序也很容易有超过100个模块依赖项。我们来看看npm上一些流行的工具包有多少个模块依赖项吧： 包 模块数量 date-fns 729 lodash-es 643 rxjs 226 人们对模块的主要误解是，在生产环境中使用模块时只有两个选择：(1)按原样部署所有源代码(包括node_modules目录)，(2)完全不使用模块。 如果你仔细考虑我所引用研究给出的建议，它没有说加载模块比普通加载脚本慢，也没有说你不应该使用模块。它只是说，如果你将数百个未经过压缩的模块文件部署到生产环境中，Chrome将无法像加载单个经过压缩的模块一样快速的加载它们。所以建议继续使用打包器、编译器和压缩器（译者注：原文是minifier，指去除空格注释等）。 实际情况是，你可以在生产环境中使用上面所有技术的同时，也可以使用ES2015模块！ 事实上，因为浏览器已经知道如何加载模块（对不支持模块的浏览器可以做降级处理），所以模块才是我们应该打包出的格式。如果你检查大多数流行的打包器生成的输出代码，你会发现很多样板代码（译者注：指rollup和webpack中的runtime的代码），其唯一的目的是动态加载其它代码并管理依赖，但如果我们只使用带有import和export语句的模块，则不需要这些代码！ 幸运的是，今天至少有一个流行的打包器（Rollup）支持模块作为输出格式，这意味着可以打包代码并在生产环境中部署模块（没有加载器样板代码）。由于Rollup（根据我的经验，这是最好的打包器）具有出色的tree-shaking，使得Rollup打包出的模块是目前所有打包器输出模块中代码最少的。 更新： Parcel计划在下一版本中添加模块支持。Webpack目前不支持模块输出格式，但这里有一些相关讨论＃2933，＃8895，＃8896。 另一个误解是，除非你的所有依赖项都使用模块，否则你不能使用模块。不幸的是大多数npm包仍然以CommonJS的形式发布(甚至有些包以ES2015编写，但在发布到npm之前转换为CommonJS)！ 尽管如此，Rollup有一个插件（rollup-plugin-commonjs），它可以将CommonJS源代码转换为ES2015。如果一开始你的依赖项采用ES2015模块管理肯定会更好，但是有一些依赖关系不是这样管理的并不会阻止你部署模块。 在本文的剩余部分，我将向你展示如何打包到模块（包括使用动态导入和代码拆分的粒度），解释为什么它通常比原始脚本更高效，并展示如何处理不支持模块的浏览器。 最优打包策略打包生产代码一直是需要权衡利弊。一方面，希望代码尽快加载和执行。另一方面，又不希望加载用户实际用不到的代码。 同时，还希望代码尽可能地被缓存。打包的一个大问题是，即使只是一行代码有修改也会使整个打包后的包缓存失效。如果直接使用ES2015模块部署应用程序（就像它们在源代码中一样），那么你可以自由地进行小的更改，同时让应用程序的大部分代码仍然保留在缓存中。但就像我已经指出的那样，这也意味着你的代码需要更长时间才能被新用户的浏览器加载完成。 因此，找到最优打包粒度的挑战是在加载性能和长期缓存之间取得适当的平衡。 默认情况下，大多数打包器在动态导入时进行代码拆分，但我认为仅动态导入的代码拆分粒度不够细，特别是对于拥有大量留存用户的站点（缓存很重要）。 在我看来，你应该尽可能细粒度地拆分代码，直到开始显著地影响加载性能为止。虽然我强烈建议你自己动手进行分析，但是查阅上文引用的研究可以得出一个大致的结论。当加载少于100个模块时，没有明显的性能差异。针对HTTP/2性能的研究发现，加载少于50个文件时没有明显的差异(尽管他们只测试了1、6、50和1000，所以100个文件可能就可以了)。 那么，最好的代码拆分方法是什么呢？除了通过动态导入做代码拆分外，我还建议以npm包为粒度做代码拆分，node_modules中的模块都合并到以其包名命名的文件中。 包级别的代码拆分如上所述，打包技术的一些最新进展使得高性能模块部署成为可能。我提到的增强是指Rollup的两个新功能：通过动态import()时自动代码拆分（在v1.0.0中添加）和通过manualChunks选项进行可编程的手动代码拆分（在v1.11.0中添加）。 有了这两个功能，现在很容易在包级别进行代码拆分的构建配置。 这是一个使用manualChunks选项配置的例子，每个位于node_module里的模块将被合并到以包名命名的文件里(当然，这种模块路径里肯定包含node_modules) 1234567891011121314151617181920export default { input: { main: &apos;src/main.mjs&apos;, }, output: { dir: &apos;build&apos;, format: &apos;esm&apos;, entryFileNames: &apos;[name].[hash].mjs&apos;, }, manualChunks(id) { if (id.includes(&apos;node_modules&apos;)) { // Return the directory name following the last `node_modules`. // 返回最后一个node_modules后面跟着的目录名 // Usually this is the package, but it could also be the scope. // 通常都会是一个包名，也有可能是一个私有域 const dirs = id.split(path.sep); return dirs[dirs.lastIndexOf(&apos;node_modules&apos;) + 1]; } },} manualChunks选项接收一个函数，该函数将模块文件路径作为惟一的参数，也可以返回一个文件名，参数中的模块将被加入到这个文件里。如果没有返回任何内容，参数中的模块将被添加到默认文件中。 考虑从lodash-es包中导入cloneDeep()、debounce()和find()模块的一个应用程序。上面的配置将把各个模块(以及它们导入的任何其它lodash模块)一起放入一个名为npm.lodash-es.XXXX.mjs的输出文件中，(其中XXXX是lodash-es模块文件的哈希值)。 在该文件的末尾，你会看到这样的导出语句(注意，它只包含添加到块中模块的导出语句，而不是所有lodash模块): 1export {cloneDeep, debounce, find}; 希望这个例子能清楚地说明使用Rollup手动拆分代码的工作原理。就我个人而言，我认为使用import和export语句的代码拆分比使用非标准的、特定于打包器实现的代码拆分更容易阅读和理解。 例如，跟踪这个文件中发生了什么很难(我以前使用webpack对一个项目做代码拆分后的实际输出)，而且在支持模块的浏览器中其实不需要这些代码: 12345678910111213141516171819(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[&quot;import1&quot;],{/***/ &quot;tLzr&quot;:/*!*********************************!*\\ !*** ./app/scripts/import-1.js ***! \\*********************************//*! exports provided: import1 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;import1&quot;, function() { return import1; });/* harmony import */ var _dep_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dep-1 */ &quot;6xPP&quot;);const import1 = &quot;imported: &quot; + _dep_1__WEBPACK_IMPORTED_MODULE_0__[&quot;dep1&quot;];/***/ })}]); 如果你有数百个npm依赖项怎么办？我在上面说过，我认为包级别上的代码拆分是站点代码拆分的最佳状态，而又不会太激进。 当然，如果你的应用程序从数百个不同的npm包中导入模块，那么浏览器可能无法有效地加载所有模块。 但是，如果你确实有很多npm依赖项，那么先不要完全放弃这个策略。请记住，你可能不会在每个页面上加载所有的npm依赖项，因此检查实际加载了多少依赖项非常重要。 尽管如此，确实有一些非常大的应用程序具有如此多的npm依赖关系，以至于它们不能实际地对其中的每一个应用程序进行代码拆分。如果你是这种情况，我建议你找出一种方法来将一些依赖项分组到公共文件中。一般来说，你可以将可能在同一时间发生变化的包(例如，React和react-dom)分组，因为它们必须一起失效(例如，我稍后展示的示例应用程序将所有React依赖项分组为同一个文件)。 动态导入使用原生import语句进行代码拆分和模块加载的一个缺点是，需要开发人员对不支持模块的浏览器做兼容处理。 如果你想使用动态import()懒加载代码，那么你还必须处理这样一个事实：有些浏览器支持模块，但不支持动态import()（Edge 16–18, Firefox 60–66, Safari 11, Chrome 61–63）。 幸运的是，一个很小的(~400字节)、非常高性能的polyfill可用于动态import()。 向站点添加polyfill很容易。你所要做的是导入它并在应用程序的主入口点初始化它(在调用import()之前): 12345import dynamicImportPolyfill from &apos;dynamic-import-polyfill&apos;;// This needs to be done before any dynamic imports are used. And if your// modules are hosted in a sub-directory, the path must be specified here.dynamicImportPolyfill.initialize({modulePath: &apos;/modules/&apos;}); 最后要做的是告诉Rollup将输出代码中的动态import()重命名为你指定的另一个名称(通过output.dynamicImportFunction选项配置)。动态导入polyfill默认使用名称为import，但是可以配置它。 需要重命名import()语句的原因是import是JavaScript中的一个关键字。这意味着不可能使用相同的名称来填充原生import()，因为这样做会导致语法错误。 让Rollup在构建时重命名它是很好的，这意味着你的源代码可以使用标准版本，并且在将来不再需要polyfill时，你将不必重新更改它。 高效加载JavaScript模块当你使用代码拆分的时候，最好预加载所有马上要使用的模块(即主入口模块导入图中的所有模块)。 但是，当你加载实际的JavaScript模块（通过&lt;script type=&quot;module&quot;&gt;以及随后import语句引用的模块时），你将希望使用modulepreload而不是传统的preload(仅适用于原始脚本)。 123456&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-one.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-two.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-three.XXXX.mjs&quot;&gt;&lt;!-- ... --&gt;&lt;script type=&quot;module&quot; src=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;/script&gt; 实际上，对于预加载原生的模块，modulepreload实际上比传统的preload要严格得多，它不仅下载文件，而且在主线程之外立即开始解析和编译文件。传统的预加载无法做到这一点，因为它不知道在预加载时该文件将用作模块脚本还是原始脚本。 这意味着通过modulepreload加载模块通常会更快，而且在实例化时不太可能导致主线程卡顿。 生成modulepreload列表Rollup的bundle对象中的每个入口文件在其静态依赖关系图中包含完整的导入列表，因此在Rollup的generateBundle钩子中很容易获得需要预加载哪些文件的列表。 虽然在npm上确实存在一些modulepreload插件，但是为图中的每个入口点生成一个modulepreload列表只需要几行代码，所以我更愿意像这样手动创建它: 123456789101112131415{ generateBundle(options, bundle) { // A mapping of entry chunk names to their full dependency list. const modulepreloadMap = {}; for (const [fileName, chunkInfo] of Object.entries(bundle)) { if (chunkInfo.isEntry || chunkInfo.isDynamicEntry) { modulepreloadMap[chunkInfo.name] = [fileName, ...chunkInfo.imports]; } } // Do something with the mapping... console.log(modulepreloadMap); }} 例如，这里是我如何为这个站点以及我的demo应用生成modulepreload列表的。 注意：虽然对于模块脚本来说，modulepreload绝对比原始的preload更好，但它对浏览器的支持更差(目前只支持chrome)。如果你的流量中有相当一部分是非chrome流量，那么使用classic preload是有意义的。 与使用modulepreload不同，使用preload时需要注意的一点是，预加载脚本不会放在浏览器的模块映射中，这意味着可能会不止一次地处理预加载的请求(例如，如果模块在浏览器完成预加载之前导入文件)。 为什么要部署原生模块？如果你已经在使用像webpack这样的打包器，并且已经在使用细粒度代码拆分和预加载这些文件(与我在这里描述的类似)，那么你可能想知道是否值得改变策略，使用原生模块。下面是我认为你应该考虑它的几个原因，以及为什么打包到原生模块比使用带有模块加载代码的原始脚本要好。 更小的代码总量当使用原生模块时，现代浏览器不必为用户加载任何不必要的模块加载或依赖关系管理代码。例如，如果使用原生模块，则根本不需要webpack运行时和清单。 更好的预加载正如我在前一节中提到的，使用modulepreload允许你加载代码并在主线程之外解析/编译代码。在其他条件相同的情况下，这意味着页面的交互速度更快，并且主线程在用户交互期间不太可能被阻塞。 因此，无论你如何细粒度地对应用程序进行代码拆分，使用import语句和modulepreload加载模块要比通过原始script标签和常规preload加载更有效(特别是如果这些标签是动态生成的，并在运行时添加到DOM中)。 换句话说，由Rollup打包出的20个模块文件将比由webpack打包出的20个原始脚本文件加载得更快(不是因为webpack，而是因为它不是原生模块)。 更面向未来许多最令人兴奋的新浏览器特性都是构建在模块之上的，而不是原始的脚本。这意味着，如果你想使用这些特性中的任何一个，你的代码需要作为原生模块部署，而不是转换为ES5并通过原始的script标签加载(我在尝试使用实验性KV存储API时曾提到过这个问题)。 以下是一些仅限模块才有的最令人兴奋的新功能： 内置模块 HTML模块 CSS模块 JSON模块 导入地图 workers、service workers和window之间共享模块 支持旧版浏览器在全球范围内，超过83%的浏览器原生支持JavaScript模块(包括动态导入)，因此对于你的大多数用户来说，不需要做任何处理就可以使用这项技术。 对于支持模块但不支持动态导入的浏览器，可以使用上面提到的dynamic-import-polyfill。由于polyfill非常小，并且在可用时将使用浏览器的原生动态import()，因此添加这个polyfill几乎没有大小或性能成本。 对于根本不支持模块的浏览器，可以使用我前面提到的module/nomodule技术。 一个实际的例子由于谈论跨浏览器兼容性总是比实际实现它要容易，所以我构建了一个演示应用程序，它使用了我在这里阐述的所有技术。 这个演示程序可以在不支持动态import()的浏览器中运行(如Edge 18和Firefox ESR)，也可以在不支持模块的浏览器中运行(如Internet Explorer 11)。 为了说明这个策略不仅适用于简单的用例，我还包含了当今复杂的JavaScript应用程序需要的许多特性: Babel转换（包括JSX） CommonJS的依赖关系（例如react，react-dom） CSS依赖项 Asset hashing 代码拆分 动态导入（带有polyfill降级机制） module/nomodule降级机制 代码托管在GitHub上(因此你可以派生repo并自己构建它)，而演示则托管在Glitch上，因此你可以重新组合代码并使用这些特性。 最重要的是查看示例中使用的Rollup配置，因为它定义了如何生成最终模块。 总结希望这篇文章让你相信，现在不仅可以在生产环境中部署原生JavaScript模块，而且这样做可以提高站点的加载和运行时性能。 以下是快速完成此工作所需步骤的摘要： 使用打包器，但要确保输出格式为ES2015模块 积极地进行代码拆分(如果可能的话，一直到node包) 预加载静态依赖关系图中的所有模块(通过modulepreload) 使用polyfill来支持不支持动态import()的浏览器 使用&lt;script nomodule&gt;支持根本不支持模块的浏览器 如果你已经在构建设置中使用了Rollup，我希望你尝试这里介绍的技术，并在生产环境中部署原生模块(带有代码拆分和动态导入)。如果你这样做了，请告诉我进展如何，因为我既想听你的问题，也想听你的成功故事！ 模块是JavaScript的明确未来，我希望我们所有的工具和依赖都能尽快包含模块。希望本文能在这个方向上起到一点推动作用。 译者评：1.作者上一篇文章的译文：https://jdc.jd.com/archives/49112.另外一篇讲JavaScript原生模块的文章：https://www.jianshu.com/p/9aae3884b05b","link":"/2019/09/10/【译】在生产环境中使用原生JavaScript模块/"},{"title":"你还在用图片做引导蒙层？","text":"作者：深山蚂蚁 引导蒙层通常在新业务上线、或者业务有变更时的给新用户的一个操作指引。下图页面即是一个蒙层，会在某个局部位置高亮我们需要重点突出的内容： 当前发现很多页面做蒙层引导，还是使用图片形式来做。 图片引导蒙层有几大缺点： 图片大，影响加载 图片的内容都是假的，和真实的底部内容没对上 全屏蒙层图片，图片的宽高和屏幕宽高不一致，显示两边留黑，或者有压缩的效果。 图片的引导位置不能点击。 low ？ not cool ？ 本文讲述六种思路来实现引导蒙层 z-index实现蒙层 动态opacity实现 border实现 box-shadow实现 节点复制实现 canvas实现 以上六种引导蒙层实现思路，在一定情况下都能满足业务需求，从不同角度来实现了引导蒙层。z-index最简单，canvas最灵活，就个人而言，更加喜欢骨架屏式的动态opacity蒙层实现，更有趣更酷!!! 思路一：使用z-index 新增一个div，设置为半透明区域，大小覆盖整个页面 半透明蒙层区域z-index大于页面元素 引导内容区域大于半透明蒙层区域z-index 这个好理解，页面元素都是有层级的，我们只需要把引导内容区域设置为最顶层的层级，在引导内容区域之下设置一个遮罩层，其他内容元素的z-index都地域这个遮罩层即可。 我们来看一个简单例子。 123456789101112131415161718192021222324252627.z1{ position:absolute; left:50px; top:50px; width:50px; height:50px; background:blue; z-index:1;}.z2{ position:absolute; left:60px; top:60px; width:50px; height:50px; background:red; z-index:2;}.z3{ position:absolute; left:70px; top:70px; width:50px; height:50px; background:yellow; z-index:3;} 我们修改一下z2的样式。 12345678910111213141516171819202122232425.z2{ position:absolute; left:50px; top:50px; width:50px; height:50px; background:black; opacity:0.5; z-index:2; animation:z_index 2s linear infinite alternate;}@keyframes z_index { from { left:50px; top:50px; width:50px; height:50px; } to { left:0px; top:0px; width:200px; height:200px; } } 只要在布局页面元素的时候，把需要做蒙层的元素确定好，配合js，动态的设置元素的z-index + opacity，就可以很好的做到页面的引导蒙层效果。 思路二：使用opacity将非蒙层元素半透明 引导内容区域无需改动 页面其他节点元素半透明 我们不再新增蒙层，而是完全操作页面节点，将需要遮罩的节点都设置为半透明，引导蒙层显现内容则完全显示出来。页面的效果和蒙层不太一样，对于空白地方，我们仍然是完全显示，只是将有内容的元素给半透明，类似骨架屏的效果。为了演示效果，我们看如下例子：页面设置6个元素。 12345678&lt;div class=\"wrap\"&gt; &lt;div class=\"z z1\"&gt;&lt;/div&gt; &lt;div class=\"z z2\"&gt;&lt;/div&gt; &lt;div class=\"z z3\"&gt;&lt;/div&gt; &lt;div class=\"z z4\"&gt;&lt;/div&gt; &lt;div class=\"z z5\"&gt;&lt;/div&gt; &lt;div class=\"z z6\"&gt;&lt;/div&gt; &lt;/div&gt; 将元素内容用flex并排布局。 12345678910111213141516171819202122232425262728.wrap{ display:flex; flex-wrap:wrap; width:150px;}.z{ width:50px; height:50px; transition:all 1s;}.z1{ background:blue;}.z2{ background:black;}.z3{ background:yellow;}.z4{ background:red;}.z5{ background:green;}.z6{ background:orange;} 使用js操作，依次半透明其他元素，显示当前元素来模拟蒙层。 1234567891011121314151617let arry = Array.from(document.querySelectorAll(\".z\"));let index = -1;let direct = 1;setInterval(()=&gt;{ if(index&gt;=5) direct = -1; else if(index&lt;=0) direct = 1; index = index+direct; arry.forEach((d,i)=&gt;{ d.style.opacity = 1; }); setTimeout(()=&gt;{ arry.forEach((d,i)=&gt;{ if(i==index) return; d.style.opacity = 0.1; }); },1000);},2000) 看了这个例子，我们清晰的看到这个引导蒙层的实现过程。这种引导蒙层其实更好玩有趣，有点类似当前流行的骨架屏，其他已有元素需要遮罩的内容就是骨架屏的灰色部分，需要显现的就是重点的蒙层内容。有趣！！！ 思路三：使用border的方式来实现没错，就是普遍不能在普遍的border了，且看如下： 123div { border:1px solid #red;} 那用border怎么实现引导蒙层呢？ 1、先了解下三角形先看一个简单的例子： 1&lt;div class=\"border_1\"&gt;&lt;/div&gt; 123456789.border_1{ width: 100px; height: 100px; border-top:50px solid red; border-right: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid transparent; box-sizing:border-box;} 实现了一个倒三角,这个应用场景是不是就比较多了，很多tips的指引，标注等都会用到。我就看到过这种倒三角使用一张图片代替的做法。仔细看这段代码，主要有实现了三点： 四边都设置了边框 宽高都为100px,即上下、左右表框之和，其实小于等于这个值都行。 只有顶部边框是红色，其他边框是透明的。 为了理解上面的实现，我们来看下如下代码： 123456789101112131415161718.border_2{ width: 100px; height: 100px; background-color:green; border-style:solid; border-color:red yellow blue black; border-width:50px; animation:border_ani 2s linear infinite alternate; box-sizing:border-box;}@keyframes border_ani { from { border-width:50px; } to { border-width:0; } } 从图中我们可以清晰的看到，随着border-width的变化，整个div的绿色背景在跟随变化。 当border-width=0的时候，整个页面只有绿色背景，即都是内容的大小 当border-width=50的时候，整个div的大小都被border给充满了，上下左右均分1/4，就是四个倒三角。 这样我们就清晰的能得到: 当border-right,border-left,border-bottom都transparent透明，border-top是红色的时候，所看到的就是一个倒三角。 同理我们还可以设置边框的大小不一致，可以实现斜三角： 123456789.border_3{ width: 0; height: 0; border-top:30px solid red; border-right: 10px solid transparent; border-bottom: 20px solid transparent; border-left: 100px solid transparent; box-sizing:border-box;} 还可以实现工作中经常碰到的梯形： 123456789.border_4{ width: 150px; height: 150px; border-top:50px solid red; border-right: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid transparent; box-sizing:border-box;} 好了，这里不累赘了，感兴趣的可以各种尝试。遇到这种简单边线图，就不要动不动使用图片了。 2、再看实现引导蒙层 新增一个div，作为蒙层元素 div中间大小和引导内容元素大小完全一致，且位置恰好重叠 div的border设置为半透明且无限放大 了解了上面的三角形的实现之后，估计你也能想出怎么做引导蒙层了。一个div有四个边框，如果我们把边框都设置成半透明，然后中间的区域（上面border_2的green）设置成全透明会不就可以实现区域引导蒙层了吗？然后再把边框设置成超过屏幕的大小呢，就是全景引导蒙层了！ 123456789.border_5{ width: 150px; height: 150px; border-top:50px solid rgba(0,0,0,.5); border-right: 50px solid rgba(0,0,0,.5); border-bottom: 50px solid rgba(0,0,0,.5); border-left: 50px solid rgba(0,0,0,.5); box-sizing:border-box;} 这是一个150px的区域蒙层，我们看下如下示例就能很明白了： 1234567891011121314151617.border_6{ width: 20px; height: 20px; border-style:solid; border-color:rgba(0,0,0,.5); border-width:20px; animation:border_ani 2s linear infinite alternate; box-sizing:content-box;}@keyframes border_ani { from { border-width:20px; } to { border-width:100px; } } 当然，我们还可以设置border-radius来实现圆形的蒙层区域，如下： 当然，这里的边框大小值都是写死的，具体实现需要根据页面内容修改或者动态修改即可。 如果是椭圆呢？ 总结： border可以实现各种边线的形状，可以实现引导蒙层，页面指定区域透明，之外的都半透明来实现即可。 思路四、使用box-shadow来实现 新增一个div，作为蒙层元素 div大小和内容元素大小完全一致，且位置恰好重叠 div的box-shadow的阴影尺寸设置为半透明且设置为比较大的约2000px大小 box-shadow，大伙都不陌生，就是盒子的阴影，我们先来了解下它的基本用法： 123456.boxshadow_1{ width:50px; height:50px; background:blue; box-shadow: 10px 10px 5px 4px #000;} 在宽高为50px的div,它的阴影水平和垂直都是10px，阴影模糊距离是5px,阴影的尺寸是4px,阴影是#000的颜色(这里给body增加了一个yellow的背景色以便于区分)。 首先我们把阴影透明： 123456.boxshadow_2{ width:50px; height:50px; background:blue; box-shadow: 10px 10px 5px 4px rgba(0,0,0,.5);} 那怎么让阴影遮盖整个页面呢？ 阴影的水平和垂直距离是指距离原dev的距离，这个调整达不到效果，只会让阴影更多的偏离元素。 阴影的模糊距离指阴影的边缘渐变模糊的距离，距离越长，只会让渐变模糊加长，蒙层大小不会变。 阴影的尺寸，这个是指多大的阴影，那我们将阴影尺寸设置很大呢？是的，就是这个了 看如下的例子，我们调整阴影的尺寸： 123456789101112131415.boxshadow_3 { width:50px; height:50px; background:blue; box-shadow: 0px 0px 5px 0px rgba(0,0,0,.5); animation:box_ani 2s linear infinite alternate;}@keyframes box_ani { from { box-shadow: 10px 10px 5px 0px rgba(0,0,0,.5); } to { box-shadow: 10px 10px 5px 100px rgba(0,0,0,.5); } } 如上，我们只需要把阴影尺寸加大就可以实现引导蒙层了。如果需要引导蒙层状态下还能响应事件呢？只需要加一个pointer-events属性即可。 box-shadow的阴影距离切勿盲目设置过大，经过测试这个值如果过大，比如4000px，在部分手机上阴影无法显示出来。经过实践，设置为2000px为佳。 思路五：使用页面节点复制 新增两个div，一个半透明蒙层元素和一个蒙层内容区域 将页面节点引导内容拷贝到蒙层内容区域 将蒙层内容区域的大小和位置与原节点引导内容完全重合 页面内容已经做好了，我们需要引导蒙层来显示某个元素，那么将元素复制到最外层，顶层增加一层蒙层来实现,需要突出的引导内容在蒙层之上即可实现。 123456&lt;div class=\"content one\"&gt;我是第一个div，我是第一个div&lt;/div&gt;&lt;div class=\"content two\"&gt;我是第二个div，我是第二个div&lt;/div&gt;&lt;div class=\"content three\"&gt;我是第三个div，我是第三个div&lt;/div&gt;&lt;div class=\"content four\"&gt;我是第四个div，我是第四个div&lt;/div&gt;&lt;div class=\"mask\"&gt;&lt;/div&gt;&lt;div id=\"maskContent\"&gt;&lt;/div&gt; 这里设置了一个固定蒙层，和一个固定的蒙层内容元素，我们只需要填充即可。 12345678910111213141516171819.content{ padding:10px; z-index:0;}.mask{ position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,.8); z-index:900 } #maskContent{ position:fixed; z-index:999; display:inline-block; background-color: #fff; } 这里内容区域都是0，然后mask是900，我们的蒙层元素是999，就是最上层了。 123456789101112131415function renderContent(cls){ let targetNode = document.querySelector(`.${cls}`); let maskContent = document.getElementById(\"maskContent\"); maskContent.innerHTML = targetNode.outerHTML; let pos = targetNode.getBoundingClientRect(); maskContent.style.top=pos.top+\"px\"; maskContent.style.left=pos.left+\"px\"; maskContent.style.width=pos.width+\"px\"; maskContent.style.height=pos.height+\"px\"; }let i = 0;setInterval(()=&gt;{ renderContent(['one','two','three','four'][i]); if(++i&gt;=4) i = 0;},1000) 这里为了演示效果，增加了一个定时器改变不同的遮罩层。易于理解，看下效果： 思路六：使用canvas实现 新增一个canvas，绘制两次图形 第一次：绘制一个全屏的半透明阴影 第二次：使用xor绘制一个和引导内容区域的大小位置完全重合的区域 第二次绘制的内容区域和第一次重叠，使用xor，所以会透明，该引导内容区域就会完全显示出来，这就是我们想要的效果了。 使用canvas的globalCompositeOperation属性来实现,内容参考http://www.tutorialspoint.com/html5/canvas_composition.htm 重点看xor：Shapes are made transparent where both overlap and drawn normal everywhere else.翻译： canvas绘制的形状在重叠处都会变成透明的，非重叠处的其他任何地方都正常绘制内容。 所以我们就可以在canvas里面绘制一个canvas蒙层，然后在蒙层中需要显示的内容用xor来绘制重叠，然后重叠内容就会被透明，那么这个透明区域的内容就是我们想要的引导蒙层突出内容区域。具体看实例： 12345 &lt;div class=\"content one\"&gt;我是第一个div，我是第一个div&lt;/div&gt;&lt;div class=\"content two\"&gt;我是第二个div，我是第二个div&lt;/div&gt;&lt;div class=\"content three\"&gt;我是第三个div，我是第三个div&lt;/div&gt;&lt;div class=\"conteent four\"&gt;我是第四个div，我是第四个div&lt;/div&gt;&lt;canvas id=\"mask\"&gt;&lt;/canvas&gt; 页面增加一个canvas节点。将canvas整体设置成半透明，然后再用xor来实现内容的绘制。 12345678910111213141516171819202122232425 function mask(cls){ let targetNode = document.querySelector(`.${cls}`); let pos = targetNode.getBoundingClientRect(); let canvas = document.getElementById(\"mask\"); let width = window.innerWidth; let height = window.innerHeight;; canvas.setAttribute(\"width\", width); canvas.setAttribute(\"height\",height); var ctx = canvas.getContext(\"2d\"); ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle ='rgba(255, 255, 255, 0.9)'; ctx.fillRect(0, 0, width, height); ctx.fill(); ctx.fillStyle ='white'; ctx.globalCompositeOperation=\"xor\"; ctx.fillRect(pos.left,pos.top,pos.width,pos.height); ctx.fill(); }let array = ['one','two','three','four'];let i = 0;setInterval(()=&gt;{ mask(array[i]); i++; if(i&gt;=4) i = 0;},1000) 看完以上实现，你最喜欢哪种实现方式呢？","link":"/2019/09/20/guid-mask/"},{"title":"Electron 实践笔记","text":"作者：周全 社交魔方平台是京东的 SNS 活动搭建平台，其内置了很多模板，每一个模板都有一个模板 JSON 用于生成表单，运营同学、商家配置了这个表单后就可以生成活动页面了。模板 JSON 是标准的结构化数据，包含名称、类型、控件类型、校验器、默认值等等字段。以往都是采用手写 JSON 的方式，这是非常低效的，而且容易出错。针对其结构化数据的特点可以用 GUI 的方式去编辑，我们基于 Electron 参考 Github Desktop 客户端 的架构编写了一个 编辑器，通过填写表单的方式生成 JSON。所以在这里记录下这个 Electron 编辑器开发过程中可以记录的点和从 Github Desktop 客户端代码中值得学习的点。 一、关于 Electron Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。 上面是来自 Electron 官方的介绍。基于 Electron 平台，我们可以使用熟悉的前端技术栈来开发桌面应用。Electron 运行 package.json 的 main 脚本的进程被称为主进程（以下简称main）。 在主进程中运行的脚本通过创建 web 页面来展示用户界面（以下简称 renderer）。 一个 Electron 应用总是有且只有一个主进程。main 用于创建应用，创建浏览器窗口，它就是一个彻底的 Node 进程，获取不到 DOM, BOM 这些接口。在 main 创建的浏览器窗口中运行的就是 renderer 进程，它既可以获取 DOM, BOM 这些接口，也可以使用 Node 的 API。两类进程之间可以通过 Electron 提供的 IPC 接口通信。 二、开发环境搭建我们了解到 Electron 分为两类进程，main 和 renderer。所以搭建开发环境时不能像普通的前端应用一样一个 webpack 配置搞定。并且我们想要实现 一键启动开发环境 一键打包 一键发布 那么就需要两个 webpack 配置文件。 一个用于开发环境 – webpack.dev.ts。 1234567891011121314151617181920212223242526272829// webpack.dev.tsconst mainConfig = merge({}, base.mainConfig, config, { watch: true})const rendererConfig = merge({}, base.rendererConfig, config, { module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'], }, { test: /\\.styl$/, use: ['style-loader', 'css-loader', 'stylus-loader'], } ] }, devServer: { contentBase: path.join(__dirname, base.outputDir), port: 8000, hot: true, inline: true, historyApiFallback: true, writeToDisk: true },})module.exports = [rendererConfig, mainConfig] 另一个用于生产环境 – webpack.prod.ts。 12345678910111213141516171819202122232425262728293031const config: webpack.Configuration = { mode: 'production', devtool: 'source-map',}const mainConfig = merge({}, base.mainConfig, config)const rendererConfig = merge({}, base.rendererConfig, config, { module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'], }, { test: /\\.styl$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'stylus-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: 'renderer.css' }), new BundleAnalyzerPlugin({ analyzerMode: 'static', openAnalyzer: false, reportFilename: 'renderer.report.html', }), ],})module.exports = [mainConfig, rendererConfig] 这里参考了 Desktop 使用 Typescript 编写 webpack 配置文件。配合 interface 可以实现 webpack 配置文件的编辑器自动补全。具体使用方法可参考 webpack 文档 https://webpack.js.org/configuration/configuration-languages/#typescript 每一个配置文件导出一个数组，分别是 main, renderer 的配置对象。 使用 webpack-dev-server 启动能实现 renderer 的热更新，main 则是使用 webpack 的 watch 模式。 123{ \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\"} 使用 nodemon 监听 main 编译后的产物，nodemon 监听到改动则重新运行 electron . 重启应用,这样间接实现了 main 的 livereload。 Nodemon is a utility that will monitor for any changes in your source and automatically restart your server. 1234{ \"app\": \"electron .\", \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\",} 这样就实现了一键启动开发环境，且能够监听代码变化，重新启动应用。 Tips: 开源社区有更好的 electron-webpack, HMR for both renderer and main processes 生产环境则使用 webpack 顺序编译 main 和 renderer。编译完成后使用 electron-builder 打包。这样就实现了一键打包。 由于工具链的缺失实现不了一键发布，就只能打包后手动发布了（后面详细说明）。 下面就是完整的 scripts。 123456789101112131415161718{ \"scripts\": { \"start\": \"run-p -c compile:dev typecheck:watch app:watch\", \"dist\": \"npm run compile:prod &amp;&amp; electron-builder build --win --mac\", \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\", \"compile:prod\": \"npm run clean &amp;&amp; webpack --config scripts/webpack.prod.ts\", \"app\": \"electron .\", \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\", \"clean\": \"rimraf dest dist\", \"typecheck\": \"tsc --noEmit\", \"typecheck:watch\": \"tsc --noEmit --watch\", \"lint\": \"eslint src --ext .ts,.js --fix\", \"release:patch\": \"standard-version --release-as patch &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\", \"release:minor\": \"standard-version --release-as minor &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\", \"release:major\": \"standard-version --release-as major &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\", \"repush\": \"git push --follow-tags origin master &amp;&amp; npm run dist\" },} 三、目录结构1. 项目目录结构123456789101112131415161718192021222324252627282930src├── lib│ ├── cube│ ├── databases│ ├── enviroment│ ├── files│ ├── local-storage│ ├── log│ ├── shell│ ├── stores│ ├── update│ ├── validator│ └── watcher├── main│ ├── app-window.ts│ ├── event-bus.ts│ ├── index.ts│ ├── keyboard│ └── menu├── models│ ├── popup.ts│ └── project.ts└── renderer ├── App.tsx ├── assets ├── components ├── index.html ├── index.tsx ├── pages └── types 在目录结构上模仿了 Desktop。main 目录存放 main 进程相关代码，包括应用入口，窗口创建，菜单，快捷键等等；而 renderer 目录则是整个 UI 渲染层的代码。lib 目录则是一些和 UI 无关也和 main 无强相关的业务逻辑代码。models 则存放一些领域模型。 2. CSS 规范在这个 React 中项目中没有使用 css-modules 这类方案。而是使用 BEM 这类能形成命名空间的规范来实现模块化，这样做的好处是能够比较好的对样式进行覆盖。 在文件的组织方式上采用一个独立的 React 组件搭配一个独立的样式文件，这样在重构的时候，我们想要修改一个组件的样式只需要找到对应的样式文件进行修改即可，提高重构的效率。 123456789101112stylesheets ├── common.styl ├── components │ ├── editor.styl │ ├── empty-guide.styl │ ├── find-in-page.styl │ ├── reindex.styl │ ├── sidebar.styl │ ├── source-viewer.styl │ └── upload.styl ├── index.styl └── reset.styl 三、IPC 通信 进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 Electron 的 main 进程和 renderer 进程的通信是通过 Electron 提供的 ipcMain 和 ipcRenderer 来实现的。 1. main 端在 main 中向某一个窗口 renderer 发送消息可以使用 window.webContents.send。在 main 端监听 renderer 消息可以使用 ipcMain.on。 1234567891011// 在主进程中.const { ipcMain } = require('electron')ipcMain.on('asynchronous-message', (event, arg) =&gt; { console.log(arg) // prints \"ping\" event.reply('asynchronous-reply', 'pong')})ipcMain.on('synchronous-message', (event, arg) =&gt; { console.log(arg) // prints \"ping\" event.returnValue = 'pong'}) 2. renderer 端回复同步消息可以使用 event.returnValue。同步消息的返回值可以直接读取。回复异步消息可以使用 event.reply。那么在 renderer 就要监听回复的 channel 得到返回值。 12345678//在渲染器进程 (网页) 中。const { ipcRenderer } = require('electron')console.log(ipcRenderer.sendSync('synchronous-message', 'ping')) // prints \"pong\"ipcRenderer.on('asynchronous-reply', (event, arg) =&gt; { console.log(arg) // prints \"pong\"})ipcRenderer.send('asynchronous-message', 'ping') 可以看到 renderer 可以使用 ipcRenderer.send 向主进程发送异步消息。用 ipcRenderer.sendSync 发送同步消息。 四、数据持久化及状态管理1. 复杂数据持久化数据持久化可选的方案有很多，比如 electron-store等基于 JSON 文件实现的存储方案。对于更复杂的应用场景还可以使用 lowdb，nedb ，sqlite等。 最初我使用的是 electron-store, 并且一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以在最初设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。而且还需要自己维护 ID 的生成。借鉴了 Desktop 的代码后，重构了数据持久化部分，也采用了 Dexie，它是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了indexedDB 的三个问题： 不明确的异常处理 查询很烂 代码复杂 1234567891011121314151617181920import Dexie from 'dexie';export interface IDatabaseProject { id?: number; name: string; filePath: string;}export class ProjectsDatabase extends Dexie { public projects: Dexie.Table&lt;IDatabaseProject, number&gt;; constructor() { super('ProjectsDatabase'); this.version(1).stores({ projects: '++id,&amp;name,&amp;filePath', }); this.projects = this.table('projects'); }} 继承 Dexie 来实现我们自己的数据库类，在构造函数中声明数据库的版本，表的 schema 等等。具体可以参考 Dexie 官方文档。 2. 简单数据持久化一些 UI 状态的标志位存储（比如某个弹窗是否显示过），我们一般会把这种标志位存储到 localStorage 中。在查看 Desktop 的源码过程中，发现他们对 number, boolean 类型的数据的 get, set 进行了简单的封装。使用起来非常方便，这里贴一下对于 boolean 型数据的处理。 12345678910111213141516171819202122232425export function getBoolean(key: string): boolean | undefinedexport function getBoolean(key: string, defaultValue: boolean): booleanexport function getBoolean( key: string, defaultValue?: boolean): boolean | undefined { const value = localStorage.getItem(key) if (value === null) { return defaultValue } if (value === '1' || value === 'true') { return true } if (value === '0' || value === 'false') { return false } return defaultValue}export function setBoolean(key: string, value: boolean) { localStorage.setItem(key, value ? '1' : '0')} 源码详见 五、功能实现1. 磁盘/编辑器版本实时同步一般情况下，在编辑器中我们编辑的内容其实是编辑器读取磁盘文件到内存中的副本。所以说如果磁盘的文件发生了改动，比如 Git 切换分支造成文件变动，抑或是删除了磁盘文件，重命名等等都会造成内存版本和磁盘版本的不一致，即磁盘版本领先于内存版本，这个时候就可能产生冲突。解决这个问题很简单，可以使用 fs.watch/watchFile 监听当前编辑的文件，一旦发生变化，就重新读取磁盘版本，更新内存版本来实现同步。但是 fs.watch 这个 API 在工程上不是可以开箱即用的，有许多兼容问题和一些 bug。比如说 Node.js fs.watch: Doesn’t report filenames on MacOS. Doesn’t report events at all when using editors like Sublime on MacOS. Often reports events twice. Emits most changes as rename. Does not provide an easy way to recursively watch file trees. Node.js fs.watchFile: Almost as bad at event handling. Also does not provide any recursive watching. Results in high CPU utilization. 上面列举的点来自 chokidar，它是一个 Node 模块，提供了开箱可用的监听文件变化的能力。只需要监听 add, unlink, change 等事件读取最新版本的文本到编辑器就可以实现磁盘/编辑器版本的同步了。 2. Context-MenuDesktop 的 contextmenu (右键菜单)的实现基于原生 IPC 的，比较绕。 首先我们需要知道的是 Menu 类是 main process only 的。 在需要 contextmenu 的 JSX.Element 上绑定 onContextMenu 事件。构造对象数组 Array&lt;MenuItem&gt;, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。 1onContextMenu =&gt; showContextualMenu (暂存MenuItems，ipcRenderer.send) =&gt; icpMain =&gt; menu.popup() =&gt; MenuItem.onClick(index) =&gt; event.sernder.send(index) =&gt; MenuItem.action() 所以在我的应用中使用了 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。 123456789101112131415161718192021222324252627import { remote } from 'electron';const { MenuItem, dialog, getCurrentWindow, Menu } = remote;const onContextMenu = (project: Project) =&gt; { const menu = new Menu(); const menus = [ new MenuItem({ label: '在终端中打开', visible: __DARWIN__, click() { const accessor = new FileAccessor(project.filePath); accessor.openInTerminal(); }, }), new MenuItem({ label: '在 vscode 中打开', click() { const accessor = new FileAccessor(project.filePath); accessor.openInVscode(); }, }), ]; menus.forEach(menu.append); menu.popup({ window: getCurrentWindow() });}; 六、日志完善的日志不论是开发环境还是生产环境都是非常重要的，大致记录 UI 状态迁移背后的数据变动，流程的分支走向，能很好的辅助开发。 参考 Desktop，他们的日志基于日志库：winston。 在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 debug, info, warn, error。在 renderer 进程，简单的封装了 window.console 对象上的 debug, info, warn, error 方法，日志打印到浏览器控制台的时候也通过 IPC 传递到 main 进程，由 main 进程统一管理。 main 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 transports。winston.transports.Console 和 winston.transports.DailyRotateFile 分别用于将日志信息打印在终端控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。 在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要在进程启动时引入一次即可。同时在 TS 环境中还需要添加 log 方法的类型声明。 七、打包，发布及更新开源世界已经有非常完善的打包和发布的工具 – electron-builder。它集多平台打包，签名，自动更新，发布到Github等平台等等功能于一身。 鉴于这个工具只能在内网使用，不能发布到 Github 而且也没有没有苹果开发者工具无法进行签名，只能利用 electron-builder 在本机打包，发布的话只能使用手动打包上传了，用户也只能手动下载安装包覆盖安装，不能像 VSCODE 这样实现自动更新。 既然不能自动更新，那么新版本下发后，如何通知到用户去下载新版本安装包更新呢？从用户这一端来看，在应用每次启动的时候可以做一次请求，查询是否有版本更新，或者是在应用菜单栏提供入口，让用户手动触发更新查询。查询到服务端的最新版本后，使用 sermver 比较本机版本是否低于服务器版本，如果是就下发通知给用户，提示用户去下载更新。 在有限的条件下怎么实现这个功能呢？ 实现这个功能必需的三个元素：服务端标识着最新版本的可读文件；托管各个版本安装包的云空间；应用代码中的更新逻辑。 服务端标识着最新版本的可读文件：每次打包时都会更新 package.json，所以我们直接把 package.json 上传到某个不带鉴权的 CDN 就可以，更新的时候就请求这个文件。 托管各个版本安装包的云空间：这个可以使用云盘，云盘可以生成分享链接，把这个链接手动拷贝到 Gitlab 该版本的 tag 的 Notes 中。 应用代码中的更新逻辑： 1234567891011121314151617181920212223import got from 'got';import semver from 'semver';import { app, remote, BrowserWindow } from 'electron';const realApp = app || remote.app;const currentVersion = realApp.getVersion();export async function checkForUpdates(window: BrowserWindow, silent: boolean = false) { const url = `http://yourcdn/package.json?t=${Date.now()}`; try { const response = await got(url); const pkg = JSON.parse(response.body); log.debug('检查更新，云端版本：', pkg.version); log.debug('当前版本', currentVersion); if (semver.lt(currentVersion, pkg.version)) { window.webContents.send('update-available', pkg.version); } else { window.webContents.send('update-not-available', silent); } } catch (error) { window.webContents.send('update-error', silent); }} 分别在应用主进程启动、用户点击应用菜单检查更新时调用这个方法，从而通知 UI 进程下发通知。我们期望应用主进程启动时的更新是在失败或者无更新时是静默的，不用打扰用户，所以在 IPC 管道可以提供一个 silent 参数。检测到更新后就可以通知用户，用户点击更新后就可以跳转到最新版本的 Gitlab tags ，引导用户下载最新版本进行手动安装。 八、其他1. devtools开发 Electron 应用中 renderer 端也是使用 Chrome devtools 来调试的。对于 React, Mobx 这类框的 devtools 扩展也可以通过 electron-devtools-installer 来安装。应用窗口创建之后调用electron-devtools-installer 进行 mobx、react 等扩展的安装。 123456789const { default: installExtension, MOBX_DEVTOOLS, REACT_DEVELOPER_TOOLS } = require('electron-devtools-installer');const extensions = [REACT_DEVELOPER_TOOLS, MOBX_DEVTOOLS];for (const extension of extensions) { try { installExtension(extension); } catch (e) { // log.error(e); }} 2. 保持窗口大小对于桌面应用，一个常见的需求就是关闭后重新打开，需要恢复到上次打开时的窗口大小，位置。实现这个比较简单，监听窗口的 resize 事件，把窗口信息记录到当前用户的应用数据文件夹, 即 app.getPath(appData)。下次启动应用创建窗口时读取这个文件设置窗口信息即可。开源社区已经有对这个功能封装好的库：electron-window-state 123456789101112131415161718const windowStateKeeper = require('electron-window-state');let win;app.on('ready', function () { let mainWindowState = windowStateKeeper({ defaultWidth: 1000, defaultHeight: 800 }); win = new BrowserWindow({ 'x': mainWindowState.x, 'y': mainWindowState.y, 'width': mainWindowState.width, 'height': mainWindowState.height }); mainWindowState.manage(win);}); 只需要提供缺省窗口大小，剩余的事情 electron-window-state 都帮我们搞定了。","link":"/2019/10/11/Electron-实践笔记/"},{"title":"TypeScript安利指南","text":"作者：李逸君 骚年，你感受过debug一年找不到问题，最后发现是变量名写错时的绝望吗？骚年，你感受过生产线上代码出现Uncaught TypeError时的恐惧吗？骚年，你感受过写代码找一万个文件还找不到方法定义时委屈吗？ 拿起键盘，让我们对谋害生命的代码拖进垃圾箱！(划掉) 前言据了解，目前有相当一部分同学不想去学习ts，毕竟没(xue)时(bu)间(dong)。很不幸两个月前我也是其中的一员。在看到尤大大都用ts写vue3了，蠢蠢欲动的我小心翼翼的踏入了这个深坑。在经历了长达一天的摸爬滚打之后，领悟到了真谛 经过了一段时间的理解之后，写了这篇文章，旨在给犹豫是否学习或者还在观望TypeScript的同学做个使用ts的收益分析，希望能够打动屏幕面前的你。 安利ts难写吗？不难。最简单的做法三步就搞定。 找一个js文件 按下重命名 把.js改成.ts 大功告成！ （打人别打脸，还要靠它吃饭的…） ⬇️ ts初体验 -ts是什么ts是js的超集，意味着js本身的语法在ts里面也能跑的通。ts一方面是对js加上了很多条条框框的限制，另一方面是拓展了js的一些能力，就像es6提供了那么多神奇的语法糖一样。只要按照一定的规则去书写js，就能享受到ts带来的好处。 当然因为现在的ts足够强大，并且有自家的vscode保驾护航，才方便了我们这些过去想都不(lan)敢(de)想的苦逼程序员。 js改造成ts的工作量很大程度取决于你想对自己的代码限制的有多细致，描述的有多完善。最简单的就像上面说的，改个拓展名就行了(当然很大程度上可能会通过不了各种静态检查)。如果你写的越多，用你代码的同志就越大可能喜欢你写的东西。 下面先简单介绍一下ts语法，便于后面的理解。 -ts语法简介1234567891011121314151617181920212223242526272829303132// 'xxx: number' 表示声明一个number类型const num: number = 123// 声明一个函数的参数类型(number以及any)和返回值(void)function fn (arg1: number, arg2: any): void { // todo}fn(num, [1,2,3,4])// 声明一个接口interface IPerson { name: string // IPerson需要包含一个name属性，类型是string age: number // IPerson需要包含一个age属性，类型是number family: Array&lt;string&gt; // IPerson需要包含一个family属性，类型是数组，数组里面都是string类型的数据 sex?: '男' | '女' // IPerson可选一个sex属性，值为'男'或者'女'或者undefined}// 使用IPerson接口定义一个对象，如果对象不符合IPerson的定义，编译器会飘红报错const person: IPerson = { name: '小王', age: 12, family: ['爹', '娘'],}// type类似interface，以下写法等同用interface声明IPersontype IPerson2 = { name: string age: number family: Array&lt;string&gt; sex?: '男' | '女'}// 因此可以直接定义过来const person2: IPerson2 = person 可能有的同学看了上面的介绍，会说： “要写这么多其他代码，还增加了文件体积，搞个啥子咧” 一般情况下，ts需要编译成js才能运行。编译后长这样： 123456789101112131415// 'xxx: number' 表示声明一个number类型var num = 123;// 声明一个函数的参数类型(number以及any)和返回值(void)function fn(arg1, arg2) { // todo}fn(num, [1, 2, 3, 4]);// 使用IPerson接口定义一个对象，如果对象不符合IPerson的定义，编译器会飘红报错var person = { name: '小王', age: 12, family: ['爹', '娘'],};// 因此可以直接定义过来var person2 = person; 通过人肉diff，发现编译后的去掉了ts的所有代码。 可能就又有同学想问了： “学这些有啥好处?” 别急，接着往下看🤓 应用场景这块介绍ts的几个应用场景，给点启发~ -用我的代码就要听我的平时为了代码的健壮性，不得不对代码做很多容错的操作。 假如成功避免了因为自己年龄大了而眼睛花了，使用自己写的方法时这里漏了一个参数，那里传错了参数类型。经常会有些不靠谱的使用者，不看你辛辛苦苦耕耘的api文档，瞎jb传参。最后出了问题还怪你没有做好兼容处理，领导群里一顿数落。 我们就得像孩子他妈一样，考虑熊孩子会传些什么乱七八糟的东西进来，然后在代码里面加上各种分支。 现在用ts，就可以在传参的时候友好的提示出来“你写了个什么玩意”的意思。 首先用ts定义一个函数 12345678interface IArgs { name: string age: string}function youFoo (arg1: string, arg2: 'a'|'b', arg3: IArgs) { // 这里啥都不干，你传参吧} 假如同事小明这么写 1234youFoo('sss', 'c', { name: 'xiaoming', age: 18}) 他就会发现哪里好像不太对 第二个参数要求’a’或者’b’，于是小明默默的改过来了，但是又发现 原来age是要求传string类型。 于是小明一边心里mmp一边改了过来。 -找文档平时在干活的时候，我们一般喜欢多一个屏幕，可以开个chrome，查查问题找找文档等。不过经常还得看网速，用搜索去搜api啥的，遇到在乡下写代码，分分钟有想shi的心。 有了ts，我们就完(da)美(gai)的决掉了这个问题: 首先按照这样的结构去写方法： 12345678910111213141516/** * 一个方法：生成错误提示信息 * * @param {string} message 提示信息，比如`you have a error` * @param {number | string} code 错误码，数字和字符都行 * @param {string} type 类型，请写`demo1`或者`demo2` * * [还不懂？点这里吧](https://www.google.com) * * // demo * genErrMsg('demo', 10086) * */export function genErrMsg (message: string, code: number | string, type?: ('demo1' | 'demo2')): string { return (message || `网络繁忙，请稍候再试`) + (code ? `(${code})` : ``)} 然后在使用过程中的体验如下： 在更完善的lib当中，体验更佳，除了开头的jquery外，还比如： -粗心大意阅读以下js代码，提问：分割线以下的代码有几处bug？ 12345678910111213141516171819202122// careless.jslet foooo = 1let fooo = 1let fooooooo = 1let foo = 1let foooooo = 1let test = 12const obj = { fn1 () {}, fn2 () {}, fn4 () {},}/*************** 分割线以下的代码有哪些地方有bug？ **************** */obj.fn3()console.leg(fooooo)function test () { alert(tast)} /* ** ** * 答案分界线 * ** ** */ 是不是觉得眼睛有点要瞎了？ 试试把.js改成.ts -隐藏的问题如果说之前的js代码还能凭眼神立刻看出哪里不对，那么下面这些就没那么简单了 阅读以下js代码，提问：代码有几处bug？ 123456import * as utils from './utils'utils.genErrMsg(10086, 'this is error') // 上面提到的genErrMsg函数let dom = window.document.getElementById('foo')dom.className = 'add' /* ** ** * 答案分界线 * ** ** */ 试试把.js改成.ts 可知问题如下： 1.genErrMsg的第一个参数应该是string 2.getElementById返回值还可能是null -接口数据不知道在维护代码的过程中，可能经常遇到某个接口不知道有啥数据，通常这个时候我们需要去查接口文档。然而当次数一多，或者后台大佬一坑起来，改了字段，可能会查到怀疑人生。 如果使用ts，可能手里的剧本就不一样了 假如有个接口如下所示 我们针对这个接口写出了如下ts代码： 123456789101112131415161718192021222324interface IPriceData { /** 标识 */ cbf: string /** id */ id: string /** 市场价格 */ m: string /** 后台价 */ op: string /** 前台价 */ p: string}// 将IPriceData塞进数组里type IPriceDataArray = Array&lt;IPriceData&gt;function getPrice () { // Promise的泛型参数使用了IPriceDataArray类型，then里面返回的数据就是IPriceDataArray类型 return new Promise&lt;IPriceDataArray&gt;((resolve, reject) =&gt; { $.get('https://xxxxxxx/prices/pgets?ids=P_100012&amp;area=&amp;source=', data =&gt; { resolve(data) }) })} 当调用getPrice函数时，体验如下： 以后每次维护这段函数的时候都不需要去看文档啦。如果后台突然改了字段，在检查的过程中我们可以马上发现问题，然后拿着数据去质问：你tm改了东西让我来背锅…(此处省略1万个字) -增强后的class和enum众所周知，js里面的class就是个语法糖，想学强类型语言，写法又是个半吊子。 但是在ts当中，class被增强了(当然还是个语法糖，只不过更甜了) 咱们看图说话： vscode中对ts下的共有属性、私有属性、保护属性和静态属性开了小灶，实例下只有公有属性才会被允许使用和提示出来。 另外ts还提供了enum语法糖： 12345678910111213141516171819enum HttpCode { /** 成功 */ '200_OK' = 200, /** 已生成了新的资源 */ '201_Created' = 201, /** 请求稍后会被处理 */ '202_Accepted' = 202, /** 资源已经不存在 */ '204_NoContent' = 204, /** 被请求的资源有一系列可供选择的回馈信息 */ '300_MultipleChoices' = 300, /** 永久性转移 */ '301_MovedPermanently' = 301, /** 暂时性转移 */ '302_MoveTemporarily' = 302,}HttpCode['200_OK']HttpCode[200] 相比简单对象定义的key-value，只能通过key去访问value，不能通过value访问key。但是在enum当中，正反都可以当做key来用。 编译后的代码有兴趣的同学可以了解下~ 1234567891011121314151617181920\"use strict\";var HttpCode;(function (HttpCode) { /** 成功 */ HttpCode[HttpCode[\"200_OK\"] = 200] = \"200_OK\"; /** 已生成了新的资源 */ HttpCode[HttpCode[\"201_Created\"] = 201] = \"201_Created\"; /** 请求稍后会被处理 */ HttpCode[HttpCode[\"202_Accepted\"] = 202] = \"202_Accepted\"; /** 资源已经不存在 */ HttpCode[HttpCode[\"204_NoContent\"] = 204] = \"204_NoContent\"; /** 被请求的资源有一系列可供选择的回馈信息 */ HttpCode[HttpCode[\"300_MultipleChoices\"] = 300] = \"300_MultipleChoices\"; /** 永久性转移 */ HttpCode[HttpCode[\"301_MovedPermanently\"] = 301] = \"301_MovedPermanently\"; /** 暂时性转移 */ HttpCode[HttpCode[\"302_MoveTemporarily\"] = 302] = \"302_MoveTemporarily\";})(HttpCode || (HttpCode = {}));HttpCode['200_OK'];HttpCode[200]; 优点以及不足通过上面的几个栗子，大概可以看出使用了ts后，可以获得以下技能点： 清晰的函数参数/接口属性，增加了代码可读性和可维护性 静态检查 生成API文档 配合现代编辑器，各种提示 活跃的社区 以及对应的技术成本 维护者(包的作者) 使用者 收益 清晰的函数参数/接口属性 静态检查 生成api文档 清晰的函数参数/接口属性 配合现代编辑器，各种提示 代价 标记类型 声明(interface/type) 和某些库结合的不是很完美(没错，说的就是vue 2.x) 这里提到的vue2.x由于ts先天能力的不足，导致vue的ts语法需要使用class风格(运行时会被转换回原本的vue构造函数的语法)，和我们平时熟悉的vue风格有些差异 这里是因为vue的this下的环境比较复杂，对于ide来说需要在运行时才能确定，因此在编写ts的时候需要手动去设置属性(比如props,data,methods等)到this下面，非常麻烦。早期ts并不支持手动编写this的作用域，后来专门为其设计了一个ThisType的方法。 在上面的代码里用了class的写法，本身所有需要的属性就在this下，规避了运行时才能确定this下需要的作用域的问题。 另一方面，由于ts提示能力比较局限，比如在函数场景中，如果数据来源是独立的对象，体验就会比较糟糕。 请阅读以下栗子(这一块稍微超纲了标题’安利’的范畴，不太理解的新同学可以入坑以后再消化~) 1234567891011121314151617181920212223interface IOptions { name: string age: number extra: { data: Object methods: Object }}// 参数options要求符合IOptions定义的规则function sthConstructor (options: IOptions) {}// options对象当中并没有任何ts的静态检查和提示const options = { name: 'peter', age: '13', // error: age应该为数字 extra: { data: [], methods: {} }}// options飘红报错，然而提示内容废话太多，关键信息藏得太深sthConstructor(options) 在上面的场景，我们希望在options当中能够获得完整的ts检查能力。达成这个目的有三种方法： 1.将options里面的东西挪进函数当中 2.将options用IObject定义 3.提供一个helper方法 这三种方式当中： 方法1是最简单的方式，但是在大型项目当中，这样的写法反而很少见到。 方法2是维护者常用的方式，但是对于使用者而言，成本较高。因为使用者需要去lib里翻到方法对应的type类型，将它import进来。 方法3是个人觉得相对比较好的方式，只要维护者提供一个类似helper的函数包装一下，就可以获得对应的提示。是不是很像vue ts的装饰器? 但上述三种解决方式我觉得都不优雅，这就是ts当前的不足之一。 ts在js中的玩法TypeScript是和vscode都是微软的亲儿子，他们兄弟俩相互协作肯定会有更多小花样，甚至你用的只是js文件，也可以享受到。 这里抛砖引玉列出两条： -配置文件自动提示只要有types文件，所有配置都可以自动提示： 12345678910/** * webpack配置自动提示 * * 先安装对应的types包： `npm i @types/webpack -D` * * @type {import(&apos;webpack&apos;).Configuration} */const config = { } -js语法检查在js中也可以获得自动提示和静态检查。只要在vscode的setting当中勾上Check JS即可。虽然你的js代码可能会被各种飘红🤪 ⬇️ 之前的例子在js中也可以提示出一些bug了 写在最后有的同学会问：我才学js，可以学ts吗？可以，并且建议，因为会对js基础知识加深理解。有用法问题在stackoverflow上搜搜就解决了。 那么这么有用的工具，去哪可以学到呢？或许你可以参考下我学习的轨迹： 传送门–TypeScript 入门教程 (墙裂推荐) 传送门–为 Vue3 学点 TypeScript , 体验 TypeScript 传送门–一篇朴实的文章带你30分钟捋完TypeScript,方法是正反对比 传送门–stack overflow (墙裂推荐) 传送门–google 今年ts突然遍地开花，似乎成为了潮流。各种ts改造、学习教程、心得出现在了各大学习、交友网站上。有的同学可能也发现了：这不就就是java这类语言玩剩了的东西了吗？ 那年轻的时候谁不都想自由嘛，然而随着年龄大了都被管的服服帖帖的","link":"/2019/10/08/TypeScript安利指南/"},{"title":"Vue.js 3.0编译器compiler-core源码解析","text":"作者：深山蚂蚁 Vue.js 3.0的源代码正在国庆假期就这么突然放出来了，假期还没结束，陆陆续续看到努力的码农就在各种分析了。 目前还是 pre Alpha，乐观估计还有 Alpha，Beta版本，最后才是正式版。 话不多说，看 Pre-Alpha。 瞧 compiler-core 热门的 reactivity 被大佬翻来覆去再研究了，我就和大伙一起来解读一下 ”冷门“ 的 compiler 吧！😄😄😄😄 如果你对 AST 还不太熟悉，或者对如何实现一个简单的 AST解析器 还不太熟悉，可以猛戳：手把手教你写一个 AST 解析器 vue3.0的模板解析和vue2.0差异比较大，但是无论怎样变化，基本原理是一致的，我们写的各种 html 代码，js使用的时候其实就是一个字符串，将非结构化的字符串数据，转换成结构化的 AST，我们都是使用强大的正则表达式和indexOf来判断。compiler-core 的一个核心作用就是将字符串转换成 抽象对象语法树AST。 Let’s do IT ! 目录结构 _tests_ 测试用例 src/ast ts语法的大佬的类型定义，比如type，enum，interface等 src/codegen 将生成的ast转换成render字符串 src/errors 定义 compiler 错误类型 src/index 入口文件，主要有一个 baseCompile ，用来编译模板文件的 src/parse 将模板字符串转换成 AST src/runtimeHelper 生成code的时候的定义常量对应关系 src/transform 处理 AST 中的 vue 特有语法，比如 v-if ,v-on 的解析 进入 compiler-core 目录下，结构一目了然。这里说下 _tests_ 目录，是vue的jest测试用例。阅读源码前先看看用例，对阅读源码有很大帮助哦。 如下，测试一个简单的text，执行parse方法之后，得到 ast，期望 ast 的第一个节点与定义的对象是一致的。同理其他的模块测试用例，在阅读源码前可以先瞄一眼，知道这个模块如何使用，输入输出是啥。 1234567891011121314test('simple text', () =&gt; { const ast = parse('some text') const text = ast.children[0] as TextNode expect(text).toStrictEqual({ type: NodeTypes.TEXT, content: 'some text', isEmpty: false, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 9, line: 1, column: 10 }, source: 'some text' } })}) 先看一张图，重点是四块： 起始标签 结束标签 动态内容 普通内容 其中起始标签会用到递归来处理子节点。 接下来，我们开始跟着源码来阅读吧! parse：将字符串模板转换成 AST 抽象语法树这个是对外暴露的核心方法，我们先测试下结果： 12345678const source = ` &lt;div id=\"test\" :class=\"cls\"&gt; &lt;span&gt;{{ name }}&lt;/span&gt; &lt;MyCom&gt;&lt;/MyCom&gt; &lt;/div&gt;`.trim()import { parse } from './compiler-core.cjs'const result = parse(source) output: 一个简单的转换结果就呈现出来了，从生成的结构来看，相对于vue2.x有几个比较重要的变化： 新增了 loc 属性 每一个节点都记录了该节点在源码当中的 start 和 end，标识了代码的详细位置，column,line,offset。 vu3.0对于开发遇到的问题都要详细的日志输出也基于此，另外支持 source-map 新增了 tagType 属性 tagType 属性标识该节点是什么类型的。我们知道 vue2.x 判断节点类型是运行时才有的，vu3.0将判断提前到编译阶段了，提升了性能。 目前tagType有三种类型：0 element,1 component,2 slot,3 template 新增 isStatic 属性 将模板提前编译好，标识是否为动态变化的，比如动态指令 …… 新版的 AST 明显比 vue2.x 要复杂些，可以看到vue3.0将很多可以在编译阶段就能确定的就在编译阶段确定，标识编译结果，不需要等到运行时再去判断，节省内存和性能。这个也是尤大大重点说了的，优化编译，提升性能。 接下来我们来看下转换的代码，主要有如下几个方法： parse &amp; parseChildren 主入口 parseTag 处理标签 parseAttribute 处理标签上的属性 parseElement 处理起始标签 parseInterpolation 处理动态文本内容 parseText 处理静态文本内容 parse &amp; parseChildren 主入口parse 的主入口，这里创建了一个 parseContext，有利于后续直接从 context 上拿到 content，options 等。getCursor 获取当前处理的指针位置，用户生成 loc,初始都是1。 1234567891011121314export function parse(content: string, options: ParserOptions = {}): RootNode { const context = createParserContext(content, options) const start = getCursor(context) return { type: NodeTypes.ROOT, children: parseChildren(context, TextModes.DATA, []), helpers: [], components: [], directives: [], hoists: [], codegenNode: undefined, loc: getSelection(context, start) }} 重点看下 parseChildren ，这是转换的主入口方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function parseChildren( context: ParserContext, mode: TextModes, ancestors: ElementNode[]): TemplateChildNode[] { const parent = last(ancestors) const ns = parent ? parent.ns : Namespaces.HTML const nodes: TemplateChildNode[] = [] while (!isEnd(context, mode, ancestors)) { const s = context.source let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined if (startsWith(s, context.options.delimiters[0])) { // '{{' node = parseInterpolation(context, mode) } else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') { // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state if (s.length === 1) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1) } else if (s[1] === '!') { // &lt;!DOCTYPE &lt;![CDATA[ 等非节点元素 暂不讨论 } else if (s[1] === '/') { if (s.length === 2) { } else if (s[2] === '&gt;') { advanceBy(context, 3) continue } else if (/[a-z]/i.test(s[2])) { parseTag(context, TagType.End, parent) continue } else { } } else if (/[a-z]/i.test(s[1])) { node = parseElement(context, ancestors) } else if (s[1] === '?') { } else { } } if (!node) { node = parseText(context, mode) } if (Array.isArray(node)) { for (let i = 0; i &lt; node.length; i++) { pushNode(context, nodes, node[i]) } } else { pushNode(context, nodes, node) } } return nodes} ancestors 用来存储未匹配的起始节点，为后进先出的stack。 循环处理 source，循环截止条件是 isEnd 方法返回true，即是处理完成了，结束有两个条件: context.source 为空，即整个模板都处理完成。 碰到截止节点标签(&lt;/)，且能在未匹配的起始标签（ancestors）里面找到对对应的tag。这个对应 parseChildren 的子节点处理完成。 匹配尚未结束，则进入循环匹配。有三种情况： if(startsWith(s,context.options.delimiters[0]))语句， delimiters是分割符合，对于Vue来说就是‘’。开始匹配到Vue的文本输出内容，则意味着需要处理文本内容插入。 else if (mode === TextModes.DATA &amp;&amp; s[0] === ‘&lt;’) 内容是以&lt;开头，即html标签的标识符号，则开始处理起始标签和截止标签两种情况。 以上条件都不是，或者匹配未成功,那么就是动态文本内容了。 如果是第三种动态文本插入，则执行 parseInterpolation 组装文本节点，其中 isStatic=false 标识是变量，比较简单，方法就不贴了。 12345678910return { type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, isStatic: false, content, loc: getSelection(context, innerStart, innerEnd) }, loc: getSelection(context, start) } 再看下这两个处理 source 内容后移的方法： advanceBy(context,number) : 将需要处理的模板source ，后移 number 个字符，重新记录 locadvanceSpaces() : 后移存在的连续的空格 回到上面的匹配条件，如果是 &lt; 开头，分两种情况： 第二个字符是 “/“ 对应的就是 &lt;/ 如果是 &lt;/&gt; ，那么认为是一个无效标签，直接 advanceBy 后移 3 个字符即可。 如果是 &lt;\\/a，那么认为是一个截止标签，执行 parseTag 方法处理。 第二个字符是字母 对应就是标签的起始文字了，如 &lt;\\div，执行 parseElement 方法处理起始标签。 parseTag 处理标签如果是截止标签：parseTag，则直接处理完成。如果是起始标签：parseElement 执行，调用parseTag 处理标签，然后再去递归处理子节点等。 正则：/^&lt;/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i 这个就不多说了，匹配 &lt;\\div&gt; &lt;/div&gt;这种标签。测试 match ： 12/^&lt;\\/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(\"&lt;div class='abc'&gt;\")(2) [\"&lt;div\", \"div\", index: 0, input: \"&lt;div class='abc'&gt;\", groups: undefined] 显然，mathch[1] 即匹配到的标签元素。我们看主方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined): ElementNode { // Tag open. const start = getCursor(context) const match = /^&lt;\\/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(context.source)! const tag = match[1] const props = [] const ns = context.options.getNamespace(tag, parent) let tagType = ElementTypes.ELEMENT if (tag === 'slot') tagType = ElementTypes.SLOT else if (tag === 'template') tagType = ElementTypes.TEMPLATE else if (/[A-Z-]/.test(tag)) tagType = ElementTypes.COMPONENT advanceBy(context, match[0].length) advanceSpaces(context) // Attributes. const attributeNames = new Set&lt;string&gt;() while ( context.source.length &gt; 0 &amp;&amp; !startsWith(context.source, '&gt;') &amp;&amp; !startsWith(context.source, '/&gt;') ) { const attr = parseAttribute(context, attributeNames) if (type === TagType.Start) { props.push(attr) } advanceSpaces(context) } // Tag close. let isSelfClosing = false if (context.source.length === 0) { } else { isSelfClosing = startsWith(context.source, '/&gt;') advanceBy(context, isSelfClosing ? 2 : 1) } return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined // to be created during transform phase }} tagType有四种类型，在这里定义了，分别是: 0 element,1 component,2 slot,3 template 我们看while 循环，advanceBy 去掉起始 &lt; 和标签名之后:如果跟着是 &gt; 或者 /&gt; ，那么标签处理结束，退出循环。否则是标签的元素，我们执行 parseAttribute 来处理标签属性，该节点上增加props，保存 该起始节点的 attributes; 执行方法后面的！，是ts语法，相当于告诉ts，这里一定会有值，无需做空判断，如 const match = /^&lt;/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(context.source)! parseAttribute 处理标签上的属性正则获取属性上的name 12/^[^\\t\\r\\n\\f /&gt;][^\\t\\r\\n\\f /&gt;=]*/.exec('class='abc'&gt;')[\"class\", index: 0, input: \"class='abc'&gt;\", groups: undefined] 如果不是一个孤立的属性，有value值的话（/^[\\t\\r\\n\\f ]*=/.test(context.source)），那么再获取属性的value。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990function parseAttribute( context: ParserContext, nameSet: Set&lt;string&gt;): AttributeNode | DirectiveNode { // Name. const start = getCursor(context) const match = /^[^\\t\\r\\n\\f /&gt;][^\\t\\r\\n\\f /&gt;=]*/.exec(context.source)! const name = match[0] nameSet.add(name) advanceBy(context, name.length) // Value let value: | { content: string isQuoted: boolean loc: SourceLocation } | undefined = undefined if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) { advanceSpaces(context) advanceBy(context, 1) advanceSpaces(context) value = parseAttributeValue(context) } const loc = getSelection(context, start) if (/^(v-|:|@|#)/.test(name)) { const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec( name )! let arg: ExpressionNode | undefined if (match[2]) { const startOffset = name.split(match[2], 2)!.shift()!.length const loc = getSelection( context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length) ) let content = match[2] let isStatic = true if (content.startsWith('[')) { isStatic = false content = content.substr(1, content.length - 2) } arg = { type: NodeTypes.SIMPLE_EXPRESSION, content, isStatic, loc } } if (value &amp;&amp; value.isQuoted) { const valueLoc = value.loc valueLoc.start.offset++ valueLoc.start.column++ valueLoc.end = advancePositionWithClone(valueLoc.start, value.content) valueLoc.source = valueLoc.source.slice(1, -1) } return { type: NodeTypes.DIRECTIVE, name: match[1] || (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot'), exp: value &amp;&amp; { type: NodeTypes.SIMPLE_EXPRESSION, content: value.content, isStatic: false, loc: value.loc }, arg, modifiers: match[3] ? match[3].substr(1).split('.') : [], loc } } return { type: NodeTypes.ATTRIBUTE, name, value: value &amp;&amp; { type: NodeTypes.TEXT, content: value.content, isEmpty: value.content.trim().length === 0, loc: value.loc }, loc }} parseAttributeValue 获取属性值的方法比较容易： 如果value值有引号开始，那么就找到下一个引号未value值结束 （class=”aaa” class=’aaa’） 如果value没有引号，那么就找到下一个空格为value值结束 （class=aaa） 其中有处理vue的语法特性，如果属性名称是v-,:,@,#开头的，需要特殊处理，看下这个正则： 12345/(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(\"v-name\")(4) [\"v-name\", \"name\", undefined, undefined, index: 0, input: \"v-name\", groups: undefined]/(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(\":name\")(4) [\":name\", undefined, \"name\", undefined, index: 0, input: \":name\", groups: undefined] mathch[2]如果有值，即匹配到了，说明是非 v-name，如果是名称是[]包裹的则是 动态指令，将 isStatic 置为 false parseElement 处理起始标签parseElement 处理起始标签，我们先执行 parseTag 解析标签，获取到起始节点的 标签元素和属性，如果当前也是截止标签(比如),则直接返回该标签。否则，将起始标签 push 到未匹配的起始 ancestors栈里面。然后继续去处理子元素 parseChildren ,注意，将未匹配的 ancestors 传进去了，parseChildren 的截止条件有两个： context.source为空，即处理完成 碰到截止节点标签(&lt;/)，且能在未匹配的起始标签（ancestors）里面找到对对应的tag。 因此，如果是循环碰到匹配的截止标签了，则需要 ancestors.pop()，将节点添加到当前的子节点。 当然，处理当前起始节点，该节点也可能是截止节点，比如：&lt;\\img src=”xxx”/&gt;，则继续去执行处理截止节点即可。方法如下： 12345678910111213141516171819202122232425262728function parseElement( context: ParserContext, ancestors: ElementNode[]): ElementNode | undefined { // Start tag. const parent = last(ancestors) const element = parseTag(context, TagType.Start, parent) if (element.isSelfClosing || context.options.isVoidTag(element.tag)) { return element } // Children. ancestors.push(element) const mode = (context.options.getTextMode( element.tag, element.ns ) as unknown) as TextModes const children = parseChildren(context, mode, ancestors) ancestors.pop() element.children = children // End tag. if (startsWithEndTagOpen(context.source, element.tag)) { parseTag(context, TagType.End, parent) } else { } element.loc = getSelection(context, element.loc.start) return element} 至此，vue3.0的 将 模板文件转换成 AST 的主流程已经基本完成。静待下篇，AST 的 transform 处理。","link":"/2019/10/09/Vue-js-3-0编译器compiler-core源码解析/"},{"title":"换种方式读源码：如何实现一个简易版的Mocha","text":"作者：黄浩群 前言Mocha 是目前最流行的 JavaScript 测试框架，理解 Mocha 的内部实现原理有助于我们更深入地了解和学习自动化测试。然而阅读源码一直是个让人望而生畏的过程，大量的高级写法经常是晦涩难懂，大量的边缘情况的处理也十分影响对核心代码的理解，以至于写一篇源码解析过后往往是连自己都看不懂。所以，这次我们不生啃 Mocha 源码，换个方式，从零开始一步步实现一个简易版的 Mocha。 我们将实现什么？ 实现 Mocha 框架的 BDD 风格测试，能通过 describe/it 函数定义一组或单个的测试用例； 实现 Mocha 框架的 Hook 机制，包括 before、after、beforeEach、afterEach； 实现简单格式的测试报告输出。 Mocha 的 BDD 测试 Mocha 支持 BDD/TDD 等多种测试风格，默认使用 BDD 接口。BDD（行为驱动开发）是一种以需求为导向的敏捷开发方法，相比主张”测试先行“的 TDD（测试驱动开发）而言，它强调”需求先行“，从一个更加宏观的角度去关注包括开发、QA、需求方在内的多方利益相关者的协作关系，力求让开发者“做正确的事“。在 Mocha 中，一个简单的 BDD 式测试用例如下： 12345678910111213141516describe('Array', function() { describe('#indexOf()', function() { before(function() { // ... }); it('should return -1 when not present', function() { // ... }); it('should return the index when present', function() { // ... }); after(function() { // ... }); });}); Mocha 的 BDD 测试主要包括以下几个 API： describe/context：行为描述，代表一个测试块，是一组测试单元的集合； it/specify：描述了一个测试单元，是最小的测试单位； before：Hook 函数，在执行该测试块之前执行； after：Hook 函数，在执行该测试块之后执行； beforeEach：Hook 函数，在执行该测试块中每个测试单元之前执行； afterEach：Hook 函数，在执行该测试块中每个测试单元之后执行。 开始话不多说，我们直接开始。 一、目录设计新建一个项目，命名为 simple-mocha。目录结构如下： 1234567├─ mocha/│ ├─ index.js│ ├─ src/│ ├─ interfaces/│ └─ reporters/├─ test/└─ package.json 先对这个目录结构作简单解释： mocha/：存放我们即将实现的 simple-mocha 的源代码 mocha/index.js：simple-mocha 入口 mocha/src/：simple-mocha 核心代码 mocha/interfaces/：存放各类风格的测试接口，如 BDD mocha/reporters/：存放用于输出测试报告的各种 reporter，如 SPEC test/：存放我们编写的测试用例 package.json 其中 package.json 内容如下： 1234567891011{ \"name\": \"simple-mocha\", \"version\": \"1.0.0\", \"description\": \"a simple mocha for understanding the mechanism of mocha\", \"main\": \"\", \"scripts\": { \"test\": \"node mocha/index.js\" }, \"author\": \"hankle\", \"license\": \"ISC\"} 执行 npm test 就可以启动执行测试用例。 二、模块设计Mocha 的 BDD 测试应该是一个”先定义后执行“的过程，这样才能保证其 Hook 机制正确执行，而与代码编写顺序无关，因此我们把整个测试流程分为两个阶段：收集测试用例（定义）和执行测试用例（执行）。我们构造了一个 Mocha 类来完成这两个过程，同时这个类也负责统筹协调其他各模块的执行，因此它是整个测试流程的核心。 1234567// mocha/src/mocha.jsclass Mocha { constructor() {} run() {}}module.exports = Mocha; 12345// mocha/index.jsconst Mocha = require('./src/mocha');const mocha = new Mocha();mocha.run(); 另一方面我们知道，describe 函数描述了一个测试集合，这个测试集合除包括若干测试单元外，还拥有着一些自身的 Hook 函数，维护了一套严格的执行流。it 函数描述了一个测试单元，它需要执行测试用例，并且接收断言结果。这是两个逻辑复杂的单元，同时需要维护一定的内部状态，我们用两个类（Suite/Test）来分别构造它们。此外我们可以看出，BDD 风格的测试用例是一个典型的树形结构，describe 定义的测试块可以包含测试块，也可以包含 it 定义的测试单元。所以 Suite/Test 实例还将作为节点，构造出一棵 suite-test 树。比如下边这个测试用例： 12345678910111213141516describe('Array', function () { describe('#indexOf()', function () { it('should return -1 when not present', function () { // ... }) it('should return the index when present', function () { // ... }) }) describe('#every()', function () { it('should return true when all items are satisfied', function () { // ... }) })}) 由它构造出来的 suite-test 树是这样的： 1234567891011 ┌────────────────────────────────────────────────────────┐ ┌─┤ test:\"should return -1 when not present\" │ ┌────────────────────┐ │ └────────────────────────────────────────────────────────┘ ┌─┤ suite:\"#indexOf()\" ├─┤ │ └────────────────────┘ │ ┌────────────────────────────────────────────────────────┐┌───────────────┐ │ └─┤ test:\"should return the index when present\" ││ suite:\"Array\" ├─┤ └────────────────────────────────────────────────────────┘└───────────────┘ │ │ ┌────────────────────┐ ┌────────────────────────────────────────────────────────┐ └─┤ suite:\"#every()\" ├───┤ test:\"should return true when all items are satisfied\" │ └────────────────────┘ └────────────────────────────────────────────────────────┘ 因此，Suite/Test 除了要能够表示 describe/it 之外，还应该能够诠释这种树状结构的父子级关系： 12345678910111213141516171819// mocha/src/suite.jsclass Suite { constructor(props) { this.title = props.title; // Suite名称，即describe传入的第一个参数 this.suites = []; // 子级suite this.tests = []; // 包含的test this.parent = props.parent; // 父suite this._beforeAll = []; // before hook this._afterAll = []; // after hook this._beforeEach = []; // beforeEach hook this._afterEach = []; // afterEach hook if (props.parent instanceof Suite) { props.parent.suites.push(this); } }}module.exports = Suite; 123456789// mocha/src/test.jsclass Test { constructor(props) { this.title = props.title; // Test名称，即it传入的第一个参数 this.fn = props.fn; // Test的执行函数，即it传入的第二个参数 }}module.exports = Test; 我们完善一下目录结构： 12345678910111213141516├─ mocha/│ ├─ index.js│ ├─ src/│ │ ├─ mocha.js│ │ ├─ runner.js│ │ ├─ suite.js│ │ ├─ test.js│ │ └─ utils.js│ ├─ interfaces/│ │ ├─ bdd.js│ │ └─ index.js│ └─ reporters/│ ├─ spec.js│ └─ index.js├─ test/└─ package.json 考虑到执行测试用例的过程较为复杂，我们把这块逻辑单独抽离到 runner.js，它将在执行阶段负责调度 suite 和 test 节点并运行测试用例，后续会详细说到。 三、收集测试用例收集测试用例环节首先需要创建一个 suite 根节点，并把 API 挂载到全局，然后再执行测试用例文件 *.spec.js 进行用例收集，最终将生成一棵与之结构对应的 suite-test 树。 1、suite 根节点我们先创建一个 suite 实例，作为整棵 suite-test 树的根节点，同时它也是我们收集和执行测试用例的起点。 12345678910111213// mocha/src/mocha.jsconst Suite = require('./suite');class Mocha { constructor() { // 创建一个suite根节点 this.rootSuite = new Suite({ title: '', parent: null }); } // ...} 2、BDD API 的全局挂载在我们使用 Mocha 编写测试用例时，我们不需要手动引入 Mocha 提供的任何模块，就能够直接使用 describe、it 等一系列 API。那怎么样才能实现这一点呢？很简单，把 API 挂载到 global 对象上就行。因此，我们需要在执行测试用例文件之前，先将 BDD 风格的 API 全部作全局挂载。 1234567891011121314// mocha/src/mocha.js// ...const interfaces = require('../interfaces');class Mocha { constructor() { // 创建一个根suite // ... // 使用bdd测试风格，将API挂载到global对象上 const ui = 'bdd'; interfaces[ui](global, this.rootSuite); } // ...} 12// mocha/interfaces/index.jsmodule.exports.bdd = require('./bdd'); 123456789// mocha/interfaces/bdd.jsmodule.exports = function (context, root) { context.describe = context.context = function (title, fn) {} context.it = context.specify = function (title, fn) {} context.before = function (fn) {} context.after = function (fn) {} context.beforeEach = function (fn) {} context.afterEach = function (fn) {}} 3、BDD API 的具体实现我们先看看 describe 函数怎么实现。 describe 传入的 fn 参数是一个函数，它描述了一个测试块，测试块包含了若干子测试块和测试单元。因此我们需要执行 describe 传入的 fn 函数，才能够获知到它的子层结构，从而构造出一棵完整的 suite-test 树。而逐层执行 describe 的 fn 函数，本质上就是一个深度优先遍历的过程，因此我们需要利用一个栈（stack）来记录 suite 根节点到当前节点的路径。 1234567891011121314151617181920// mocha/interfaces/bdd.jsconst Suite = require('../src/suite');const Test = require('../src/test');module.exports = function (context, root) { // 记录 suite 根节点到当前节点的路径 const suites = [root]; context.describe = context.context = function (title, fn) { const parent = suites[0]; const suite = new Suite({ title, parent }); suites.unshift(suite); fn.call(suite); suites.shift(suite); }} 每次处理一个 describe 时，我们都会构建一个 Suite 实例来表示它，并且在执行 fn 前入栈，执行 fn 后出栈，保证 suites[0] 始终是当前正在处理的 suite 节点。利用这个栈列表，我们可以在遍历过程中构建出 suite 的树级关系。 同样的，其他 API 也都需要依赖这个栈列表来实现： 123456789101112131415161718192021222324252627282930313233343536// mocha/interfaces/bdd.jsmodule.exports = function (context, root) { // 记录 suite 根节点到当前节点的路径 const suites = [root]; // context.describe = ... context.it = context.specify = function (title, fn) { const parent = suites[0]; const test = new Test({ title, fn }); parent.tests.push(test); } context.before = function (fn) { const cur = suites[0]; cur._beforeAll.push(fn); } context.after = function (fn) { const cur = suites[0]; cur._afterAll.push(fn); } context.beforeEach = function (fn) { const cur = suites[0]; cur._beforeEach.push(fn); } context.afterEach = function (fn) { const cur = suites[0]; cur._afterEach.push(fn); }} 4、执行测试用例文件一切准备就绪，我们开始 require 测试用例文件。要完成这个步骤，我们需要一个函数来协助完成，它负责解析 test 路径下的资源，返回一个文件列表，并且能够支持 test 路径为文件和为目录的两种情况。 1234567891011121314151617181920212223242526272829303132333435// mocha/src/utils.jsconst path = require('path');const fs = require('fs');module.exports.lookupFiles = function lookupFiles(filepath) { let stat; // 假设路径是文件 try { stat = fs.statSync(`${filepath}.js`); if (stat.isFile()) { // 确实是文件，直接以数组形式返回 return [filepath]; } } catch(e) {} // 假设路径是目录 let files = []; // 存放目录下的所有文件 fs.readdirSync(filepath).forEach(function(dirent) { let pathname = path.join(filepath, dirent); try { stat = fs.statSync(pathname); if (stat.isDirectory()) { // 是目录，进一步递归 files = files.concat(lookupFiles(pathname)); } else if (stat.isFile()) { // 是文件，补充到待返回的文件列表中 files.push(pathname); } } catch(e) {} }); return files;} 1234567891011121314151617181920// mocha/src/mocha.js// ...const path = require('path');const utils = require('./utils');class Mocha { constructor() { // 创建一个根suite // ... // 使用bdd测试风格，将API挂载到global对象上 // ... // 执行测试用例文件，构建suite-test树 const spec = path.resolve(__dirname, '../../test'); const files = utils.lookupFiles(spec); files.forEach(file =&gt; { require(file); }); } // ...} 四、执行测试用例在这个环节中，我们需要通过遍历 suite-test 树来递归执行 suite 节点和 test 节点，并同步地输出测试报告。 1、异步执行Mocha 的测试用例和 Hook 函数是支持异步执行的。异步执行的写法有两种，一种是函数返回值为一个 promise 对象，另一种是函数接收一个入参 done，并由开发者在异步代码中手动调用 done(error) 来向 Mocha 传递断言结果。所以，在执行测试用例之前，我们需要一个包装函数，将开发者传入的函数 promise 化： 123456789101112131415161718192021222324// mocha/src/utils.js// ...module.exports.adaptPromise = function(fn) { return () =&gt; new Promise(resolve =&gt; { if (fn.length == 0) { // 不使用参数 done try { const ret = fn(); // 判断是否返回promise if (ret instanceof Promise) { return ret.then(resolve, resolve); } else { resolve(); } } catch (error) { resolve(error); } } else { // 使用参数 done function done(error) { resolve(error); } fn(done); } })} 这个工具函数传入一个函数 fn 并返回另外一个函数，执行返回的函数能够以 promise 的形式去运行 fn。这样一来，我们需要稍微修改一下之前的代码： 1234567891011121314151617181920212223242526272829303132333435// mocha/interfaces/bdd.js// ...const { adaptPromise } = require('../src/utils');module.exports = function (context, root) { // ... context.it = context.specify = function (title, fn) { // ... const test = new Test({ title, fn: adaptPromise(fn) }); // ... } context.before = function (fn) { // ... cur._beforeAll.push(adaptPromise(fn)); } context.after = function (fn) { // ... cur._afterAll.push(adaptPromise(fn)); } context.beforeEach = function (fn) { // ... cur._beforeEach.push(adaptPromise(fn)); } context.afterEach = function (fn) { // ... cur._afterEach.push(adaptPromise(fn)); }} 2、测试用例执行器执行测试用例需要调度 suite 和 test 节点，因此我们需要一个执行器（runner）来统一负责执行过程。这是执行阶段的核心，我们先直接贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// mocha/src/runner.jsconst EventEmitter = require('events').EventEmitter;// 监听事件的标识const constants = { EVENT_RUN_BEGIN: 'EVENT_RUN_BEGIN', // 执行流程开始 EVENT_RUN_END: 'EVENT_RUN_END', // 执行流程结束 EVENT_SUITE_BEGIN: 'EVENT_SUITE_BEGIN', // 执行suite开始 EVENT_SUITE_END: 'EVENT_SUITE_END', // 执行suite开始 EVENT_FAIL: 'EVENT_FAIL', // 执行用例失败 EVENT_PASS: 'EVENT_PASS' // 执行用例成功}class Runner extends EventEmitter { constructor() { super(); // 记录 suite 根节点到当前节点的路径 this.suites = []; } /* * 主入口 */ async run(root) { this.emit(constants.EVENT_RUN_BEGIN); await this.runSuite(root); this.emit(constants.EVENT_RUN_END); } /* * 执行suite */ async runSuite(suite) { // suite执行开始 this.emit(constants.EVENT_SUITE_BEGIN, suite); // 1）执行before钩子函数 if (suite._beforeAll.length) { for (const fn of suite._beforeAll) { const result = await fn(); if (result instanceof Error) { this.emit(constants.EVENT_FAIL, `\"before all\" hook in ${suite.title}: ${result.message}`); // suite执行结束 this.emit(constants.EVENT_SUITE_END); return; } } } // 路径栈推入当前节点 this.suites.unshift(suite); // 2）执行test if (suite.tests.length) { for (const test of suite.tests) { await this.runTest(test); } } // 3）执行子级suite if (suite.suites.length) { for (const child of suite.suites) { await this.runSuite(child); } } // 路径栈推出当前节点 this.suites.shift(suite); // 4）执行after钩子函数 if (suite._afterAll.length) { for (const fn of suite._afterAll) { const result = await fn(); if (result instanceof Error) { this.emit(constants.EVENT_FAIL, `\"after all\" hook in ${suite.title}: ${result.message}`); // suite执行结束 this.emit(constants.EVENT_SUITE_END); return; } } } // suite结束 this.emit(constants.EVENT_SUITE_END); } /* * 执行suite */ async runTest(test) { // 1）由suite根节点向当前suite节点，依次执行beforeEach钩子函数 const _beforeEach = [].concat(this.suites).reverse().reduce((list, suite) =&gt; list.concat(suite._beforeEach), []); if (_beforeEach.length) { for (const fn of _beforeEach) { const result = await fn(); if (result instanceof Error) { return this.emit(constants.EVENT_FAIL, `\"before each\" hook for ${test.title}: ${result.message}`) } } } // 2）执行测试用例 const result = await test.fn(); if (result instanceof Error) { return this.emit(constants.EVENT_FAIL, `${test.title}`); } else { this.emit(constants.EVENT_PASS, `${test.title}`); } // 3）由当前suite节点向suite根节点，依次执行afterEach钩子函数 const _afterEach = [].concat(this.suites).reduce((list, suite) =&gt; list.concat(suite._afterEach), []); if (_afterEach.length) { for (const fn of _afterEach) { const result = await fn(); if (result instanceof Error) { return this.emit(constants.EVENT_FAIL, `\"after each\" hook for ${test.title}: ${result.message}`) } } } }}Runner.constants = constants;module.exports = Runner 代码很长，我们稍微捋一下。 首先，我们构造一个 Runner 类，利用两个 async 方法来完成对 suite-test 树的遍历： runSuite ：负责执行 suite 节点。它不仅需要调用 runTest 执行该 suite 节点上的若干 test 节点，还需要调用 runSuite 执行下一级的若干 suite 节点来实现遍历，同时，before/after 也将在这里得到调用。执行顺序依次是：before -&gt; runTest -&gt; runSuite -&gt; after。 runTest ：负责执行 test 节点，主要是执行该 test 对象上定义的测试用例。另外，beforeEach/afterEach 的执行有一个类似浏览器事件捕获和冒泡的过程，我们需要沿节点路径向当前 suite 节点方向和向 suite 根节点方向分别执行各 suite 的 beforeEach/afterEach 钩子函数。执行顺序依次是：beforeEach -&gt; run test case -&gt; afterEach。 在遍历过程中，我们依然是利用一个栈列表来维护 suite 根节点到当前节点的路径。同时，这两个流程都用 async/await 写法来组织，保证所有任务在异步场景下依然是按序执行的。 其次，测试结论是“边执行边输出”的。为了在执行过程中能向 reporter 实时通知执行结果和执行状态，我们让 Runner 类继承自 EventEmitter 类，使其具备订阅/发布事件的能力，这个后续会细讲。 最后，我们在 Mocha 实例的 run 方法中去实例化 Runner 并调用它： 1234567891011// mocha/src/mocha.js// ...const Runner = require('./runner');class Mocha { // ... run() { const runner = new Runner(); runner.run(this.rootSuite); }} 3、输出测试报告reporter 负责测试报告输出，这个过程是在执行测试用例的过程中同步进行的，因此我们利用 EventEmitter 让 reporter 和 runner 保持通信。在 runner 中我们已经在各个关键节点都作了 event emit，所以我们只需要在 reporter 中加上相应的事件监听即可： 12// mocha/reporters/index.jsmodule.exports.spec = require('./spec'); 1234567891011121314151617181920212223// mocha/reporters/spec.jsconst constants = require('../src/runner').constants;module.exports = function (runner) { // 执行开始 runner.on(constants.EVENT_RUN_BEGIN, function() {}); // suite执行开始 runner.on(constants.EVENT_SUITE_BEGIN, function(suite) {}); // suite执行结束 runner.on(constants.EVENT_SUITE_END, function() {}); // 用例通过 runner.on(constants.EVENT_PASS, function(title) {}); // 用例失败 runner.on(constants.EVENT_FAIL, function(title) {}); // 执行结束 runner.once(constants.EVENT_RUN_END, function() {});} Mocha 类中引入 reporter，执行事件订阅，就能让 runner 将测试的状态结果实时推送给 reporter 了： 1234567891011// mocha/src/mocha.jsconst reporters = require('../reporters');// ...class Mocha { // ... run() { const runner = new Runner(); reporters['spec'](runner); runner.run(this.rootSuite); }} reporter 中可以任意构造你想要的报告样式输出，例如这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// mocha/reporters/spec.jsconst constants = require('../src/runner').constants;const colors = { pass: 90, fail: 31, green: 32,}function color(type, str) { return '\\u001b[' + colors[type] + 'm' + str + '\\u001b[0m';}module.exports = function (runner) { let indents = 0; let passes = 0; let failures = 0; function indent(i = 0) { return Array(indents + i).join(' '); } // 执行开始 runner.on(constants.EVENT_RUN_BEGIN, function() { console.log(); }); // suite执行开始 runner.on(constants.EVENT_SUITE_BEGIN, function(suite) { console.log(); ++indents; console.log(indent(), suite.title); }); // suite执行结束 runner.on(constants.EVENT_SUITE_END, function() { --indents; if (indents == 1) console.log(); }); // 用例通过 runner.on(constants.EVENT_PASS, function(title) { passes++; const fmt = indent(1) + color('green', ' ✓') + color('pass', ' %s'); console.log(fmt, title); }); // 用例失败 runner.on(constants.EVENT_FAIL, function(title) { failures++; const fmt = indent(1) + color('fail', ' × %s'); console.log(fmt, title); }); // 执行结束 runner.once(constants.EVENT_RUN_END, function() { console.log(color('green', ' %d passing'), passes); console.log(color('fail', ' %d failing'), failures); });} 五、验证到这里，我们的 simple-mocha 就基本完成了，我们可以编写一个测试用例来简单验证一下： 12345678910111213141516171819202122232425262728// test/test.spec.jsconst assert = require('assert');describe('Array', function () { describe('#indexOf()', function () { it('should return -1 when not present', function () { assert.equal(-1, [1, 2, 3].indexOf(4)) }) it('should return the index when present', function () { assert.equal(-1, [1, 2, 3].indexOf(3)) }) }) describe('#every()', function () { it('should return true when all items are satisfied', function () { assert.equal(true, [1, 2, 3].every(item =&gt; !isNaN(item))) }) })})describe('Srting', function () { describe('#replace', function () { it('should return a string that has been replaced', function () { assert.equal('hey Hankle', 'hey Densy'.replace('Densy', 'Hankle')) }) })}) 这里我们用 node 内置的 assert 模块来执行断言测试。下边是执行结果： 123456789101112131415161718npm test&gt; simple-mocha@1.0.0 test /Documents/simple-mocha&gt; node mocha Array #indexOf() ✓ should return -1 when not present × should return the index when present #every() ✓ should return true when all items are satisfied String #replace ✓ should return a string that has been replaced 3 passing 1 failing 测试用例执行成功。附上完整的流程图： 结尾如果你看到了这里，看完并看懂了上边实现 simple-mocha 的整个流程，那么很高兴地告诉你，你已经掌握了 Mocha 最核心的运行机理。simple-mocha 的整个实现过程其实就是 Mocha 实现的一个简化。而为了让大家在看完这篇文章后再去阅读 Mocha 源码时能够更快速地理解，我在简化和浅化 Mocha 实现流程的同时，也尽可能地保留了其中的一些命名和实现细节。有差别的地方，如执行测试用例环节，Mocha 源码利用了一个复杂的 Hook 机制来实现异步测试的依序执行，而我为了方便理解，用 async/await 来替代实现。当然这不是说 Mocha 实现得繁琐，在更加复杂的测试场景下，这套 Hook 机制是十分必要的。所以，这篇文章仅仅希望能够帮助我们攻克 Mocha 源码阅读的第一道陡坡，而要理解 Mocha 的精髓，光看这篇文章是远远不够的，还得深入阅读 Mocha 源码。 参考文章 Mocha官方文档BDD和Mocha框架","link":"/2019/10/09/换种方式读源码：如何实现一个简易版的Mocha/"},{"title":"记一次Node.js直出服务的性能优化","text":"作者：肖睦群、李刚松 一.问题背景MPM（Market Page Maker）是京东社交电商部的组件化的页面可视化搭建平台，于2016年9月份上线，平均每周150+个页面，目前已经成为社交电商部的一个核心系统。系统使用Vue.js作为组件化的基础框架,并于2017年5月份上线了Node.js直出服务。MPM的页面会被运营同学拿到各种渠道投放，整体流量很不稳定，对于流量的暴涨情况要能够及时处理，这对于开发同学来说是一个比较烦的工作。 前几天突然收到告警信息，由于运营同学将某个MPM活动页面投放了外部广告，直出服务流量大涨，服务器CPU使用率达到了80%以上，于是立马申请扩容，问题虽解决，但是留给了我们一个问题：直出服务能否优化，这次量级的流量进来之后，是否可以稳定支撑而不需要扩容？ 二.分析方法及问题点由于本次告警问题主要是流量暴涨导致的CPU使用率过大，我们本次重点优化服务的CPU消耗性能。分析CPU消耗的方法有多种,我们选择其中操作比较简单的v8-profiler方案：安装NPM包v8-profiler，在直出服务中添加监控代码，打包发布到预发布环境进行压测，收集监控数据再进行分析。监控代码如下： 12345678910111213141516const profiler = require('v8-profiler');const fs = require('fs');(function cpuProf() { setTimeout(function () { console.log('开始收集CPU数据'); profiler.startProfiling('CPU profile'); setTimeout(function () { const profile = profiler.stopProfiling(); profile.export(function (err, result) { fs.writeFileSync('profile.json', result); profile.delete(); console.log('CPU数据收集完成'); }); }, 1000 * 60 * 5);//监控数据采集5分钟 }, 1000);})(); 上述代码会采集服务端5分钟的CPU消耗数据，并生成一个JSON文件，将此文件下载到本地后，导入到在线分析网址https://www.speedscope.app/ （或者用Chrome DevTool也可以），可以看到火焰图如下： 从火焰图可以看到函数的调用栈，从上而下就是调用栈，其中横条长度越长代表这占用cpu的时间越长。如果某个横条很长，但是下面又没有很细小的子调用，一般就表示该调用消耗时间比较长，可以考虑做优化。从图中我们可以看到，消耗性能的主要有几个地方：1）replace函数2）compile函数3）parse函数4）vue渲染 为了方便后文的分析，我们先了解一下直出服务的处理过程： 步骤 处理流程 资源消耗类型 备注 1 服务收到请求，解析页面参数 CPU计算 2 从Redis中读取页面数据(PageData) 网络IO PageData包括页面的各种配置信息，如页面头尾模板、页面楼层信息、身份判断要求、组件元数据等 3 解析PageData CPU计算 4 组装后端请求参数 CPU计算 5 发起后端请求并等待返回 网络IO 6 解析后端接口返回的JSON数据 CPU计算 7 页面模板构造 CPU计算 由于存在用户身份判断（如某些组件仅对新人可见）、楼层BI等原因，组件的容器是动态构造的 8 组件渲染 CPU计算 此处的组件渲染是Vue组件的服务端渲染 9 吐出页面HTML 网络IO 三.replace函数调用优化分析具体的replace函数调用之前，我们先详细分析一下上面表格的第7步:页面模板构造。 1.页面模板构造由于存在用户身份判断（如某些组件仅对新人或者VIP用户可见）、楼层BI（每个用户展示的楼层顺序都不一样）等原因，相同页面对于不同的用户展示的组件数量、顺序都是不一样（即千人千面），因此页面的模板是基于各个组件的模板动态构造的。为方便对组件进行操作，每个组件都有一个div容器，容器构造很简单，示例代码如下： 1234&lt;div id='com_1001'&gt;__vue_com_1001_replace__&lt;/div&gt;&lt;div id='com_1002'&gt;__vue_com_1002_replace__&lt;/div&gt;&lt;div id='com_1003'&gt;__vue_com_1003_replace__&lt;/div&gt;&lt;div id='com_1004'&gt;__vue_com_1004_replace__&lt;/div&gt; 其中vue_com_1001_replace这种是占位符，需要用相应位置的组件的实际模板来替换。但是这里有个问题，Vue渲染的时候，使用Render Function进行渲染的，并不是普通的字符串模板或者Vue模板。下面是一段模板编译后的Render Function： 1_c('commontag',{ref:\"__uid__replace__str__\",attrs:{\"uid\":\"__uid__replace__str__\",\"params\":params___uid__replace__str__},inlineTemplate:{render:function(){with(this){return _c('div',[(true)?[(params.transparent != 1)?_c('div',{staticClass:\"vueSeparator\",style:({'background-color':params.color, height: params.height + 'px'})}):_c('div',{staticClass:\"vueSeparator\",style:({height: params.height + 'px'})})]:_e()],2)}},staticRenderFns:[]}}) 若使用的是Vue模板，则会在运行时做一次编译，编译为Render Function，比较耗性能，因此官方推荐的做法是在构建时预编译，并且运行时使用不包含编译函数的精简版。目前MPM每个组件存储到Redis中的也是Render Function，而不是原始的Vue模板。所以现在的问题是，已知子组件编译后的Render Function，并且知道各个组件的DOM结构形式的容器，能否构造出父组件的Render Function？ 答案当然是可以：可以通过字符串操作，构造出父组件的Render Function！ 我们以下面这段代码为例，看看构造过程（为了简单处理，我们用了内联模板）： 1234567891011&lt;ParentComponent&gt; &lt;SubComponent1 inline-template :param=\"data.sub1\"&gt; &lt;p&gt;this is SubComponent1{{param.name}}&lt;/&gt; &lt;/SubComponent1&gt; &lt;SubComponent2 inline-template :param=\"data.sub2\"&gt; &lt;p&gt;this is SubComponent2{{param.name}}&lt;/&gt; &lt;/SubComponent2&gt; &lt;SubComponent3 inline-template :param=\"data.sub3\"&gt; &lt;p&gt;this is SubComponent3{{param.name}}&lt;/&gt; &lt;/SubComponent3&gt;&lt;/ParentComponent&gt; 上述代码经过Vue.compile函数编译处理后，会得到一个包含render和staticRenderFns两个属性的对象，我们主要看render属性，它是一个匿名函数，代码如下： 1234function anonymous() {with(this){return _c('ParentComponent',[_c('SubComponent1',{attrs:{\"param\":data.sub1},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent1\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent2',{attrs:{\"param\":data.sub2},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent2\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent3',{attrs:{\"param\":data.sub3},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent3\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}})],1)}} 将上面的代码再格式化一下： 123456789function anonymous() {with(this){return _c('ParentComponent',[_c('SubComponent1',{attrs:{\"param\":data.sub1},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent1\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent2',{attrs:{\"param\":data.sub2},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent2\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent3',{attrs:{\"param\":data.sub3},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent3\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}})],1)}} 可以看到上面第4、5、6行代码，就是子组件的Render Function，他们包裹在一个数组里。因此，如果知道子组件的Render Function，配合形如下面的模板，就可以反过来构造出父组件的Render Function（当然有一个从字符串到函数的反序列化过程，但是在我们的场景这个不可避免，因为模板是从Redis中读取出来的）。 123456789function anonymous() {with(this){return _c(&apos;ParentComponent&apos;,[__SubComponent1_replace__,__SubComponent2_replace__,__SubComponent3_replace__],1)}} 再回到我们的问题，我们已知子组件的Render Function，并且已知父组件的容器，需要构造出父组件的Render Function。现在思路就很清晰了，我们只需要把开头那段包含占位符的div容器代码， 1234&lt;div id='com_1001'&gt;__vue_com_1001_replace__&lt;/div&gt;&lt;div id='com_1002'&gt;__vue_com_1002_replace__&lt;/div&gt;&lt;div id='com_1003'&gt;__vue_com_1003_replace__&lt;/div&gt;&lt;div id='com_1004'&gt;__vue_com_1004_replace__&lt;/div&gt; 使用Vue.compile函数将其编译成Render Function，处理成字符串后，再通过正则替换其中的子组件的占位符，变成子组件模板，最后反序列化为父组件的Render Function即可。整体处理逻辑如下： 2.问题代码分析了解了上述处理过程，我们再根据火焰图中的调用栈，找到replace函数调用的问题代码： 12345678910111213141516171819Object.keys(MPM_COM_STYLE_MAP).forEach(function(comId){ var styleKey = MPM_COM_STYLE_MAP[comId]; var code = ''; if(hideComIds.indexOf(comId)!=-1){ code = HIDE_TPL; }else if(loadingComs.indexOf(comId)!=-1){ code = LOADING_TPL; }else if(MPM_STYLE_TPL_MAP[styleKey]) { // 第一次replace替换 code = MPM_STYLE_TPL_MAP[styleKey].replace(/__uid__replace__str__/g, comId); } else{ console.error('最终替换，发现无模板组件',comId); } if(code) { //第二次replace替换 compileTpl = compileTpl.replace(`_v(\"__vue__${comId}__replace__\")`,code); } }); 可以看到有两次replace函数调用，第一次是组件ID替换（即uid替换），第二次是组件模板替换。 先分析第一次replace函数调用。前面提到，每个组件的模板已经编译为Render Function并存在Redis中。但是同一个组件在页面中可能有多个实例，每个实例需要有一个ID来区分，我们称为uid（unique ID的意思），uid只有在运行的时候才生成，在编译的时候是不知道的，因此用了一个占位符（即下图中的uidreplace__str__），在直出服务中需要做替换，即上面代码中的uid替换。下面是一段编译后的代码： 每个页面会有很多个组件（数十个甚至上百个），每次替换都是在之前替换的结果之上进行的，形成了循环替换，前面导致告警的那个页面用到的编译之后的模版最大的有20+KB，而每次正则替换之后的模版会越来越长，所以这里耗时较多也就不奇怪了。 从逻辑上讲，这段代码是必不可少的，但是又有性能瓶颈，如何优化？ 3.uid替换优化我们研究发现：对于比较长的字符串，先用字符串的split方法分割成数组，再用数组的join方法将切割的数组合并为一个字符串，比正则替换的效率要高。此法我们称为数组粘合法。以下为测试代码： 12345678910111213141516171819202122const exeCount = 10000000; //执行次数,此处分别换成1W、10W、100W、1000W//测试字符串，需要比较长的字符串才能看到效果，下面是从我们的组件模板中摘取的一段const str = `_c('ds',{ref:\"__uid__replace__str__\",attrs:{\"uid\":\"__uid__replace__str__\",\"params\":params___uid__replace__str__,\"tab-index\":\"3\"},inlineTemplate:{render:function(){with(this){return _c('div',{attrs:{\"stylkey\":data.styleKey,\"pc\":data.pc,\"actid\":data.actid,\"areaid\":data.areaid}},[_c('ul',{directives:[{name:\"getskuad\",rawName:\"v-getskuad\",value:({bindObj:data, appendName:'skuAd', show: params.extend.showAds}),expression:\"{bindObj:data, appendName:'skuAd', show: params.extend.showAds}\"}],staticClass:\"pinlei_g3col\"},[(true)?_l((params.fnObj.translate(data.itemList)),function(item,index){return (!params.shownum || index &lt; params.shownum || data.showMore)?_c('li',{class:['pinlei_g3col_col', (params.extend.imgSize == '1' ? 'size_230x230' : 'size_230x320')],attrs:{\"index\":index}},[_c('div',{staticClass:\"pinlei_g3col_img\"},[_c('a',{attrs:{\"href\":params.extend.buttonType == '5' ? addRd(goPingouUrl(item.sUrl),params.ptag) : addRd(item.sUrl,params.ptag)}},[_c('img',{attrs:{\"init_src\":getImgUrl('//img12.360buyimg.com/mcoss/'+ item.sPicturesUrl),\"data-size\":\"230x230\"}})]),((params.extend.sellOut != '0') &amp;&amp; (item.dwStock - 0 &gt; 0))?_c('div',{staticClass:\"pinlei_g3col_msk\"},[_m(0,true)]):_e()]),_c('div',{staticClass:\"pinlei_g3col_info\"},[_c('div',{class:['pinlei_g3col_t1', 'red', (params.extend.titleHeight == '1' ? 'oneline' : '')]},[_v(\"\\n \"+_s(item.sProductName)+\"\\n \")]),(!params.fnObj.isBeforeActive(params.extend.beginTime))?_c('div',{staticClass:\"pinlei_g3col_price red\",style:({color: params.extend.isShowTokenPrice == '1' &amp;&amp; item.dwTokenPrice &amp;&amp; (Number(item.dwTokenPrice) != 0)?'#888':''})},[_v(\"\\n ￥\"),_c('b',[_v(_s(item.dwRealTimePrice.split('.')[0]))]),_v(\".\"+_s(item.dwRealTimePrice.split('.')[1])+\"\\n \")]):_e(),(params.fnObj.isBeforeActive(params.extend.beginTime))?_c('div',{staticClass:\"pinlei_g3col_price red\",style:({color: params.extend.isShowTokenPrice == '1' &amp;&amp; item.dwTokenPrice &amp;&amp; (Number(item.dwTokenPrice) != 0)?'#888':''})},[_v(\"\\n ￥\"),_c('b',[_v(_s(params.fnObj.getYushouInt(item, params.extend.priceType)))]),_v(_s(params.fnObj.getYushouDecimal(item, params.extend.priceType))+\"\\n \")]):_e(),(params.extend.isShowTokenPrice == '1')?[_c('div',{staticClass:\"pinlei_g3col_token\"},[(item.dwTokenPrice &amp;&amp; (Number(item.dwTokenPrice) != 0))?_c('div',{staticClass:\"pinlei_g3col_token_price\"},[_v(\"专属价:￥\"),_c('b',[_v(_s(parseFloat(item.dwTokenPrice)))])]):_e()])]:_e(),(params.fnObj.isBeforeActive(params.extend.beginTime))?[_c('div',{staticClass:\"pinlei_g3col_desc red\"},[(item.sBackUpWords[0] &amp;&amp; (params.fnObj.getYushouJiaDiff(item,params.extend.priceType) &gt; 0))?[_v(\"比现在买省\"+_s(params.fnObj.getYushouJiaDiff(item,params.extend.priceType))+\"元\")]:(item.sTag)?[_v(_s(item.sTag.split('|')[0]))]:(params.extend.showAds == '1' &amp;&amp; item.skuAd)?[_v(_s(item.skuAd))]:_e()],2)]:_e(),(!params.fnObj.isBeforeActive(params.extend.beginTime))?[_c('div',{staticClass:\"pinlei_g3col_desc red\"},[(item.sTag)?[_v(_s(item.sTag.split('|')[0]))]:(params.extend.showAds == '1' &amp;&amp; item.skuAd)?[_v(_s(item.skuAd))]:_e()],2)]:_e(),(params.fnObj.isBeforeActive(params.extend.beginTime))?[(params.extend.buttonType == '0')?[(params.extend.priceType == '1')?_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId}),expression:\"{skuId: item.ddwSkuId}\"}],class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime), 'right': item.sBackUpWords[2]},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")]):_e(),(params.extend.priceType == '0')?_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId}),expression:\"{skuId: item.ddwSkuId}\"}],class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime), 'right': item.sBackUpWords[2]},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")]):_e()]:_e(),(params.extend.buttonType == '1')?[_c('a',{attrs:{\"href\":addRd(item.sUrl,params.ptag)}},[_c('div',{class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime)},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])])]:_e(),(params.extend.buttonType == '5')?[_c('a',{attrs:{\"href\":addRd(goPingouUrl(item.sUrl),params.ptag)}},[_c('div',{class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime)},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])])]:_e(),(params.extend.buttonType == '2')?[_c('a',{attrs:{\"href\":addRd(item.sUrl,params.ptag)}},[_c('div',{class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime)},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n 定金\"+_s(item.sBackUpWords[1].split('+')[0])+\"抵\"+_s(parseFloat((item.sBackUpWords[1].split('+')[1] * item.sBackUpWords[1].split('+')[0]).toFixed(2)))+\"\\n \")])])]:_e(),(params.extend.buttonType == '3')?[_c('div',{directives:[{name:\"yuyue\",rawName:\"v-yuyue\",value:({bindObj:data,stop:true, activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}),expression:\"{bindObj:data,stop:true, activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}\"}],class:['pinlei_g3col_btn','blue', item.state == 1 ? 'disabled' : ''],style:(params.extend.priceType == 0?'border-radius: 24px;':''),attrs:{\"yuyueid\":params.extend.yuyueID}},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])]:_e(),(params.extend.buttonType == '4' )?[((params.fnObj.getYushouJiaDiff(item,params.extend.priceType)&gt; 0))?_c('div',{directives:[{name:\"skuyuyue\",rawName:\"v-skuyuyue\",value:({bindObj:data,stop:true, skuId:item.ddwSkuId,appendTo:item,ignoreHistory:true,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'},actPrice:params.fnObj.getYushouInt(item, params.extend.priceType)+params.fnObj.getYushouDecimal(item, params.extend.priceType),classId:item.classId1+'_'+item.classId2+'_'+item.classId3}),expression:\"{bindObj:data,stop:true, skuId:item.ddwSkuId,appendTo:item,ignoreHistory:true,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'},actPrice:params.fnObj.getYushouInt(item, params.extend.priceType)+params.fnObj.getYushouDecimal(item, params.extend.priceType),classId:item.classId1+'_'+item.classId2+'_'+item.classId3}\"}],class:['pinlei_g3col_btn','blue', item.state == 1 ? 'disabled' : ''],style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")]):_c('div',{directives:[{name:\"skuyuyue\",rawName:\"v-skuyuyue\",value:({bindObj:data,stop:true, skuId:item.ddwSkuId,ignoreHistory:true,appendTo:item,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'}}),expression:\"{bindObj:data,stop:true, skuId:item.ddwSkuId,ignoreHistory:true,appendTo:item,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'}}\"}],class:['pinlei_g3col_btn','blue', item.state == 1 ? 'disabled' : ''],style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])]:_e(),(params.extend.buttonType == '6' )?[_c('div',{directives:[{name:\"yuyue\",rawName:\"v-yuyue\",value:({bindObj:data,stop:true,noTip:true,activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}),expression:\"{bindObj:data,stop:true,noTip:true,activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}\"},{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: {skuId: item.ddwSkuId,successTxt:'预约加车成功'}}),expression:\"{skuId: {skuId: item.ddwSkuId,successTxt:'预约加车成功'}}\"}],class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime), 'left': params.fnObj.getCouponInfo(item.sBackUpWords[2])},style:(params.extend.priceType == 0?'border-radius: 24px;':''),attrs:{\"yuyueid\":params.extend.yuyueID}},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])]:_e()]:_e(),(!params.fnObj.isBeforeActive(params.extend.beginTime))?[(params.extend.buttonActiveType == '0')?[_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId}),expression:\"{skuId: item.ddwSkuId}\"}],staticClass:\"pinlei_g3col_btn\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])]:_e(),(params.extend.buttonActiveType == '1')?[_c('a',{attrs:{\"href\":addRd(item.sUrl,params.ptag)}},[_c('div',{staticClass:\"pinlei_g3col_btn red\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])])]:_e(),(params.extend.buttonActiveType == '2')?[_c('a',{attrs:{\"href\":addRd(goPingouUrl(item.sUrl),params.ptag)}},[_c('div',{staticClass:\"pinlei_g3col_btn red\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])])]:_e(),(params.extend.buttonActiveType == '4')?[_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId, bindObject: item, bindPropertyName: 'addCartMsg', isPullQuan: true}),expression:\"{skuId: item.ddwSkuId, bindObject: item, bindPropertyName: 'addCartMsg', isPullQuan: true}\"},{name:\"quan\",rawName:\"v-quan\",value:({bindObj:data,key:params.extend.key, level:params.extend.level, num:1, msg:{}, appendTo:item, appendName:'status', ignoreHistory:false, style:2, successUrl:item.successUrl, type:1, coupondes:{value: params.extend.price, gate: params.extend.gate, name: params.extend.name}}),expression:\"{bindObj:data,key:params.extend.key, level:params.extend.level, num:1, msg:{}, appendTo:item, appendName:'status', ignoreHistory:false, style:2, successUrl:item.successUrl, type:1, coupondes:{value: params.extend.price, gate: params.extend.gate, name: params.extend.name}}\"}],staticClass:\"pinlei_g3col_btn\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])]:_e()]:_e()],2),(params.extend.corner != '0')?[(isRange(params.extend.cornerBegin, params.extend.cornerEnd) &amp;&amp; params.extend.cornerDes)?_c('div',{staticClass:\"pinlei_g3col_stamp red\"},[_v(_s(params.extend.cornerDes))]):(item.sCopyWriting)?_c('div',{staticClass:\"pinlei_g3col_stamp red\"},[_v(_s(item.sCopyWriting))]):_e()]:_e()],2):_e()}):_e()],2),(params.shownum &amp;&amp; data.itemList.length &gt; params.shownum)?[_c('div',{class:'pinlei_more '+ (data.showMore?'pinlei_more_unfold':''),on:{\"click\":function($event){toggleMore($event)}}},[_v(_s(data.showMore?'收起更多':'展开更多'))])]:_e()],2)}},staticRenderFns:[function(){with(this){return _c('div',{staticClass:\"pinlei_g3col_msk_ico\"},[_c('div',{staticClass:\"pinlei_g3col_msk_text\"},[_v(\"\\n 已抢光\\n \"),_c('br'),_v(\"over\\n \")])])}}]}})`//正则替换法startconst timeStart = new Date().getTime();for(var i = 0; i &lt; exeCount; i++) { str.replace(/__uid__replace__str__/g, 'com_1001');}const timeEnd = new Date().getTime();console.log('正则替换耗时：', timeEnd - timeStart);//正则替换法end//数组粘合法startconst timeStart2 = new Date().getTime();const segs = str.split('__uid__replace__str__');for(var i = 0; i &lt; exeCount; i++) { segs.join('com_1001');}const timeEnd2 = new Date().getTime();console.log('数组粘贴耗时：', timeEnd2 - timeStart2);//数组粘合法end 结果如下： 执行次数 正则替换法耗时(ms) 数组粘合法耗时(ms) 正则替换法耗时/数组粘合法耗时 1W 42 25 1.68 10W 362 179 2.01 100W 3555 1623 2.2 1000W 36449 18634 1.95 可以看到数组粘合法的耗时是正则替换法的一半左右。 考虑到我们的场景就是字符串比较大，存在循环替换，且是海量服务的场景，因此上面第一次替换，直接改成数组粘合法即可。 4.组件模板替换优化问题代码中的第二次替换，是将容器里的组件占位符替换为子组件的Render Function。即下图所示：子模板替换优化的替换次数其实是跟组件的数量相关的，即使有150个组件，用数组粘合法也不会有明显的性能提升，因此需要考虑别的办法。 我们查了一下vue-template-compiler的源码(Vue的compile能力也是用此模块)，发现Vue.compile的函数有2个参数，第一个参数是待编译的Vue模板，第二个参数是一个option对象，包含一个名为tansformCode钩子函数(参见资料https://github.com/vuejs/vue/blob/dev/flow/compiler.js#L38-L45 ，此参数并未在官网的文档中暴露，关于此函数的用处后面可以再写一篇文章) ，这个钩子函数接受两个参数，第一个是ast节点，第二个是编译该节点之后的render code，而该函数的返回值会就是最终的render code。于是在之前的生成dom函数那里把com占位符替换为一个空的div元素，div元素的id为之前的占位符，然后在编译的时候在transformCode钩子函数这里做一个替换，当发现ast节点为div并且id符合组件占位符的规则，那么就返回该组件对应的编译之后样式模版。具体代码如下： 1234567891011121314var compileTpl = compiler.compile(`&lt;div&gt;${html}&lt;/div&gt;`, { modules: { transformCode: function (el, code) { if (el.attrsMap &amp;&amp; el.attrsMap['id'] &amp;&amp; el.attrsMap['id'].match(/__vue__com_\\d{4,5}__replace__/)) { var comId = el.attrsMap['id'].match(/com_\\d{4,5}/)[0]; // console.log('--------------------------------', comId); var styleTemplate = compiledComTplMap[comId]; // console.log(styleTemplate); return styleTemplate; } return code; } } }).staticRenderFns.toString(); 这样一来就完全省去了第二次字符串替换的操作，于是组件编译这里的流程了下面这样： 这两次优化之后然后重新压测并收集性能数据，得到的火焰图如下： 可以看到createApp函数里面原来的那个replace函数的横条已经消失不见了，说明前面的优化是有效果的，最耗时的操作已经不是replace而是vue的compile方法即模版的编译。从此次优化前后的服务端压测的CPU数据也能说明问题： 四.compile函数调用优化compile函数调用，就是前面”组件模板构造”那一节提到的，将组件的容器模板用Vue.compile函数编译成Render Function，虽然这段容器模板很简单，但是他是一个很耗性能的操作。而且这是Vue自身提供的能力，似乎已经没有多大的优化余地了。有没有其他优化方法呢？ 仔细观察一下组件容器dom以及编译之后的代码，似乎是有规律的。如果组件树的结构是下面这样的： 12345678910[ {id: \"com_1001\"}, { id: \"com_1002\", child: [ {id: \"com_1003\"}, {id: \"com_1004\"} ] }]; 拼接之后的html内容大概是下面这样的： 12345678&lt;div&gt; &lt;div id=\"com_1001_con\"&gt;&lt;/div&gt; &lt;div id=\"com_1002_con\"&gt;&lt;/div&gt; &lt;div mpm_edit_child_box tabpid=\"com_1002\" class=\"childBox\"&gt; &lt;div id=\"com_1003_con\"&gt;&lt;/div&gt; &lt;div id=\"com_1004_con\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这里一般都只是一些简单的模版，编译出来大概是这样的： 1234567891011121314with(this) { return _c('div', [ _c('div', {attrs: {\"id\": \"com_1001_con\"}}), _v(\" \"), _c('div', {attrs: {\"id\": \"com_1002_con\"}}), _v(\" \"), _c('div', {staticClass: \"childBox\", attrs: {\"mpm_edit_child_box\": \"\", \"tabpid\": \"com_1002\"}}, [ _c('div', {attrs: {\"id\": \"com_1003_con\"}}), _v(\" \"), _c('div', {attrs: {\"id\": \"com_1004_con\"}}) ]) ])} 通过观察可以发现，这里都是生成的div元素，div上的属性都是静态属性，由此我们可以自己实现一个简单的“编译”函数，不用走vue的编译： 1234567891011121314151617function simpleCompile(comList) { function genTree(tree) { var html = ''; for (var i = 0, len = tree.length; i &lt; len; i++) { var node = tree[i]; var comId = node.id; html += `_c('div',{attrs:{\"id\":\"${comId}_con\"}},[`; html = html + compiledComTplMap[comId] + '])'; // compiledComTplMap[comId] 该组件对应的编译后的样式模版 if (node.child &amp;&amp; node.child.length) { html += `,_c('div',{staticClass:\"childBox\",attrs:{\"mpm_edit_child_box\":\"\",\"tabpid\":\"${comId}\"}},[` + genTree(node.child) + `])`; } html += (i === len - 1) ? '' : ','; } return html; } return genTree(comList); } 经测试，这样简单“编译”之后生成的代码跟之前编译的代码是一样的，在预发布环境测试了多个页面之后，页面渲染也没有问题。去掉Vue模版编译之后整个组件渲染的逻辑就变成了下面这样： Vue编译优化之后收集cpu数据得到的火焰图如下： 从火焰图可以看出，原来的那个compile函数调用的横条也消失了，说明优化有效果。再看看压测的CPU消耗情况： 需要提到的是，由于是自己实现了一个简单版的compile函数，前文中关于compile函数调用优化的代码，也直接去掉了，当然也到达了优化的效果。 五.其他优化研究经过上面两次优化之后，剩下最耗性能的地方是JSON解析和Vue渲染了。我们也做了一下研究，但是很可惜，暂时没什么成果，不过我们的探索也可以提一下：1）JSON解析。我们的服务从Redis中读出来的PageData比较大，一般有100多KB，很需要有一个高性能的JSON反序列化的库(即代替JSON.parse)。目前有一个高性能的库fast-json-stringify，但是可惜他是做序列化的（即做的是JSON.stringify做的事情）。我们测试了多个方案，目前原生的JSON.parse函数性能是最好的。2）Vue渲染。有位腾讯的同学提到，用string-based的模板代替VirtualDom的渲染方案提升性能,不过他忽略了一点，Vue是完全的组件化的、是有生命周期钩子、方法、计算属性等，不是一个简简单单的模板引擎，按照他的思路是需要把生命周期的钩子、方法、计算属性等全部算好后拿到的数据对象，再跟string-based模板结合才能渲染，这个显然是和组件化的思路背道而驰的。 上面2点，各位看官如果有好的思路，欢迎不吝赐教！ 六.总结这次优化总的来说，CPU性能消耗得到了有效优化，整体提升了大概20%，一方面为公司节省了资源，另外一方面也减少了因流量暴涨导致我们要扩容的几率，一举两得。","link":"/2019/09/27/记一次Node-js直出服务的性能优化/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS Houdini","slug":"CSS-Houdini","link":"/tags/CSS-Houdini/"},{"name":"AST","slug":"AST","link":"/tags/AST/"},{"name":"web内容","slug":"web内容","link":"/tags/web内容/"},{"name":"电池电量","slug":"电池电量","link":"/tags/电池电量/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"},{"name":"webpack loader","slug":"webpack-loader","link":"/tags/webpack-loader/"},{"name":"工程化","slug":"工程化","link":"/tags/工程化/"},{"name":"资源治理","slug":"资源治理","link":"/tags/资源治理/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/前端工程化/"},{"name":"碰撞检测","slug":"碰撞检测","link":"/tags/碰撞检测/"},{"name":"向量","slug":"向量","link":"/tags/向量/"},{"name":"type=\"module\"","slug":"type-module","link":"/tags/type-module/"},{"name":"代码拆分","slug":"代码拆分","link":"/tags/代码拆分/"},{"name":"rollup打包","slug":"rollup打包","link":"/tags/rollup打包/"},{"name":"modulepreload","slug":"modulepreload","link":"/tags/modulepreload/"},{"name":"引导蒙层","slug":"引导蒙层","link":"/tags/引导蒙层/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"桌面开发","slug":"桌面开发","link":"/tags/桌面开发/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Mocha","slug":"Mocha","link":"/tags/Mocha/"},{"name":"BDD/TDD","slug":"BDD-TDD","link":"/tags/BDD-TDD/"},{"name":"测试框架","slug":"测试框架","link":"/tags/测试框架/"},{"name":"Vue.compile","slug":"Vue-compile","link":"/tags/Vue-compile/"},{"name":"CPU性能优化","slug":"CPU性能优化","link":"/tags/CPU性能优化/"},{"name":"火焰图","slug":"火焰图","link":"/tags/火焰图/"}],"categories":[{"name":"Web开发","slug":"Web开发","link":"/categories/Web开发/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Web前端","slug":"Web前端","link":"/categories/Web前端/"}]}