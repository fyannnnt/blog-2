{"pages":[{"title":"WecTeam | 京东社交电商前端团队","text":"维C团简介维C团(WecTeam)是京东社交电商部一群热爱技术、乐于分享的前端工程师自发成立的一个前端技术团队，希望通过技术实践总结、新技术探秘、Bug深度分析、优质英文资料引入等方式，参与和推动前端技术的发展，为公司及行业带来价值！ 联系我们","link":"/about/index.html"}],"posts":[{"title":"CSS Houdini实现动态波浪纹","text":"作者：黄浩群 CSS Houdini 号称 CSS 领域最令人振奋的革新。CSS 本身长期欠缺语法特性，可拓展性几乎为零，并且新特性的支持效率太低，兼容性差。而 Houdini 直接将 CSS 的 API 暴露给开发者，以往完全黑盒的浏览器解析流开始对外开放，开发者可以自定义属于自己的 CSS 属性，从而定制和扩展浏览器的展示行为。 背景我们知道，浏览器在渲染页面时，首先会解析页面的 HTML 和 CSS，生成渲染树（rendering tree），再经由布局（layout）和绘制（painting），呈现出整个页面内容。在 Houdini 出现之前，这个流程上我们能操作的空间少之甚少，尤其是 layout 和 painting 环节，可以说是完全封闭，使得我们很难通过 polyfill 等类似的手段为欠支持的 CSS 特性提供兼容。而另一方面，语法特性的缺失也极大地限制了 CSS 的编程灵活性，社区中 sass、less、stylus 等 CSS 预处理技术的出现大多都源于这个原因，它们都希望通过预编译，突破 CSS 的局限性，让 CSS 拥有更强大的组织和编写能力。所以慢慢地，我们都不再手写 CSS，更方便、更灵活的 CSS 扩展语言成了 web 开发的主角。看到这样的情况，CSS Houdini 终于坐不住了。 什么是 CSS Houdini？CSS Houdini 对外开放了浏览器解析流程的一系列 API，这些 API 允许开发者介入浏览器的 CSS engine 运作，带来了更多的 CSS 解决方案。 CSS Houdini 目前主要提供了以下几个 API： CSS Properties and Values API 允许在 CSS 中定义变量和使用变量，是目前支持程度最高的一个 API。CSS 变量以 -- 开头，通过 var() 调用： 1234div { --font-color: #9e4a9b; color: var(--font-color);} 此外，CSS 变量也可以在其他节点中使用，只不过是有作用域限制的，也就是说自身定义的 CSS 变量只能被自身或自身的子节点使用： 123456.container { --font-color: #9e4a9b;}.container .text { color: var(--font-color);} 定义和使用 CSS 变量可以让我们的 CSS 代码变得更加简洁明了，比如我们可以单纯通过改变变量来改变 box-shadow 的颜色： 1234567.text { --box-shadow-color: #3a4ba2; box-shadow: 0 0 30px var(--box-shadow-color);}.text:hover { --box-shadow-color: #7f2c2b;} Painting API 允许开发者编写自己的 Paint Module，自定义诸如 background-image 这类的绘制属性。自定义的重点在于，”怎么画” 的逻辑需要我们来描述，因此我们利用 registerPaint 来描述我们的绘制逻辑： 12345registerPaint('rect', class { paint(ctx, size, properties, args) { // @TODO }}); registerPaint 方法注册了一个 Paint 类 rect 以供调用，这个类的核心在于它的 paint 方法。paint 方法用于描述自定义的绘制逻辑，它接收四个参数： ctx：一个 Canvas 的 Context 对象，因此 paint 中的绘制方式跟 canvas 绘制是一样的。 size：包含节点的尺寸信息，同时也是 canvas 可绘制范围（画板）的尺寸信息。 properties：包含节点的 CSS 属性，需要调用静态方法 inputProperties 声明注入。 args: CSS 中调用 Paint 类时传入的参数，需要调用静态方法 inputArguments 声明注入。 编写完 Paint 类之后，我们在 CSS 中只需要这样调用，就能应用到我们自定义的绘制逻辑： 123.wrapper { background-image: paint(rect);} Painting API 目前在高版本 Chrome、Opera 浏览器已有支持，且实现起来比较简单，后边我们还将通过 demo 进一步演示。 Layout API允许开发者编写自己的 Layout Module，自定义诸如 display 这类的布局属性。同样的，”如何布局” 的逻辑需要我们自己编写： 1234567891011registerLayout('block-like', class { layout(children, edges, constraints, properties, breakToken) { // @TODO return { // inlineSize: number, // blockSize: number, // autoBlockSize: number, // childFragments: sequence&lt;LayoutFragment&gt; } }}) registerLayout 方法用于注册一个 Layout 类以供调用，它的 layout 方法用于描述自定义的布局逻辑，最终返回一个包含布局后的位置尺寸信息和子节点序列信息的对象，引擎将根据这个对象进行布局渲染。 同样的，调用时只需： 123.wrapper { display: layout('block-like');} 因此利用 Layout API，你完全可以实现对 flex 布局的手工兼容。相比 Painting，Layout 的编写显得更加复杂，涉及到盒模型的深入概念，且支持度不高，这里就不细讲了。 WorkletsregisterPaint、registerLayout 这些 API 在全局上并不存在，为什么可以直接调用呢？这是因为上述的 JS 代码并不是直接执行的，而是通过 Worklets 载入执行的。Worklets 类似于 Web Worker，是一个运行于主代码之外的独立工作进程，但比 Worker 更为轻量，负责 CSS 渲染任务是最合适的了。和 Web Worker 一样，Worklets 拥有一个隔离于主进程的全局空间，在这个空间里，没有 window 对象，却有 registerPaint、registerLayout 这些全局 API。因此，我们需要这样引入自定义 JS 代码： 123if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\");} 123if (\"layoutWorklet\" in CSS) { CSS.layoutWorklet.addModule(\"layoutworklet.js\");} 基础：三步用上 Painting API我们来自定义 background-image 属性，它将用于给作用节点绘制一个矩形背景，背景色值由该节点上的一个 CSS 变量 --rect-color 指定。 1、编写一个 Paint 类：新建一个 paintworklet.js，利用 registerPaint 方法注册一个 Paint 类 rect，定义属性的绘制逻辑： 12345678910registerPaint(\"rect\", class { static get inputProperties() { return [\"--rect-color\"]; } paint(ctx, geom, properties) { const color = properties.get(\"--rect-color\")[0]; ctx.fillStyle = color; ctx.fillRect(0, 0, geom.width, geom.height); }}); 上边定义了一个名为 rect 的 Paint 类，当 rect 被使用时，会实例化 rect 并自动触发 paint 方法执行渲染。paint 方法中，我们获取节点 CSS 定义的 --rect-color 变量，并将元素的背景填充为指定颜色。由于需要使用属性 --rect-color，我们需要在静态方法 inputProperties 中声明。 2、Worklets 加载 Paint 类：HTML 中通过 Worklets 载入上一步骤实现的 paintworklet.js 并注册 Paint 类： 123456&lt;div class=\"rect\"&gt;&lt;/div&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); }&lt;/script&gt; 3、使用 Paint 类：CSS 中使用的时候，只需要调用 paint 方法： 123456.rect { width: 100vw; height: 100vh; background-image: paint(rect); --rect-color: rgb(255, 64, 129);} 可以看得出利用 CSS Houdini，我们可以像操作 canvas 一样灵活自如地实现我们想要的样式功能。 进阶：实现动态波纹根据上述步骤，我们演示一下如何用 CSS Painting API 实现一个动态波浪的效果： 1234567891011121314151617181920212223242526&lt;!-- index.html --&gt;&lt;div id=\"wave\"&gt;&lt;/div&gt;&lt;style&gt; #wave { width: 20%; height: 70vh; margin: 10vh auto; background-color: #ff3e81; background-image: paint(wave); }&lt;/style&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); const wave = document.querySelector(\"#wave\"); let tick = 0; requestAnimationFrame(function raf(now) { tick += 1; wave.style.cssText = `--animation-tick: ${tick};`; requestAnimationFrame(raf); }); }&lt;/script&gt; 12345678910111213141516171819202122232425262728// paintworklet.jsregisterPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { let tick = Number(properties.get('--animation-tick')); const { width, height } = geom; const initY = height * 0.4; tick = tick * 2; ctx.beginPath(); ctx.moveTo(0, initY + Math.sin(tick / 20) * 10); for (let i = 1; i &lt;= width; i++) { ctx.lineTo(i, initY + Math.sin((i + tick) / 20) * 10); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + Math.sin(tick / 20) * 10); ctx.closePath(); ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fill(); }}) paintworklet 中，利用 sin 函数绘制波浪线，由于 AnimationWorklets 尚处于实验阶段，开放较少，这里我们在 worklet 外部用 requestAnimationFrame API 来做动画驱动，让波浪纹动起来。完成后能看到下边这样的效果。 然而事实上这个效果略显僵硬，sin 函数太过于规则了，现实中的波浪应该是不规则波动的，这种不规则主要体现在两个方面： 1）波纹高度（Y）随位置（X）变化而不规则变化 把图按照 x-y 正交分解之后，我们希望的不规则，可以认为是固定某一时刻，随着 x 轴变化，波纹高度 y 呈现不规则变化； 2）固定某点（X 固定），波纹高度（Y）随时间推进而不规则变化动态过程需要考虑时间维度，我们希望的不规则，还需要体现在时间的影响中，比如风吹过的前一秒和后一秒，同一个位置的波浪高度肯定是不规则变化的。 提到不规则，有朋友可能想到了用 Math.random 方法，然而这里的不规则并不适合用随机数来实现，因为前后两次取的随机数是不连续的，而前后两个点的波浪是连续的。这个不难理解，你见过长成锯齿状的波浪吗？又或者你见过上一刻 10 米高、下一刻就掉到 2 米的波浪吗？ 为了实现这种连续不规则的特征，我们弃用 sin 函数，引入了一个包 simplex-noise。由于影响波高的有两个维度，位置 X 和时间 T，这里需要用到 noise2D 方法，它提前在一个三维的空间中，构建了一个连续的不规则曲面： 123456789101112131415161718192021222324252627282930313233343536373839404142// paintworklet.jsimport SimplexNoise from 'simplex-noise';const sim = new SimplexNoise(() =&gt; 1);registerPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { const tick = Number(properties.get('--animation-tick')); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.4)', 0.004, tick, 15, 0.4); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.5)', 0.006, tick, 12, 0.4); } /** * 绘制波纹 */ drawWave(ctx, geom, fillColor, ratio, tick, amp, ih) { const { width, height } = geom; const initY = height * ih; const speedT = tick * ratio; ctx.beginPath(); for (let x = 0, speedX = 0; x &lt;= width; x++) { speedX += ratio * 1; var y = initY + sim.noise2D(speedX, speedT) * amp; ctx[x === 0 ? 'moveTo' : 'lineTo'](x, y); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + sim.noise2D(0, speedT) * amp); ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill(); }}) 修改峰值和偏置项等参数，可以再画多一个不一样的波浪纹，效果如下，完工！ 参考文章 CSS Painting API Level 1CSS Layout API Level 1CSS 魔術師 Houdini API 介紹","link":"/2019/07/12/CSS Houdini实现动态波浪纹/"},{"title":"Javascript抽象语法树上篇(基础篇)","text":"作者：陈晓强 一、基础为什么要了解抽象语法树日常工作中，我们会碰到js代码解析的场景，比如分析代码中require了哪些包，有些什么关键API调用，大部分情况使用正则表达式来处理，可一旦场景复杂，或者依赖于代码上下文时，正则就很难处理了，这时候就要用到抽象语法树。常见的uglify、eslint、babel、webpack等等都是基于抽象语法树来处理的，如此强大，有必要好好了解一下。 什么是抽象语法树抽象语法树即：Abstract Syntax Tree。简称AST，见下图。 图中code先经过parse转换成一个树状数据结构 接着对树中节点进行转换，图中将叶子节点对换位置 将树状结构通过generate再生成code 图中树状数据结构即AST，从这个过程可以看到将代码转成AST后，通过操作节点来改变代码。 如何获得抽象语法树获得抽象语法树的过程为：代码 =&gt; 词法分析 =&gt; 语法分析 =&gt; AST词法分析：把字符串形式的代码转换为令牌（tokens）流。语法分析：把一个令牌流转换成 AST 的形式。这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。如下图，代码为一个简单的函数声明。词法分析阶段，将代码作为字符串输入获得关键词，图中function、square、(、)、{、}等都被识别为关键词(稍微回忆下编译原理，字符挨个入栈，符合一定规则即出栈)。语法分析阶段，对关键词的组合形成一个个节点，如n*n这3个关键词组合成二元表达式，关键词return与二元表达式组合成return语句。最后组合成一个函数声明语句。 二、规范如何获得AST已经简单介绍了，那AST最终应该以什么样的数据结构存在呢，先看看上述函数声明的AST结构 那解析的依据是什么，为什么要以上图的结构出现，业界已经有了一套成熟的规范。 规范起源在v8引擎之前，最早js引擎是SpiderMonkey，第一个版本由js作者Brendan Eich设计，后交给Mozilla组织维护。js引擎在执行js文件时，都会先将js代码转换成抽象语法树(AST)。有一天，一位Mozilla工程师在FireFox中公开了这个将代码转成AST的解析器Api，也就是Parser_API[1]，后来被人整理到github项目estree[2]，慢慢的成了业界的规范。 规范解读上面提到的Parser_API是规范的原文，中文版:Parser_API[3]，但读起来并不太友好，推荐直接读整理后的git项目estree，打开项目地址，如下图其中最下面的es5.md为ES5规范，仅列出ES5的内容，es2015.md为ES6规范，但只列出了针对ES5新增的内容，依次类推，最后的es2019.md即ES10是对ES9的补充，仅有一条规则。 打开最基础的es5.md，可以看到所有语法基础，这里跟大家一起读一下大类，细分类别就略过了。读规范时可以使用https://astexplorer.net/ 辅助阅读，可以实时输出AST。 Node objects Programs Identifier Literal Functions Statements Declarations Expressions Patterns Node objects1234interface Node { type: string; loc: SourceLocation | null;} 定义AST中节点基本类型，其他所有具体节点都需要实现以上接口，即每个节点都必须包含type、loc两个字段 type字段表示不同的节点类型，下边会再讲一下各个类型的情况，分别对应了 JavaScript 中的什么语法。你可以从这个字段看出这个节点实现了哪个接口loc字段表示源码的位置信息，如果没有相关信息的话为 null，否则是一个对象，包含了开始和结束的位置。接口如下 12345interface SourceLocation { source: string | null; start: Position; end: Position;} 每个 Position 对象包含了行（从1开始）和列（从0开始）信息，接口如下 1234interface Position { line: number; // &gt;= 1 column: number; // &gt;= 0} Programs1234interface Program &lt;: Node { type: \"Program\"; body: [ Directive | Statement ];} 一棵完整的程序代码树，一般作为根节点 Identifier1234interface Identifier &lt;: Expression, Pattern { type: \"Identifier\"; name: string;} 标识符，我们写代码时自定义的名称，如变量名、函数名、属性名。 Literal1234interface Literal &lt;: Expression { type: \"Literal\"; value: string | boolean | null | number | RegExp;} 字面量，如“hello”、true、null、100、/\\d/这些，注意字面量本身也是一个表达式语句(ExpressionStatement) Functions12345interface Function &lt;: Node { id: Identifier | null; params: [ Pattern ]; body: FunctionBody;} 一个函数声明或者表达式，id是函数名，params是标识符数组，body是函数体，也是一个语句块。 Statements1interface Statement &lt;: Node { } 语句，子类有很多，块语句、if/switch语句、return语句、for/while语句、with语句等等 Declarations1interface Declaration &lt;: Statement { } 声明，子类主要有变量申明、函数声明。 Expressions1interface Expression &lt;: Node { } 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式(a = 1)等等 Patterns1interface Pattern &lt;: Node { } 模式，主要在 ES6 的解构赋值中有意义(let {name} = user，其中{name}部分为ObjectPattern)，在 ES5 中，可以理解为和Identifier 差不多的东西。 三、现状通过以上规范解读，知道了最终要生成的AST以什么样的结构存在，对于javascript的解析，业界已经有很多成熟的解析器，可以将js代码转换成符合规范的AST Esprima，比较经典，出现的比较早 Acorn，fork自Esprima，代码更精简。webpack使用acorn进行模块解析 UglifyJS2，主要用于代码压缩 babylon，babel解析器，fork自Acorn，目前最新版本是babylon7,对应npm包@babel/parser Espree，eslint默认的解析器，由于遵循同一套规范，也可以使用babel的解析器替代 flow、shift等等 AST基础篇介绍完毕，下篇将从实践的角度继续介绍 References[1] Parser_API：https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API[2] estree：https://github.com/estree/estree[3] Parser_API(中文)：https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API","link":"/2019/07/19/Javascript抽象语法树上篇(基础篇)/"},{"title":"Javascript抽象语法树下篇(实践篇)","text":"作者：陈晓强 上篇已经对AST基础做了介绍，本篇介绍AST的运用 AST应用的三个要点 需要一个解析器，将代码转换为AST 需要一个遍历器，能够遍历AST,并能够方便的对AST节点进行增删改查等操作 需要一个代码生成器，能够将AST转换为代码 esprima与babel常用的满足上述3个要点的工具包有两个，一个是esprima，一个是babel esprima相关包及使用如下 1234567891011const esprima = require('esprima'); // code =&gt; astconst estraverse = require('estraverse'); //ast遍历const escodegen = require('escodegen'); // ast =&gt; codelet code = 'const a = 1';const ast = esprima.parseScript(code);estraverse.traverse(ast, { enter: function (node) { //节点操作 }});const transformCode = escodegen.generate(ast); babel相关包及使用如下 123456789101112const parser = require('@babel/parser'); //code =&gt; astconst traverse = require('@babel/traverse').default; // ast遍历，节点增删改查，作用域处理等const generate = require('@babel/generator').default; // ast =&gt; codeconst t = require('@babel/types'); // 用于AST节点的Lodash式工具库,各节点构造、验证等let code = 'const a = 1';let ast = parser.parse(sourceCode);traverse(ast, { enter (path) { //节点操作 }})const transformCode = escodegen.generate(ast); 目前babel不管是从生态上还是文档上比esprima要好很多，因此推荐大家使用babel工具，本文示例也使用babel来做演示。 使用babel工具操作AST如上一章节所示 @babel/parser用于将代码转换为AST @babel/traverse用于对AST的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将AST转换成代码 @babel/types 用于AST节点操作的Lodash式工具库,各节点构造、验证等 更多api详见babel手册[1] 下面通过简单案例来介绍如何操作AST，注意案例只是示例，由于篇幅对部分边界问题只会注释说明，实际开发过程中需要考虑周全。 案例1:去掉代码中的console.log()实现代码 123456789101112131415161718192021const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `function square(n) { console.log(n); console.warn(n); return n * n;}`let ast = parser.parse(sourceCode);traverse(ast, { CallExpression(path) { let { callee } = path.node; if (callee.type === ‘MemberExpression’ &amp;&amp; callee.object.name === ‘console’ &amp;&amp; callee.property.name === ‘log’ ) { path.remove(); // 注意考虑对象挂载的识别，如global.console.log()，此时remove后剩下global.,会导致语法错误，此时可以判断父节点类型来排除 } }})console.log(generate(ast).code); 处理结果 12345function square(n) {- console.log(n); console.warn(n); return n * n;} 此案例涉及知识点 如何通过traverse遍历特定节点 识别出console.log()在规范中属于函数调用表达式,节点类型为CallExpression。 console.log本身即callee是在对象console上的一个方法，因此console.log是一个成员表达式，类型为MemberExpression。 MemberExpression根据规范有一个object属性代表被访问的对象，有一个property代表访问的成员。 通过path.remove()api可以对节点进行删除。 可以通过https://astexplorer.net/ 来辅助对代码节点的识别。注意选择babylon7，即babe7,对应@babel/parser 案例2:变量混淆实现代码 12345678910111213141516171819const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `function square(number) { console.warn(number); return number * number;}`let ast = parser.parse(sourceCode);traverse(ast, { FunctionDeclaration(path) { let unia = path.scope.generateUidIdentifier(\"a\"); path.scope.rename(\"number\",unia.name); }})console.log(generate(ast).code); 处理结果 1234567-function square(number) {+ function square(_a) {- console.warn(number);+ console.warn(_a);- return number * number;+ return _a * _a;} 此案例涉及知识点 path.scope保存了当前作用域的相关信息 可以通过api对作用域内的变量名进行批量修改操作 通过path.scope可以获得当前作用域唯一标识符，避免变量名冲突 案例3:转换箭头函数并去掉未使用参数实现代码 123456789101112131415161718192021222324252627const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(1); },200)});`let ast = parser.parse(sourceCode);traverse(ast, { ArrowFunctionExpression (path) { let { id, params, body } = path.node; for(let key in path.scope.bindings){ //注意考虑箭头函数的this特性，若发现函数体中有this调用，则需要在当前作用域绑定其父作用域的this if(!path.scope.bindings[key].referenced){ params = params.filter(param=&gt;{ return param.name!==key; }) } } path.replaceWith(t.functionExpression(id, params, body)); }})console.log(generate(ast).code); 处理结果 1234567-new Promise((resolve,reject)=&gt;{+new Promise(function(resolve){- setTimeout(()=&gt;{+ setTimeout(function(){ resolve(1); },200)}); 此案例涉及知识点 箭头函数节点：ArrowFunctionExpression 通过path.scope可以识别变量引用情况，是否有被引用，被哪些路径引用 通过@babel/types可以很方便的构建任意类型节点 通过path.replaceWith()可以进行节点替换 案例4:京东购物小程序的Tree-shaking删掉小程序中的冗余代码，部分实现代码示例如下 1234567891011121314151617181920212223242526272829const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `export function square (x) { return x * x;}export function cube (x) { return x * x * x;}`let ast = parser.parse(sourceCode);traverse(ast, { ExportNamedDeclaration (path) { let unused = ['cube'] // 借助webpack，我们能获得导出的方法中，哪些是没有被使用过的 let { declaration = {} } = path.node; if (declaration.type === 'FunctionDeclaration') { unused.forEach(exportItem =&gt; { // references=1表示仅有一次引用，即export的引用，没有在别处调用 if (declaration.id.name === exportItem &amp;&amp; path.scope.bindings[exportItem].references === 1) { path.remove(); } }); } }})console.log(generate(ast).code); 处理结果 123456export function square (x) { return x * x;}-export function cube (x) {- return x * x * x;-} 此案例涉及知识点 export节点：ExportNamedDeclaration 案例5:将代码转换成svg流程图此案例是git上一个比较有意思的开源项目，通过AST将代码转换为svg流程图，详见js-code-to-svg-flowchart[2] 可以体验一下：demo[3] 通过以上示例，可以看到通过AST我们可以对代码任意蹂躏，做出很多有意思的事情 AST在其他语言的应用除了Javascript，其他语言如HTML、CSS、SQL等也有广泛的AST应用。如下图，可以在这里找到对应语言的解析器，开启AST之门。 结语在上述AST网站中，可以看到HTML的解析器有个vue选项，读过vue源码的同学应该知道vue模板在转换成HTML之前会先将模板转换成AST然后生成render function进而生成VirtualDOM。我们平时开发对AST使用比较少，但其实到处都能见到AST的影子：babel、webpack、eslint、taro等等。希望能抛砖引玉，使同学们在各自团队产出更多基于AST的优秀工具、项目。 References[1] babel手册：https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md[2] js-code-to-svg-flowchart：https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart[3] demo：https://bogdan-lyashenko.github.io/js-code-to-svg-flowchart/docs/live-editor/index.html","link":"/2019/07/20/Javascript抽象语法树下篇(实践篇)/"},{"title":"【译】Web内容如何影响电池的使用","text":"原文地址：https://webkit.org/blog/8970/how-web-content-can-affect-power-usage/原文作者：Benjamin Poulain &amp; Simon Fraser译者：刘辉 校验：李刚松 现在用户上网大多使用移动设备或者笔记本电脑。对这两者来说，电池寿命都很重要。在这篇文章里，我们将讨论影响电池寿命的因素，以及作为一个web开发者，我们如何让网页耗电更少，以便用户有更多时间来关注我们的内容。 是什么在耗电？移动设备的电力消耗有以下几个因素： CPU （核心处理器） GPU （图形处理） 网络 （wifi或者蜂窝移动网络） 屏幕 屏幕功耗相对稳定，并且主要由用户控制（通过屏幕使用时间和亮度），但是对于其他组件，例如CPU，GPU，网络模块，功耗是动态变化的，而且变化范围很大。 系统根据当前正在处理的任务调整CPU和GPU性能，包括在Web浏览器中用户正在交互的网页以及使用Web内容的其他应用程序。这是通过打开或关闭某些组件以及通过更改其时钟频率来完成的。总的来说，芯片所需的性能越高，其功率效率就越低。硬件可以非常快速地提升到高性能（但是需要很大的功率），然后迅速恢复到更高效的低功耗状态。 良好用电的一般原则为了最大限度地延长电池寿命，你必须尽量减少硬件处于高功率状态的时间，让硬件尽可能的处于空闲状态。 对于web开发者来说，有三种交互场景需要注意： 用户主动与内容交互 页面处于前台，但是用户没有交互 页面处于后台 高效的用户交互用户交互的时候肯定会耗电。页面需要快速的加载，并且能够快速的响应触摸。在大多数场景中，减少首次渲染时间也会降低功耗。不过，在初始页面加载后继续加载资源和运行脚本时要小心。我们要尽快让系统返回空闲状态。总的来说，浏览器已经完成了布局和渲染，js执行的越少，耗电越少。 一旦页面加载完，用户可能会滚屏或者点击页面，这同样会产生耗电（主要是CPU和GPU）,这是必要的消耗。要确保尽快返回空闲状态。并且，最好使用浏览器本身提供的功能。- 举例：普通的页面滚动肯定比用js自定义的滚动更高效。 让空闲状态耗电趋向于零当用户没有和页面交互时，尽可能的使页面不耗电，例如： 尽量少用定时器以避免唤醒CPU,可以把基于定时器的任务合并，使用尽可能少的定时器。大量滥用定时器会导致CPU被频繁唤醒，这比把这些任务合并处理要糟糕的多。 最大限度地减少动画内容，如动画图像和自动播放视频。要特别注意”loading”用的gif图片或css动画，这些动画会不断触发渲染，即使看不到也会触发。IntersectionObserver可以用来在可见时才运行动画。 尽量用css做动画和过渡，这些动画不可见时，浏览器会进行优化，并且css动画比js动画要高效的多。 避免通过轮询来获取服务器更新，可以用websocket或者持久连接来代替轮询。 看起来处于空闲状态的页面，如果正在后台进行工作，其用户交互的响应效率也会降低，因此最小化后台活动也可以提高响应能力以及电池寿命。 页面在后台时CPU零使用这几种场景时，页面变为非活动状态(不是用户的首要焦点)，例如： 用户切换到其他tab 用户切换到其他app 浏览器窗口最小化 浏览器窗口失去焦点 浏览器窗口在其他窗口后面 窗口所在的空间不是当前空间（MacOS才有空间的概念） 当页面不活动时，webkit会自动做以下处理来减少耗电： 停止调用requestAnimationFrame CSS和SVG动画会暂停 定时器会节流 此外，WebKit利用操作系统提供的能力来最大限度地提高效率： 在iOS上，不用的选项卡(tab页)会完全暂停。 在macOS上，选项卡会响应App Nap功能，这意味着不可视更新的选项卡的Web进程优先级较低，并且其计时器会做节流处理。 但是，页面可以通过计时器（setTimeout和setInterval），消息，网络事件等触发CPU唤醒。页面在后台时应避免这些唤醒，有两个API对此有用： 页面可见性API提供了一种响应页面转换为后台或前台的方法。这是一种避免页面在后台时更新UI的好方法。用visibilitychange事件，在页面可见时更新页面内容。 页面失去焦点时会发出blur事件。这时，页面依然可见，但是不是聚焦窗口。可以考虑暂停动画。 查找问题最简单的方式就是用浏览器控制台的时间线功能。页面在后台时，时间线记录中不应该有任何事件发生。 找到问题所在现在我们知道了web页面主要的耗电因素，并且给出了一些创建高效页面的一般规则。 接下来讨论一下怎样找出并解决导致功耗过大的问题。 脚本如上所述，现代CPU能够把功率从空闲态的非常低提升到非常高来满足用户交互和其他任务的要求。 也正因为如此，CPU是导致电池寿命减少的主要原因。页面加载期间CPU要做一连串工作包括加载、解析、渲染资源，并且执行js。在大多数现代web页面上，执行js花费的时间远远高出浏览器用在其余加载过程中花费的时间。因为尽量减少js执行时间对省电有最大的效益。 测量CPU使用的最佳方法是使用Web Inspector，就像之前文章里所说的，时间线面板可以显示任意选定时间范围内的CPU活动。 为了高效地使用CPU，WebKit尽可能在多核上分配工作（使用Workers的页面也可以使用多核）。Web Inspector提供与页面主线程同时运行的线程的细分图表。例如，以下屏幕截图显示了滚动具有复杂渲染和视频播放的页面时的线程： 在寻找优化点时，应关注主线程，因为js运行在主线程上（除非您正在使用Workers）。我们可以使用时间线面板的 “JavaScript and Events” 项来了解触发脚本的内容。也许你在响应用户或滚动事件或从requestAnimationFrame触发隐藏元素的更新时做了太多工作。你需要了解你在页面上使用的JavaScript库和第三方脚本所做的工作。如果要深入挖掘，你可以使用Web Inspector的JavaScript profiler来查看时间都用在哪些地方。 “WebKit线程”中的活动主要由与JavaScript相关的工作触发：JIT编译和垃圾收集。因此减少运行的脚本数量并减少短生命周期的JavaScript对象可以降低webkit线程的活动。 WebKit调用的各种其他系统框架都使用线程，“Other thread” 包括了这些工作; “Other thread” 最主要的工作是渲染，我们将在下面讨论。 渲染主线程CPU使用也可以通过大量布局和绘制来触发；这些通常由脚本触发，但是除了transform，opacity和filter之外的属性的CSS动画也可以触发它们。查看时间线面板的 “Layout and Rendering” 项将帮助你了解导致活动的原因。 如果 “Layout and Rendering” 显示的渲染过程不能清楚展示页面正在发生什么变化，可以启用 Paint Flashing： 这部分渲染将用红色背景的高亮显示，你可以滚动页面查看。注意，WebKit会保留一些“透视”图块以允许平滑滚动，因此视口中不可见的图形仍然可以正常工作以使屏幕外图块保持最新。如果渲染展示在时间轴中，说明它正在工作。 除了导致CPU耗电外，渲染通常还会触发GPU工作。macOS和iOS上的WebKit使用GPU进行渲染，因此触发渲染可以显着增加耗电。额外的CPU使用通常显示在时间线面板 “CPU” 项中的 “Other threads” 下。 GPU还用于canvas渲染，包括2D画布和WebGL / WebGPU。为了最小限度使用绘图，canvas上显示的内容没有变化时不要调用canvas API，并尝试优化canvas绘制代码。 许多Mac笔记本电脑都有两个GPU，一个与CPU相同内核的集成GPU，功能不强但功耗低，一个功能更强大但是功耗也更高的独立GPU。 WebKit默认使用集成GPU；你可以使用powerPreference上下文创建参数请求独立GPU，但只有在你可以证明电源成本合理时才执行此操作。 网络无线网络会以意想不到的方式影响电池寿命。手机有功能更强大的无线模块（WiFi和蜂窝网络芯片）和更小的电池，因此受到的影响最大。 遗憾的是，在实验室外测量网络的功率影响并不容易，但可以通过遵循一些简单的规则来减少。 降低网络功耗的最直接方法是最大限度地利用浏览器的缓存。 减少页面加载时间的所有最佳实践也可以通过减少无线模块需要打开的时间来使电池受益。 另一个重要方面是在时间上将网络请求组合在一起。每当有新请求到来时，操作系统都需要打开无线模块，连接到基站或蜂窝塔，并传输字节。在发送分组之后，在发送更多分组的情况下，无线电保持供电少量时间。 如果页面非经常性的发送少量数据，则开销可能会大于传输数据所需的能量。 可以从 Web Inspector 的时间线面板的 “Network Requests” 项中发现此类问题。例如，以下屏幕截图显示了几秒钟内发送的四个单独请求： 同时发送所有请求将提高网络用电效率。 总结我们可以对网页做很多优化来延长电池寿命。 在Web Inspector中测量对电池影响并降低损耗非常重要。 这样做可以改善用户体验并延长电池寿命。 提高电池寿命的最直接方法是最大限度地降低CPU使用率。 新的Web Inspector提供了强大的工具可以全程监控。 为了让电池寿命更长，我们要： 在空闲时将CPU使用率降至零 在用户交互期间最大化性能以快速恢复空闲","link":"/2019/09/17/【译】Web内容如何影响电池的使用/"},{"title":"前端资源治理（一）","text":"作者：李刚松 0.也谈前端工程化随着前端技术的飞速发展，前端需要一种更加工程化的方式解决前端开发日益复杂的问题。前端工程化本质也是软件工程的一种，由于软件工程并无严格的定义(或者说缺乏统一的定义)，因此前端工程化的内涵其实相当宽泛，一般来说，前端工程化重点关注的是研发和维护效率，所有最终目的是这个的，都可以算作前端工程化的范畴。前端工程化近几年也是技术热点，基本上大型前端技术交流会议都有此专题，从规范、组件、编译及构建、工作流、持续集成、监控等多个维度都有涉及，笔者尝试从前端资源治理的角度谈一下前端工程化,本文是系列文章的第一篇，主要讲问题及解决的思路，不涉及具体的实现细节。 1.前端资源治理的含义首先，这里所说的前端资源，并非是仅指js、css、图片等静态资源，页面、后端接口、配置数据、监控点等，都可以纳入前端资源的定义的范畴。 在工作中，你是否会碰到以下问题： 同事或者领导发现某个页面有bug，需要在微信群或者内部沟通工具大群里问是谁负责？可能还要挨个艾特各个TL，需要各个TL确认。 某个组件要升级，但是不知道那些页面使用了，需要在沟通群里问或者搜项目源代码，逐个找到负责人。 某个大型营销活动突然要换一个新的氛围logo，但是不知道哪些页面使用了旧logo，需要安排巡检，人肉去找出来。 告警发现某个重要页面的出现了内容空窗，原因是运营同学没有及时补充运营数据，但是不知道是哪个运营负责，需要在微信大群或者内部沟通工具大群里问。 大促来临，某个重要页面的流量预计有10倍或者20倍的增长，要通知各个接口的同学做扩容和容灾准备，需要手工梳理页面的依赖的接口列表。 某个限时的页面已经到点下线，但是仍然有流量，不知道流量入口在哪里。 我要在统计系统上查看某个页面的性能数据，但是该系统是以页面名字而不是地址来查找的，查找过程找的人老眼昏花。 某个后端接口要升级或者要下线，需要分析nginx的访问日志找到页面地址，然后再拉各个TL，逐个确认都是哪些同事负责。 等等等 上面的问题一般是大型复杂业务场景（通常是多个团队合作开发，业务复杂，页面成百上千甚至上万）下才有的，如果你所在的团队也有上面的问题，那么我认为你也需要对前端的资源进行治理。 那么什么是前端资源治理呢？笔者对其的定义是： 将前端相关的页面、js/css/图片/字体、接口、配置、监控点等的依赖关系进行收集、存储和管理，并将割裂的组件系统、配置系统、监控系统、业务系统等进行重构和整合，最终形成以页面管理为基础的统一的有序的平台，所有关联信息都能够被查询和检索，最终实现整体协作效率的提升。 此处使用“治理”而不是“管理”的原因，“治理”一词更强调合作整改的过程。在很多互联网企业，通常已经有一些独立的组件系统、配置系统、监控系统等，但是这些系统很多都是独立的碎片化的系统，彼此都是割裂的，割裂意味着缺乏协同，进而影响研发效率。因此，前端资源治理的一个关键词是“整合”，整合已有的系统。 第二个关键词是“关联关系管理”，前端相关的页面、组件、js/css/图片/字体、接口、配置、监控点及负责人等，他们是存在关联关系的，比如页面是谁负责的、谁修改的、引用了哪些组件、图片、字体、接口、在什么地方配置数据、监控点都有哪些等，我们需要把这些关联关系在管理端记录下来，并提供检索和查询。 2.前端资源治理的实现前端资源信息看似繁杂，js、css、图片、页面、后端接口、配置数据、监控点等，但是他们有一个串联的锚点，这个锚点就是页面，不管是H5、小程序，还是原生APP，不管是从研发的角度，还是从反馈问题的角度，基本上都是以页面为单位进行的，其他的如组件、CSS、图片、接口、配置等，都是被页面引用的，都可以通过页面串联起来的，下图可以清晰的表达出这些依赖关系。 因此，实现前端资源治理的第一个要点是做好页面管理，把页面自身的信息，如页面名称、页面地址、负责人、修改时间等信息进行提取、存储,使之能够被查询和检索。在页面管理基础之上，我们还要把js、css、图片、页面、后端接口、配置数据、监控点等各个前端资源之间的关联关系也要存储和管理起来，使之能够被查询和检索。 关联关系从来源上讲，主要有以下几种来源： 代码静态分析产生。通常包括页面信息自身、页面跟js/css/图片等的依赖关系、页面跟接口的依赖关系等。 管理端配置产生。通常包括页面跟监控系统的配置、页面的运营配置数据等 统计数据产生。通常包括页面来源数据等。 2.1 页面信息的提取前端资源治理的第一要点是页面信息管理，因此必须能够拿到页面基本信息。页面基本信息应该包括哪些呢？通常来说，至少应该包括页面URL、页面名称、页面创建人、创建时间等几个字段。 当前的前端页面开发，不管是H5、小程序，还是原生APP，通常会经过编译构建的过程（通常是命令行工具或者IDE，比如基于gulp和webpack的工作流工具），在构建完成阶段可以提取出页面的基本信息。以下是编译构建提取页面信息的流程： 页面的编译构建流程，一般分为两种： 独立构建。常见于H5，此种场景一般是一个人负责一个页面，不存在多人协作的情况，也不需要git分支管理啥的，开发完成即可走构建流程，只需要在构建完成的时候分析即可，页面的URL、页面标题、创建人、创建时间等信息比较容易提取，比如页面修改人可以取自命令行工具的用户登录身份（命令行工具可以做类似于NPM的login功能，登录后记录用户身份ID）、页面标题可以解析页面html的title的内容（小程序下则解析自页面json文件的navigationBarTitleText字段）等。 持续集成构建。这种一般是需要多人协作的H5、小程序、原生APP等，一般涉及到分支管理和合并的问题，同一个页面可能被多人修改，因此页面信息中的用户信息部分提取相对复杂，需要分析git log信息才能拿到，其他的信息字段提取逻辑与独立构建情况相同。以下是一个典型的多人协作的页面的git log信息。 对于上面的情况，我们可以考虑定一个规则，比如取最近的5条log，并移除持续集成系统生成的log，管理端存储的时候回，以用户名+时间为key，去掉重复的部分。 构建流程分析出页面基本信息后，需提交到管理端保存，所以管理端需要提供post接口。管理端以此为基础，形成”页面管理系统“。 2.2 代码静态分析出的关联关系构建流程除可以分析基本信息外，还可以分析出页面的版本信息，比如页面依赖的组件依赖表、静态资源依赖表(js/css/图片)、接口依赖表、修改人、修改时间等。静态依赖分析通常有3种方式： 基于AST的依赖分析。AST就是抽象语法树，目前前端对他的研究和使用越来越广泛，webpack内部就使用了acorn这个AST分析库。借助于webpack强大的模块解析和依赖分析能力，我们可以拿到js与npm组件、css与背景图等之间的关联关系（可以在webpack的after-resolve钩子中进行分析）。另外，除了构建前的依赖关系，我们还可以拿到构建处理后的资源依赖关系（可以在webpac的emit钩子中进行分析），前者我们称为引用依赖关系（包括静态资源依赖表、组件依赖表），后者我们称为发布依赖关系。 基于DOM操作的依赖分析。webpack并不是以html为入口的，但是实际上我们的开发的入口可以认为就是页面，借助于JsDom等强大的类库，我们可以用我们熟悉的前端的DOM操作来分析html页面对js、css、图片等的依赖关系。 基于正则匹配的依赖分析。页面对于接口的依赖分析，由于这种是非明确的代码依赖关系，所以一般通过正则匹配来解析。一般对代码有一定的约束规则，比如不用用变量拼接接口地址。这个解析不会如AST那么精确，但是只要约定规则，基本上都能满足需求。可以考虑把此类实现封装为webpack的loader。上面的第一种和第三种的分析，都应该是一个递归分析过程，最终生成页面的静态资源依赖表、组件依赖表、接口依赖表等。这些信息提交到管理端进行保存。 2.3 管理系统之间的关联关系在很多互联网企业，通常已经有一些独立的成熟的CMS系统（如给运营用的内容配置系统，配置活动时间、商品ID等）、监控系统（如测速系统、业务监控系统、异常监控系统）等，通常这些系统由不同的团队开发，而且经常都有一个叫做”页面管理”的东西，且要手工配置页面地址。这些系统中的监控点配置、运营配置等信息，都是以页面维度进行创建和使用的，但是这些信息很难通过对前端代码静态分析的方法进行提取（比如运营配置信息，这个可以是前端直接使用，也可能是后端使用，要分析的话两端代码都要分析，比较麻烦）。我们的思路应该是在管理端通过页面管理来进行关联，实质上是要做系统整合。 整合的思路也比较简单，就是原来各个系统废弃掉原来自身的”页面管理“，而是使用前面静态分析提取到的统一的页面管理，监控系统、运营配置系统等系统都可以以此为入口进入，从而把页面相关的各个管理系统关联起来，进而把各种能力串联。 2.4 统计数据产生的关联关系对于大型应用来说，一般都有一些业务统计数据，最典型的就是点击流数据了。这种数据既不在代码中，也不在管理端配置，而且通过统计和分析才能拿到。前面提到的“某个限时的页面已经到点下线，但是仍然有流量，不知道流量入口在哪里”这种问题的解决，其实依赖于点击流的统计分析数据了，点击流系统一般都有“来源分析”，这种数据也不是敏感数据，所以可以考虑跟页面管理做关联和整合，或者提供API给页面管理系统。另外还有一个例子就是，接口和页面的关联关系，前面提到通过静态分析得到的页面和接口的依赖表有可能不够准确，但是接口访问Web Server的时候，一般都有access.log，可以通过access.log来做分析，拿到比较完整的页面依赖的接口信息，以及接口依赖的页面信息，有些接口的调用需要有open api的那种注册调用机制，就另当别论了。 2.5 关联关系的查询和存储管理端应该提供正反两个方向的查询和检索能力： 正向查询。通过页面来查询依赖的组件、静态资源(js/css/图片)、后端接口等。此种比较简单，因为提交的时候已经有完整的依赖信息，只需要提供简单的查询。 反向查询。通过组件、静态资源、接口、运营配置信息、监控配置信息等，反查有哪些页面依赖。 对于关联关系的存储，用关系型DB的话，一般只能使用like查询，可能要扫描全表，因而性能比较差，可以考虑存储到MongoDB中创建索引，或者存储到ElasticSearch中建立索引。 2.6 其他前面提到的，其实有一个假设的前提“只有一个Web应用，且接口都是前端发起的”，但是对于其他情况，思路是类似的： 多应用（业务）。多应用情况，通常要在页面管理的上一层加上“应用管理”，即页面属于哪一个应用(业务)。对于同一个页面投放在不同应用的场景，可能页面还得加上渠道标识。 页面直出（服务端渲染）。对于页面直出逻辑的代码，做前面类似的分析即可。另外，本文主要是探讨从前端视角考虑问题，所以关联核心是页面管理，但是从整体技术架构视角，可能就不是了。 3.结语本文探讨了前端资源治理的含义以及要解决的问题，并介绍了实现前端资源治理的思路，是笔者近期在前端工程化方面的思考，部分已经完成，部分正在推进。本文并不涉及实现的细节，细节在后面的系列文章中进一步讲解。前端治理的两个关键点，一个是系统整合，一个是关联关系管理，整体串联的核心是页面管理。","link":"/2019/09/24/前端资源治理（一）/"},{"title":"手把手教你写webpack loader","text":"作者：黄浩群 一、什么是 loaderloader 和 plugins 是 webpack 系统的两大重要组成元素。依靠对 loader、plugins 的不同组合搭配，我们可以灵活定制出高度适配自身业务的打包构建流程。 loader 是 webpack 容纳各类资源的一个重要手段，它用于对模块的源代码进行转换，允许你在 import 或加载模块时预处理文件，利用 loader，我们可以将各种类型的资源转换成 webpack 本质接受的资源类型，如 javascript。 二、如何编写一个 yaml-loader1、YAMLyaml 语言多用于编写配置文件，结构与 JSON 类似，但语法格式比 JSON 更加方便简洁。yaml 支持注释，大小写敏感，使用缩进来表示层级关系： 123456789101112131415161718192021#对象 version: 1.2.4#数组author: - Mike - Hankle#常量name: \"my project\" #定义一个字符串limit: 30 #定义一个数值es6: true #定义一个布尔值openkey: Null #定义一个null#锚点引用server: base: &amp;base port: 8005 dev: ip: 120.168.117.21 &lt;&lt;: *base gamma: ip: 120.168.117.22 &lt;&lt;: *base 等同于： 123456789101112131415161718192021{ \"version\": \"1.2.4\", \"author\": [\"Mike\", \"Hankle\"], \"name\": \"my project\", \"limit\": 30, \"es6\": true, \"openkey\": null, \"server\": { \"base\": { \"port\": 8005 }, \"dev\": { \"ip\": \"120.168.117.21\", \"port\": 8005 }, \"gamma\": { \"ip\": \"120.168.117.22\", \"port\": 8005 } }} 在基于 webpack 构建的应用中，如果希望能够引用 yaml 文件中的数据，就需要一个 yaml-loader 来支持编译。一般情况下，你都能在 npm 上找到可用的 loader，但如果万一没有对应的支持，或者你希望有一些自定义的转换，那么就需要自己编写一个 webpack loader 了。 2、loader 的原理loader 是一个 node 模块，它导出为一个函数，用于在转换资源时调用。该函数接收一个 String/Buffer 类型的入参，并返回一个 String/Buffer 类型的返回值。一个最简单的 loader 是这样的： 1234// loaders/yaml-loader.jsmodule.exports = function(source) { return source;}; loader 支持管道式传递，对同一类型的文件，我们可以使用多个 loader 进行处理，这批 loader 将按照“从下到上、从右到左”的顺序执行，并以前一个 loader 的返回值作为后一个 loader 的入参。这个机制无非是希望我们在编写 loader 的时候能够尽量避免重复造轮子，只关注需要实现的核心功能。因此配置的时候，我们可以引入 json-loader： 123456789101112131415161718192021// webpack.config.jsconst path = require(\"path\");module.exports = { // ... module: { rules: [ { test: /\\.yml$/, use: [ { loader: \"json-loader\" }, { loader: path.resolve(__dirname, \"./loaders/yaml-loader.js\") } ] } ] }}; 3、开始这样一来，我们需要的 yaml-loader，就只做一件事情：将 yaml 的数据转化成为一个 JSON 字符串。因此，我们可以很简单地实现这样一个 yaml-loader： 123456789101112var yaml = require(\"js-yaml\");module.exports = function(source) { this.cacheable &amp;&amp; this.cacheable(); try { var res = yaml.safeLoad(source); return JSON.stringify(res, undefined, \"\\t\"); } catch (err) { this.emitError(err); return null; }}; 就是这么简单。但是可能有朋友会问，这里是因为有个现成的模块 js-yaml，可以直接将 yaml 转换成 JavaScript 对象，万一没有这个模块，该怎么做呢？是的，loader 的核心工作其实就是字符串的处理，这是个相当恶心的活儿，尤其是在这类语法转换的场景上，对源代码的字符串处理将变得极其复杂。这个情况下，我们可以考虑另外一种解法，借助 AST 语法树，来协助我们更加便捷地操作转换。 4、利用 AST 作源码转换yaml-ast-parser 是一个将 yaml 转换成 AST 语法树的 node 模块，我们把字符串解析的工作交给了 AST parser，而操作 AST 语法树远比操作字符串要简单、方便得多： 1234567891011121314151617181920212223const yaml = require(\"yaml-ast-parser\");class YamlParser { constructor(source) { this.data = yaml.load(source); this.parse(); } parse() { // parse ast into javascript object }}module.exports = function(source) { this.cacheable &amp;&amp; this.cacheable(); try { const parser = new YamlParser(source); return JSON.stringify(parser.data, undefined, \"\\t\"); } catch (err) { this.emitError(err); return null; }}; 这里我们可以利用 AST parser 提供的方法直接转化出 json，如果没有或者有所定制，也可以手动实现一下 parse 的过程，仅仅只是一个树结构的迭代遍历而已，关键步骤是对 AST 语法树的各类型节点分别进行处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const yaml = require(\"yaml-ast-parser\");const types = yaml.Kind;class YamlParser { // ... parse() { this.data = this.traverse(this.data); } traverse(node) { const type = types[node.kind]; switch (type) { // 对象 case \"MAP\": { const ret = {}; node.mappings.forEach(mapping =&gt; { Object.assign(ret, this.traverse(mapping)); }); return ret; } // 键值对 case \"MAPPING\": { let ret = {}; // 验证 const keyValid = yaml.determineScalarType(node.key) == yaml.ScalarType.string; if (!keyValid) { throw Error(\"键值非法\"); } if (node.key.value == \"&lt;&lt;\" &amp;&amp; types[node.value.kind] === \"ANCHOR_REF\") { // 引用合并 ret = this.traverse(node.value); } else { ret[node.key.value] = this.traverse(node.value); } return ret; } // 常量 case \"SCALAR\": { return node.valueObject !== undefined ? node.valueObject : node.value; } // 数组 case \"SEQ\": { const ret = []; node.items.forEach(item =&gt; { ret.push(this.traverse(item)); }); return ret; } // 锚点引用 case \"ANCHOR_REF\": { return this.traverse(node.value); } default: throw Error(\"unvalid node\"); } }}// ... 当然这样的实现略为粗糙，正常来说，一些完备的 AST parser 一般都会自带遍历方法（traverse），这样的方法都是有做过优化的，我们可以直接调用，尽量避免自己手动实现。 按照相同的做法，你还可以实现一个 markdown-loader，甚至更为复杂的 vue-loader。 三、loader 的一些开发技巧1、单一任务只做一件事情，做好一件事情。loader 的管道（pipeline）设计正是希望能够将任务拆解并独立成一个个子任务，由多个 loader 分别处理，以此来保证每个 loader 的可复用性。因此我们在开发 loader 前一定要先给 loader 一个准确的功能定位，从通用的角度出发去设计，避免做多余的事。 2、无状态loader 应该是不保存状态的。这样的好处一方面是使我们 loader 中的数据流简单清晰，另一方面是保证 loader 具有良好可测性。因此我们的 loader 每次运行都不应该依赖于自身之前的编译结果，也不应该通过除出入参外的其他方式与其他编译模块进行数据交流。当然，这并不代表 loader 必须是一个无任何副作用的纯函数，loader 支持异步，因此是可以在 loader 中有 I/O 操作的。 3、尽可能使用缓存在开发时，loader 可能会被不断地执行，合理的缓存能够降低重复编译带来的成本。loader 执行时默认是开启缓存的，这样一来， webpack 在编译过程中执行到判断是否需要重编译 loader 实例的时候，会直接跳过 rebuild 环节，节省不必要重建带来的开销。 当且仅当有你的 loader 有其他不稳定的外部依赖（如 I/O 接口依赖）时，可以关闭缓存： 1this.cacheable &amp;&amp; this.cacheable(false);","link":"/2019/09/17/手把手教你写webpack-loader/"},{"title":"V8引擎和JavaScript优化建议","text":"原文地址：https://alligator.io/js/v8-engine/ 翻译：马雪琴 V8 是谷歌用于编译 JavaScript 的引擎，Firefox 同样也有一个，叫 SpiderMonkey，它和 V8 有一些不同，但总体颇为相似。我们将在本篇文章中讨论 V8。 V8 引擎的一些基础点： 用 C++ 语言实现，使用在 Chrome 浏览器和 Node.js 中（以及最新版的 Microsoft Edge） 遵循 ECMA-262 标准 JavaScript 旅程 当我们把压缩、混淆以及做了各种处理的 JavaScript 放到 V8 引擎中解析时，到底发生了些什么？ 下图阐述了整个流程，接下来我们会对其中的每个步骤进行详细说明： 在本篇文章中，我们将探讨 JavaScript 代码是如何被解析的，以及如何最大程度的优化 JavaScript 的编译效率。V8 里的优化编译器（又名 Turbofan）拿到 JavaScript 代码之后，会将其转化成高效率的机器码，因此，我们能向其输入越多的代码，我们的应用就会越快。附注一点，Chrome 里的解释器称作 Ignition。 JavaScript 解析整个过程中的第一步是解析 JavaScript。首先探讨什么是解析。 解析有两个阶段： Eager（全解析）- 立即解析所有的代码 Lazy（预解析）- 按需做最少的解析，剩下的留到后面 哪一种方式更好则需要根据实际情况来决定。 下面来看一段代码。 1234567891011// 变量声明会被立即解析const a = 1;const b = 2;// 目前不需要的暂时不解析function add(a, b) { return a + b;}// add 方法被执行到了，所以需要返回解析该方法add(a, b); 变量声明会被立即解析，函数则会被懒解析，但上述代码里紧接着就执行了 add(a, b)，说明 add 方法是马上就需要用到的，所以这种情况下，把 add 函数进行即时解析会更高效。 为了让 add 方法被立即解析，我们可以这样做： 1234567891011// 变量声明会被立即解析const a = 1;const b = 2;// eager parse this toovar add = (function(a, b) { return a + b;})();// add 方法已经被解析过了，所以这段代码可以立即执行add(a, b); 这就是大多数模块被创建的过程。那么，立即解析会是高效 JavaScript 应用的最好方式吗？ 我们可以用 optimize-js 这个工具对公共库代码进行完全的立即解析处理，比如对比较有名的 lodash 进行处理后，优化效果是很显著的： 没有使用 optimize-js：11.86ms 使用了 optimize-js：11.24ms 必须声明的是，该结果是在 Chrome 浏览器中得到的，其它环境的结果则无法保证： 如果您需要优化应用，必须在所有的环境中进行测试。 另一个解析相关的建议是不要让函数嵌套： 123456789// 糟糕的方式function sumOfSquares(a, b) { // 这里将被反复懒解析 function square(num) { return num * num; } return square(a) + square(b);} 改进后的方式如下： 12345678910function square(num) { return num * num;}// 好的方式function sumOfSquares(a, b) { return square(a) + square(b);}sumOfSquares(a, b); 上述示例中，square 方法只被懒解析了一次。 内联函数Chrome 有时候会重写 JavaScript 代码，内联函数即是这样一种情况。 下面是一个代码示例： 12345678910const square = (x) =&gt; { return x * x }const callFunction100Times = (func) =&gt; { for(let i = 100; i &lt; 100; i++) { // func 参数会被调用100次 func(2) }}callFunction100Times(square) 上述代码会被 V8 引擎进行如下优化： 12345678910const square = (x) =&gt; { return x * x }const callFunction100Times = (func) =&gt; { for(let i = 100; i &lt; 100; i++) { // 函数被内联后就不会被持续调用了 return x * x }}callFunction100Times(square) 从上面可以看出，V8 实际上会把 square 函数体内联，以消除调用函数的步骤。这对提高代码的性能是很有用处的。 内联函数问题上述方法存在一点问题，让我们看看下面这段代码： 123456789101112const square = (x) =&gt; { return x * x }const cube = (x) =&gt; { return x * x * x }const callFunction100Times = (func) =&gt; { for(let i = 100; i &lt; 100; i++) { // 函数被内联后就不会被持续调用了 func(2) }}callFunction100Times(square)callFunction100Times(cube) 上面的代码中先会调用 square 函数100次，紧接着又会调用 cube 函数100次。在调用 cube 之前，我们必须先对 callFunction100Times 进行反优化，因为我们已经内联了 square 函数。在这个例子中，square 函数似乎会比 cube 函数快，但实际上，因为反优化的这个步骤，使得整个执行过程变得更长了。 对象谈到对象，V8 引擎底层有个类型系统可以区分它们： 单态对象具有相同的键，这些键没有区别。 123// 单态示例const person = { name: &apos;John&apos; }const person2 = { name: &apos;Paul&apos; } 多态对象有相似的结构，并存在一些细微的差别。 123// 多态示例const person = { name: &apos;John&apos; }const person2 = { name: &apos;Paul&apos;, age: 27 } 复杂态这两个对象完全不同，不能比较。 123// 复杂态示例const person = { name: &apos;John&apos; }const building = { rooms: [&apos;cafe&apos;, &apos;meeting room A&apos;, &apos;meeting room B&apos;], doors: 27 } 现在我们了解了 V8 里的不同对象，接下来看看 V8 引擎是如何优化对象的。 隐藏类隐藏类是 V8 区分对象的方式。 让我们将这个过程分解一下。 首先声明一个对象： 1const obj = { name: &apos;John&apos;} V8 会为这个对象声明一个 classId。 1const objClassId = [&apos;name&apos;, 1] 然后对象会按如下方式被创建： 1const obj = {...objClassId, &apos;John&apos;} 然后当我们获取对象里的 name 属性时： 1obj.name V8 会做如下查找： 1obj[getProp(obj[0], name)] 这就是 V8 创建对象的过程，接下来看看如何优化对象以及重用 classId。 创建对象的建议应该尽量将属性放在构造器中声明，以保证对象的结构不变，从而让 V8 可以优化对象。 123456789class Point { constructor(x,y) { this.x = x this.y = y }}const p1 = new Point(11, 22) // 隐藏的 classId 被创建const p2 = new Point(33, 44) 应该保证属性的顺序不变，如下面这个示例： 123456789101112const obj = { a: 1 } // 隐藏的 classId 被创建obj.b = 3const obj2 = { b: 3 } // 另一个隐藏的 classId 被创建obj2.a = 1// 这样会更好const obj = { a: 1 } // 隐藏的 classId 被创建obj.b = 3const obj2 = { a: 1 } // 隐藏类被复用obj2.b = 3 其它的优化建议接下来我们看一下其它的 JavaScript 代码优化建议。 修正函数参数类型当参数被传进函数中时，保证参数的类型一致是很重要的。如果参数的类型不同，Turbofan 在尝试优化4次之后就会放弃。 下面是一个例子： 123456789function add(x,y) { return x + y}add(1,2) // 单态add(&apos;a&apos;, &apos;b&apos;) // 多态add(true, false)add({},{})add([],[]) // 复杂态 - 在这个阶段, 已经尝试了4+次, 不会再做优化了 另一个建议是保证在全局作用域下声明类： 1234567891011121314151617// 不要这样做function createPoint(x, y) { class Point { constructor(x,y) { this.x = x this.y = y } } // 每次都会重新创建一个 point 对象 return new Point(x,y)}function length(point) { //...} 结论希望大家学到了一些 V8 底层的知识，知道如何去编写更优的 JavaScript 代码。","link":"/2019/10/23/V8-引擎和Javascript优化建议/"},{"title":"手把手教你写一个AST解析器","text":"作者：深山蚂蚁 AST 解析器工作中经常用到，Vue.js中的VNode就是如此！其实如果有需要将 非结构化数据转 换成 结构化对象用 来分析、处理、渲染的场景，我们都可以用此思想做转换。 如何解析成 AST ？我们知道 HTML 源码只是一个文本数据，尽管它里面包含复杂的含义和嵌套节点逻辑，但是对于浏览器，Babel 或者 Vue 来说，输入的就是一个长字符串，显然，纯粹的一个字符串是表示不出来啥含义，那么就需要转换成结构化的数据，能够清晰的表达每一节点是干嘛的。字符串的处理，自然而然就是强大的正则表达式了。 本文阐述 AST 解析器的实现方法和主要细节，简单易懂~，总共解析器代码不过百行！ 目标本次目标，一步一步将如下 HTML 结构文档转换成 AST 抽象语法树 123&lt;div class=\"classAttr\" data-type=\"dataType\" data-id=\"dataId\" style=\"color:red\"&gt;我是外层div &lt;span&gt;我是内层span&lt;/span&gt;&lt;/div&gt; 结构比较简单，外层一个div,内层嵌套一个span，外层有class,data，stye等属性。麻雀虽小，五脏俱全，基本包含我们经常用到的了。其中转换后的 AST 结构 有哪些属性，需要怎样的形式显示，都可以根据需要自己定义即可。本次转换后的结构： 1234567891011121314151617181920212223242526272829{ \"node\": \"root\", \"child\": [{ \"node\": \"element\", \"tag\": \"div\", \"class\": \"classAttr\", \"dataset\": { \"type\": \"dataType\", \"id\": \"dataId\" }, \"attrs\": [{ \"name\": \"style\", \"value\": \"color:red\" }], \"child\": [{ \"node\": \"text\", \"text\": \"我是外层div\" }, { \"node\": \"element\", \"tag\": \"span\", \"dataset\": {}, \"attrs\": [], \"child\": [{ \"node\": \"text\", \"text\": \"我是内层span\" }] }] }]} 不难发现，外层是根节点，然后内层用child一层一层标记子节点，有 attr 标记节点的属性，classStr 来标记 class 属性，data来标记 data- 属性，type 来标记节点类型，比如自定义的 data-type=”title” 等。 回顾正则表达式先来看几组简单的正则表达式： ^ 匹配一个输入或一行的开头，/^a/匹配”ab”，而不匹配”ba” $ 匹配一个输入或一行的结尾，/a$/匹配”ba”，而不匹配”ab” 匹配前面元字符0次或多次，/ab*/将匹配a,ab,abb,abbb 匹配前面元字符1次或多次，/ab+/将匹配ab,abb,但是不匹配a [ab] 字符集匹配，匹配这个集合中的任一一个字符(或元字符)，/[ab]/将匹配a,b,ab \\w 组成单词匹配，匹配字母，数字，下划线，等于[a-zA-Z0-9] 匹配标签元素首先我们将如下的 HTML 字符串用正则表达式表示出来： 1&lt;div&gt;我是一个div&lt;/div&gt; 这个字符串用正则描述大致如下： 以 &lt; 开头 跟着 div 字符，然后接着 &gt; ，然后是中文 “我是一个 div”，再跟着 &lt;/ ，然后继续是元素 div 最后已 &gt; 结尾。 div 是HTML的标签，我们知道HTML标签是已字母和下划线开头，包含字母、数字、下滑线、中划线、点号组成的，对应正则如下： 1const ncname = '[a-zA-Z_][\\w-.]*' 于是组合的正则表达式如下： 1`&lt;${ncname}&gt;` 根据上面分析，很容易得出正则表达式为下： 1`&lt;${ncname}&gt;&lt;/${ncname}&gt;` 我是一个div 标签内可以是任意字符，那么任意字符如何描述呢？\\s 匹配一个空白字符\\S 匹配一个非空白字符\\w 是字母数字数字下划线\\W 是非\\w的同理还有\\d和\\D等。我们通常采用\\s和\\S来描述任何字符（1、通用，2、规则简单，利于正则匹配）： 1`&lt;${ncname}&gt;[\\s\\S]*&lt;/${ncname}&gt;` 匹配标签属性HTML标签上的属性名称有哪些呢，常见的有class,id,style,data-属性，当然也可以用户随便定义。但是属性名称我们也需要遵循原则，通常是用字母、下划线、冒号开头(Vue的绑定属性用:开头，通常我们不会这么定义)的，然后包含字母数字下划线中划线冒号和点的，正则描述如下： 1const attrKey = /[a-zA-Z_:][-a-zA-Z0-9_:.]*/ HTML的属性的写法目前有以下几种： class=”title” class=’title’ class=title 1const attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)=(\"([^\"]*)\"|'([^']*)'|([^\\s\"'=&lt;&gt;`]+)/ attrKey 跟着 = ，然后跟着三种情况: ” 开头 跟着多个不是 “ 的字符，然后跟着 ” 结尾 ‘ 开头 跟着多个不是 ‘ 的字符，然后跟着 ‘ 结尾 不是（空格，”，’,=,&lt;,&gt;）的多个字符 我们测试一下attr的正则 1234567\"class=abc\".match(attr);// output(6) [\"class=abc\", \"class\", \"abc\", undefined, undefined, \"abc\", index: 0, input: \"class=abc\", groups: undefined]\"class='abc'\".match(attr);// output(6) [\"class='abc'\", \"class\", \"'abc'\", undefined, \"abc\", undefined, index: 0, input: \"class='abc'\", groups: undefined] 我们发现，第二个带单引号的，匹配的结果是”‘abc’”，多了一个单引号‘，因此我们需要用到正则里面的非匹配获取（?:）了。例子： 1\"abcde\".match(/a(?:b)c(.*)/); 输出 [\"abcde\", \"de\", index: 0, input: \"abcde\"] 这里匹配到了b，但是在output的结果里面并没有b字符。场景：正则需要匹配到存在b，但是输出结果中不需要有该匹配的字符。于是我么增加空格和非匹配获取的属性匹配表达式如下： 1const attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"'=&lt;&gt;`]+))/ = 两边可以增加零或多个空格，= 号右边的匹配括号使用非匹配获取，那么类似 = 号右侧的最外层大括号的获取匹配失效，而内层的括号获取匹配的是在双引号和单引号里面。效果如下： 从图中我们清晰看到，匹配的结果的数组的第二位是属性名称，第三位如果有值就是双引号的，第四位如果有值就是单引号的，第五位如果有值就是没有引号的。 匹配节点有了上面的标签匹配和属性匹配之后，那么将两者合起来就是如下： 1/&lt;[a-zA-Z_][\\w\\-\\.]*(?:\\s+([a-zA-Z_:][-a-zA-Z0-9_:.]*)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"'=&lt;&gt;`]+)))*&gt;[\\s\\S]*&lt;\\/[a-zA-Z_][\\w\\-\\.]*&gt;/ 上述正则完整描述了一个节点，理解了签名的描述，现在看起来是不是很简答啦~ AST 解析实战有了前面的HTML节点的正则表达式的基础，我们现在开始解析上面的节点元素。显然，HTML 节点拥有复杂的多层次的嵌套，我们无法用一个正则表达式就把 HTML 的结构都一次性的表述出来，因此我们需要一段一段处理。我们将字符串分段处理，总共分成三段： 标签的起始 标签内的内容 标签的结束 于是将上述正则拆分： 123456789const DOM = /&lt;[a-zA-Z_][\\w\\-\\.]*(?:\\s+([a-zA-Z_:][-a-zA-Z0-9_:.]*)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"'=&lt;&gt;`]+)))*&gt;[\\s\\S]*&lt;\\/[a-zA-Z_][\\w\\-\\.]*&gt;/;// 增加()分组输出const startTag = /&lt;([a-zA-Z_][\\w\\-\\.]*)((?:\\s+([a-zA-Z_:][-a-zA-Z0-9_:.]*)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"'=&lt;&gt;`]+)))*)\\s*(\\/?)&gt;/;const endTag = /&lt;\\/([a-zA-Z_][\\w\\-\\.]*)&gt;/;const attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"'=&lt;&gt;`]+))/g// 其他的就是标签里面的内容了 不难发现，标签已 &lt; 开头，为标签起始标识位置，已 &lt;/ 开头的为标签结束标识位置。我们将 HTML 拼接成字符串形式，就是如下了。 1let html = '&lt;div class=\"classAttr\" data-type=\"dataType\" data-id=\"dataId\" style=\"color:red\"&gt;我是外层div&lt;span&gt;我是内层span&lt;/span&gt;&lt;/div&gt;'; 我们开始一段一段处理上面的 html 字符串吧~ 123456789101112const bufArray = [];const results = { node: 'root', child: [],};let chars;let match;while (html&amp;&amp;last!=html){ last = html; chars = true;// 是不是文本内容 // do something parse html} bufArray: 用了存储未匹配完成的起始标签results: 定义一个开始的 AST 的节点。我们再循环处理HTML的时候，如果已经处理的字符，则将其删除，这里判断 last!=html 如果处理一轮之后，html 还是等于 last，说明没有需要处理的了，结束循环。 首先判断是否是 &lt;/ 开头，如果是则说明是标签结尾标识 12345678if(html.indexOf(\"&lt;/\")==0){ match = html.match(endTag); if(match){ chars = false; html = html.substring(match[0].length); match[0].replace(endTag, parseEndTag); }} 已 &lt;/ 开头，且能匹配上实时截止标签的正则，则该 html 字符串内容要向后移动匹配到的长度，继续匹配剩下的。这里使用了 replace 方法，parseEndTag 的参数就是”()”匹配的输出结果了，已经匹配到的字符再 parseEndTag 处理标签。 如果不是已 &lt;/ 开头的，则判断是否是 &lt; 开头的，如果是说明是标签起始标识，同理，需要 substring 来剔除已经处理过的字符。 12345678else if(html.indexOf(\"&lt;\")==0){ match = html.match(startTag); if(match){ chars = false; html = html.substring(match[0].length); match[0].replace(startTag, parseStartTag); }} 如果既不是起始标签，也不是截止标签，或者是不符合起始和截止标签的正则，我们统一当文本内容处理。 12345678910111213141516if(chars){ let index = html.indexOf('&lt;'); let text; if(index &lt; 0){ text = html; html = ''; }else{ text = html.substring(0,index); html = html.substring(index);; } const node = { node: 'text', text, }; pushChild(node);} 如果是文本节点，我们则加入文本节点到目标 AST 上，我们着手 pushChild 方法，bufArray 是匹配起始和截止标签的临时数组，存放还没有找到截止标签的起始标签内容。 1234567891011function pushChild (node) { if (bufArray.length === 0) { results.child.push(node); } else { const parent = bufArray[bufArray.length - 1]; if (typeof parent.child == 'undefined') { parent.child = []; } parent.child.push(node); }} 如果没有 bufArray ，说明当前Node是一个新Node，不是上一个节点的嵌套子节点，则新push一个节点；否则 取最后一个bufArray的值，也就是最近的一个未匹配标签起始节点，将当前节点当做为最近节点的子节点。 1&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; 显然，第一个 &lt;/div&gt; 截止节点，匹配这里的第二个起始节点 ，即最后一个未匹配的节点。 在每一轮循环中，如果是符合预期，HTML字符串会越来越少，直到被处理完成。 接下来我们来处理 parseStartTag 方法，也是稍微复杂一点的方法。 123456789101112131415161718192021222324252627282930313233343536function parseStartTag (tag, tagName, rest) { tagName = tagName.toLowerCase(); const ds = {}; const attrs = []; let unary = !!arguments[7]; const node = { node: 'element', tag:tagName }; rest.replace(attr, function (match, name) { const value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] :''; if(name&amp;&amp;name.indexOf('data-')==0){ ds[name.replace('data-',\"\")] = value; }else{ if(name=='class'){ node.class = value; }else{ attrs.push({ name, value }); } } }); node.dataset = ds; node.attrs = attrs; if (!unary){ bufArray.push(node); }else{ pushChild(node); }} 遇到起始标签，如果该起始标签不是一个结束标签(unary为true，如：,如果本身是截止标签，那么直接处理完即可)，则将起始标签入栈，等待找到下一个匹配的截止标签。起始标签除了标签名称外的属性内容，我们将 dataset 内容放在dataset字段，其他属性放在attrs 我们接下来看下处理截止标签 1234567891011function parseEndTag (tag, tagName) { let pos = 0; for (pos = bufArray.length - 1; pos &gt;= 0; pos--){ if (bufArray[pos].tag == tagName){ break; } } if (pos &gt;= 0) { pushChild(bufArray.pop()); }} 记录还未匹配到的起始标签的bufArray数组，从最后的数组位置开始查找，找到最近匹配的标签。比如： 1&lt;div class=\"One\"&gt;&lt;div class=\"Two\"&gt;&lt;/div&gt;&lt;/div&gt; class One的标签先入栈，class Two的再入栈，然后遇到第一个&lt;/div&gt;，匹配的则是class Two的起始标签，然后再匹配的是class One的起始标签。 到此，一个简单的 AST解析器已经完成了。 当然，本文是实现一个简单的 AST解析器，基本主逻辑已经包含，完整版参考如下： 完整解析参考：vue-html-parse 本文的 AST解析器的完整代码如下： easy-ast","link":"/2019/10/17/手把手教你写一个AST解析器/"},{"title":"网页设计和开发中，关于字体的常识","text":"本文作者@千古壹号。 前言我周围的码农当中，有很多是技术大神，却常常被字体这种简单的东西所困扰。 这篇文章，我们来讲一讲关于字体的常识。这些常识所涉及到的问题，有很强的可操作性，都是在实际业务中真实遇到的，都是需要开发同学和产品经理、设计师不断重复沟通的。 字体真的只是“系统默认，无从解释”这么简单吗？是产品被忽悠？还是开发在敷衍？二者之间的博弈究竟谁能胜出？学会本文，你就能胜出。 字体分类常见的字体可以分为两类：衬线体、无衬线体。 1、serif（衬线体）：在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同。 常见的衬线体有： 宋体、楷体 Times New Roman 2、sans-serif（无衬线体）：笔划粗细基本一致，只剩下主干，造型简明有力，起源也很晚。适用于标题、广告等，识别性高。 常见的无衬线体有： 黑体 Windows 平台默认的中文字体：微软雅黑（Microsoft Yahei） Windows 平台默认的英文字体：Arial Mac &amp; iOS 平台默认的中文字体：苹方（PingFang SC） Mac &amp; iOS 平台默认的英文字体：San Francisco Android 平台默认字体：Droid Sans 补充： 衬线体如今已经很少使用了，你所熟悉的“宋体”，也基本只能在纸质出版物中见到。而非衬线体更符合现代审美。 所以，在这里温馨提示各位：做PPT不要用宋体。如果你不知道用什么字体，那就用系统的默认字体就好：Win 平台用微软雅黑、Mac 平台用苹方字体。 如果你发现一名设计师，在做海报设计、或者制图的时候，使用了宋体，说明她一定是个外行。 字体族CSS 中的字体族可以理解成是某一类字体。常见的字体族可以分为五类： serif：衬线体。 sans-serif：无衬线体。 monospace：等宽字体。每一个字母所占的宽度是相同的。写代码的字体尽量用等宽字体。 cursive：手写字体。比如徐静蕾手写体。 fantasy：梦幻字体。比如一些艺术字。 这五类字体族不代表某一个具体的字体，而是当你在 CSS 中指定字体族的时候，系统就有可能在字体族中找出一种字体来显示。 参考链接：serif，sans-serif，monospace，cursive和fantasy 多字体 fallback 机制多字体 fallback 机制：当指定的字体找不到（或者某些文字不支持这个字体）时，那就接着往后找。比如： 123.div1{ font-family: \"PingFang SC\", \"Microsoft Yahei\", monospace;} 上方 CSS 代码的意思是：让指定标签元素中的文字，在 Mac &amp; iOS 平台用苹方字体，在 Win 平台用微软雅黑字体，如果这两个字体都没有，就随便找一个等宽的字体进行渲染。 注意： （1）写 CSS 代码时，字体族不需要带引号。 （2）有些 Mac 用户会安装 Office 等软件，安装这些软件后，系统会顺带安装微软雅黑字体。此时，写 CSS 代码时，如果写成 &quot;Microsoft Yahei&quot;, &quot;PingFang SC&quot;这种顺序，可能导致有些 Mac 用户用微软雅黑来显示字体。这么好看的苹方字体，你忍心割舍吗？ font-weight：字体的加粗属性font-weight 字体加粗属性，是让前端同学最迷茫的属性。当你把做好的网页拿给产品经理验收时，网页一打开，产品经理首先关注到的就是字体的加粗问题，你信不信？下面这些话都是产品经理的口头禅，想必早已让你产生了幻听： “这个字体怎么没有加粗？” “这个字体是不是太粗了点？” “为什么 iPhone 和 Android 手机上的文字粗细不一致？” 想要明白这些疑惑，我们先来看看 font-weight 有哪些属性值。 font-weight 属性：在设置字体是否加粗时，属性值既可以直接填写 100 至 900 这样的数字，也可以填写normal、bold这样的单词。normal的值相当于 400，bold的值相当于 700。如下： 123456789101112font-weight: 100;font-weight: 200;font-weight: 300;font-weight: 400;font-weight: 500;font-weight: 600;font-weight: 700;font-weight: 800;font-weight: 900;font-weight: normal; // 相当于 400font-weight: bold; // 相当于 700 关键问题来了。很多人会发现，在 Windows 平台的浏览器中， font-weight 无论是设置300、400，还是500，文字的粗细都没有任何变化，只有到600的时候才会加粗一下，感觉浏览器好像不支持这些数值，那搞这么多档位不就是多余的吗？ 这个时候，大家就开始吐槽 Windows 电脑太挫、Windows 浏览器太挫；同时还会感叹 Mac 真香，支持字体的各种粗细。 实际上，所有这些数值关键字浏览器都是支持的，之所以没有看到任何粗细的变化，是因为你所使用的字体不支持。 就拿“微软雅黑”来举例，它只支持 400 和 700 这两种粗细，所以当你在代码里写成500的时候，也会被认为是400。但是 Mac 上的“苹方”字体，就支持从100到900之间的各种粗细。 再比如，前段时间，阿里巴巴开源的普惠字体，也是支持多种粗细的： 各大平台的默认字体加粗效果一张图，胜过千言万语。解释了这么多，我们来看看各大平台的字体加粗效果是什么样的。 以下截图，都是我亲测的结果，如果你打算让别人看效果，直接把下面的图丢给他即可。像我这样贴心的前端，不多见了。 1、Mac 平台的默认字体加粗效果：（苹方字体） 2、Windows 平台的默认字体加粗效果：（微软雅黑字体） 3、iOS 平台的默认字体加粗效果：（苹方字体） 4、Android 平台（华为 P30 Pro）的默认字体加粗效果：（Droid Sans 字体） 总结：（各大平台的默认字体加粗效果） Mac &amp; iOS 平台的“苹方”字体：500 和600，加粗效果是不同的；&gt;=600的加粗效果是相同的。 Windows 平台的“微软雅黑”字体：只有 &gt;=600 才会加粗，而且加粗效果相同。 Android 平台的 Droid Sans 字体，只有 &gt;=700才会加粗；而且加粗效果相同。 大部分字体不是免费的有一点你需要知道：你所见到的大部分字体，都不是免费的。换句话说，如果你想用第三方字体从事商业活动，要先交钱，获得授权后才可以使用。你在给公司做网页的时候，就是一种商业行为。 免费字体当然有，比如思源黑体（Adobe 和 Google 在2014年7月联合推出的一款开源字体）、阿里巴巴普惠体等。但这些免费字体，我们平时基本用不到。 这也就是为什么，很多公司会专门购买一套商用字体库、甚至是自己开发一套字体出来，避免未来潜在的纠纷和麻烦。 给大家列举一个常见的场景。很多时候，前端同学拿到的视觉稿是 psd 稿，需要用 PS 软件打开源文件，才能看到里面的文字是什么字体。在 PS 软件里，当我们用光标选中字体的时候，出现了下面这种场景： 看到上面的FZLTZCHK，不要慌，马上去 Google 查一下，发现这个字体的全称是方正兰亭字体系列。恩，基本可以肯定， 这个字体也是要收费的。 这个时候，前端同学要马上告诉产品或者设计师，不要用这个字体，因为它是商用字体，是要收费的，小心吃官司。那我们该用什么字体呢？接着往下看。 网页一般用什么字体大多数情况下，网页使用系统默认的字体就足够了。如果要使用特殊字体，顶多只是让阿拉伯数字使用特殊字体。中文和英文，使用默认字体，完全足够。 如果确实要使用特殊字体，只有这几种办法： 使用开源的免费字体（比如思源黑体、阿里巴巴普惠体等）。但这类字体，种类很少，而且不是很好看。网页开发中，基本没人用。 单独购买商用字体，获得授权。 自己公司开发一套字体，给自己人用。 比如我所在的 JD 公司就自主开发了一套商用字体JDZH（只允许 JD 公司自己用，别家公司不允许用），支持三种粗细。如下： 12345678910111213141516171819202122/** * JD正黑体，提供三种字重，请严格按设计稿选择字体 */ @font-face { font-family: 'JDZH-Light'; src: url('xxx.com/data/ppms/others/JDZH_Light.ttf') format('truetype');}@font-face { font-family: 'JDZH-Regular'; src: url('xxx.com/data/ppms/others/JDZH_Regular.ttf') format('truetype');}@font-face { font-family: 'JDZH-Bold'; src: url('xxx.com/data/ppms/others/JDZH_Bold.ttf') format('truetype');}@font-face { font-family: 'JDZhengHT-EN-Bold'; src: url('xxx.com/data/ppms/others/JDZhengHei_01_Bold.ttf') format('truetype');} 为了使用这个JDZH字体， JD公司在实际开发网页时，是这样做的： 步骤1：在公共的 CSS 文件中引入上方的字体库代码。这样的话，当页面加载时，用户的终端就会去下载这个字体库。 步骤2：在业务代码中，针对目标样式，直接使用 font-family: 'JDZH-Regular';这样的代码，即可生效。 这个JDZH，我们一般也只使用在阿拉伯数字中；中文和英文，建议使用系统默认字体就行。 最后一段所谓「见微知著」，一个再不起眼的知识点，也是有很多学问的。光是“字体”这一点，就足够成为一门学科。 2005年，苹果公司创始人乔布斯（Steve Jobs）在斯坦福大学的毕业典礼演讲上，有过这样一段话： 当时的我从来没有期盼过我所学的这些东西，能够在我的生活中有什么实际的用处。 但是到了十年之后，当我们在设计第一台 Macintosh 电脑时，这些所学都涌进了我的头脑。于是，我把这些设计融入到了 Mac 电脑之中，这也使这台 Mac 成为了第一台拥有漂亮字体的电脑。 可以说，如果我当时没有退学，就不会有机会去参加我感兴趣的美术字课程，Mac 也就不会拥有那些美妙的排版和字体。而当 Windows 系统借鉴了Mac之后，似乎所有的电脑都应该是这个样子。 当时的我没有办法把这些点点滴滴连接起来，但是，当我十年后回顾的时候，一切都变得豁然开朗。 推荐阅读 常见的免费字体：http://zenozeng.github.io/Free-Chinese-Fonts/ 如何优雅的选择字体(font-family)：https://segmentfault.com/a/1190000006110417 iconfont：https://www.iconfont.cn/ 阿里巴巴官方发布免费商用字体：阿里巴巴普惠体：https://mp.weixin.qq.com/s/daKUNnF_Ste-O1l0sR89sQ 得到 | 从甲骨文至得到今楷，造字的人都是神：https://mp.weixin.qq.com/s/ZnMxrhoH9piLf9EaSIwiGA","link":"/2019/10/23/网页设计和开发中，关于字体的常识/"},{"title":"你应该知道的折叠屏收集适配","text":"作者：龙朝忠 随着三星Galaxy Fold和华为Mate X的发布，前端同学将面临一个新的任务：折叠屏的适。折叠屏虽距离普及可能还有很长一段路，大多数公司还未将折叠屏列入适配的范围，但是提前研究下折叠屏的适配还是极好的。 折叠屏手机概况华为Mate X 技术参数：（由于手机还未正式上市，这里数据可能有出入） 三星Galaxy Fold 技术参数 柔派-FlexPai 小厂手机，没啥知名都，资料较少 微软 Surfaceduo 最近新出，实际是双屏手机，暂无详细资料 从目前推出的这几款折叠手机可以看出：折叠手机从折叠到展开，屏幕的变化类似于iphone到ipad。 折叠屏适配的本质 当老板下令说：“我们的产品要适配折叠屏”，不同的人会有不同的反应： 产品和设计 如何更好的利用空间？ 如何展示才不会使页面显得空洞？ 展开和折叠时分别怎么展示？ 展开后如何过渡？ …… 开发同学 页面是否显示正常？ 是否按产品和设计的预期显示？ …… 因此对于我们开发同学来说，对折叠屏的适配首先要确定一个预期，即要先确定好交互和设计，才能评估工作。因此“折叠屏的适配先是一个设计问题，然后才是一个适配问题”。 目前情况下，产品和设计可能还不会考虑适配折叠屏的问题，那是否表示开发同学暂时无事可做呢？不尽然。 从以上折叠屏手机的情况来看，折叠屏手机的适配其实就是一个响应式设计的问题，而响应式设计有一个比较公认9条的基本原则，折叠屏手机的适配至少要满足这9项基本原则。 响应式设计9项基本原则1.响应式设计 vs 适应式设计 响应式:响应式是流布局，它会自动适应屏幕大小，不管是什么设备。尺寸按比例设置，自动随浏览器尺寸变化而变化；简单只有一套代码； 适应式：自适应则采取多个不同的布局设计，多个屏幕的尺寸，使用哪个布局取决于屏幕类型。自适应作品用屏幕尺寸来决定用哪套布局。复杂，要根据市面上设备区分； 这两种设计方式彼此相辅相成，所以说也没有对错之分。具体情况要依内容而定。 2.内容流 随着屏幕尺寸越来越小，内容所占的垂直空间也越来越多，也就是说，内容会向下方延伸，这就叫做内容流。 这点对前端指导意义是：对于内容不固定情况，高度不要固定写死，写死高度就要考虑溢出情况，文本溢出、图片按比例缩放。 3.相对单位 为了适应不同屏幕尺寸和不同使用场景，使用绝对单位容易出现问题 。常见的相对单位有em、rem、ch、ex、vw、vh、vmax、vmin。 4.断点断点可以看做是临界点，比如屏幕宽度小于这个宽度时显示一个样式，大于这个宽度时显示另一样式。常见的断点落地方案就是媒体查询，如： 1@media (min-width:800px) and (max-width:1800px) 5.最大和最小值 有时候内容占满整个屏幕宽度（例如在移动设备上）是好事，但如果相同的内容在电视屏幕上也撑得满满的，就不太合理了。因为强行铺满，根据前面的内容流原则，可能会导致页面显示异常的大。这就是为什么要有最大/最小值。例如，如果宽度为100%，最大宽度1000px，那么内容就会以不超过1000px的宽度填充屏幕。 注意：Max-width和min-widht要设置合理，不能太大也不能太小。 如京东首页和优酷首页就遵循了这个原则： 6.嵌套对象 这是一种化零为整的思想，当多个元素位置是相对的时候，对每个元素采取响应式布局处理或许比较麻烦，这时候可以将这些元素用一个元素包裹起来，这样实现会更加明了和整洁。 7.移动优先还是台式桌面优先 这表示适配的起点，是先按手机做然后适配台式机？还是先按台式机做然后适配手机？ 使用哪种根据实际情况决定，无所谓好坏，对于折叠屏适配来说肯定是手机优先。 8.web字体vs系统字体 想让自己的网站拥有炫酷的Futura或Didot效果吗？那就是用web字体吧。尽管web字体看起来很炫酷，但你要记住，这些字体都需要用户下载，字越多，用户加载页面的时间也就越长。另一方面，系统字体加载速度则快得多（前提是用户本机就有），但太过普通。 9.位图vs矢量图 你的图标是否有很多细节，并且应用了很多华丽的效果？如果是，那就用位图。如果不是，考虑使用矢量图。如果是位图，使用jpg、png或gif。矢量图则最好使用SVG或图标字体。其各有利弊。但你要时刻牢记图标尺寸——未经过优化的图片不能传到网上。另一方面，矢量图通常比较小，不过部分比较老的浏览器可能不支持矢量图。还有，如果图标有很多曲线，那有可能会比位图还大，所以要明智取舍。 折叠屏常见适配问题前面讲到折叠屏的适配，首先是一个设计问题，然后才是一个适配问题。这里我们这里讨论的是违背以上9项基本原则的情况。以下案例基于三星Galaxy Fold测试。 违背“最大值和最小值“原则 未设置合适的max-width 由于设置的max-width较小，在Galaxy Fold展开态下，页面两侧有空隙。 子元素超出max-width规定范围 违背”相对单位“原则 这里”看相似“按钮使用px设置尺寸，在一般手机上看上去正常，但是在折叠屏手机上就会显的很小。采用rem设置尺寸后就显示正常了。 对折叠屏的一些畅想 折叠的方式会越来越多，屏幕会越来越宽 如LG最新申请的一项专利显示，其可能正在研发一款三折手机，将来手机的尺寸可能会更加接近笔记本电脑显示器尺寸。或许像热门美剧《西部世界》中展示的手持折叠电脑在不远的将来就会实现。 前端交互的方式会更加丰富 如：“折”手机这个动作可以算作一个事件（需系统支持提供），如果权限设置合理，可以用来区分人机，不用再看花眼选图片了；半折”分屏，实现双屏联动。 目前来说”折“这个事件虽然没有，然是要识别用户是有有做折叠和展开动作，可以通过监听resize事件来代替。 屏幕变宽带来的新的体验 比如说，在折叠屏展开状态的模式下，你将可以一边看直播，一遍看相关产品，二者相互不影响。 图片类应用一是可以放的更大，看的细节更多，二是能实现在折叠屏展开状态下一侧看预览，一侧显示完整图片，跟方便我们浏览图片。 随着屏幕的变大，一个窗口下可能放下多个任务，同时运行多个APP。 参考： https://blog.froont.com/9-basic-principles-of-responsive-web-design/","link":"/2019/11/08/你应该知道的折叠屏收集适配/"},{"title":"碰撞检测的向量实现","text":"作者： 吴冠禧 注：1、本文只讨论2d图形碰撞检测。2、本文讨论圆形与圆形，矩形与矩形、圆形与矩形碰撞检测的向量实现 前言2D游戏中，通常使用矩形、圆形等来代替复杂图形的相交检测。因为这两种形状的碰撞检测速度是最快的。其中矩形包围盒又可以分为轴对齐包围盒（AABB, Axis Aligned Bounding Box）与转向包围盒（OBB, Oriented Bounding Box）。AABB与OBB的区别在于，AABB中的矩形的其中一条边和坐标轴平行，OBB的计算复杂度要高于AABB。根据不同的使用场景，可以用不同的方案。 如上图，明显皮卡超适合用包围盒，精灵球适合用包围球。 向量向量作为一种数学工具，在碰撞检测中发挥很大作用，后面的计算都是通过向量来完成，所以先来复习一下向量。 向量的代数表示向量的代数表示指在指定了一个坐标系之后，用一个向量在该坐标系下的坐标来表示该向量，兼具了符号的抽象性和几何形象性，因而具有最高的实用性，被广泛采用于需要定量分析的情形。 对于自由向量，将向量的起点平移到坐标原点后，向量就可以用一个坐标系下的一个点来表示，该点的坐标值即向量的终点坐标。 123456789// 二维平面向量class Vector2d{ constructor(vx=1,vy=1){ this.vx = vx; this.vy = vy; }}const vecA = new Vector2d(1,2);const vecB = new Vector2d(3,1); 向量运算加法：向量的加法满足平行四边形法则和三角形法则。具体的，两向量相加还是一个向量，分别是x与y两个分量的相加。 123456// 向量的加法运算static add(vec,vec2){ const vx = vec.vx + vec2.vx; const vy = vec.vy + vec2.vy; return new Vector2d(vx,vy);} 减法：两个向量a和b的相减得到的向量可以表示为a和b的起点重合后，从b的终点指向a的终点的向量： 123456// 向量的减法运算static sub(vec,vec2){ const vx = vec.vx - vec2.vx; const vy = vec.vy - vec2.vy; return new Vector2d(vx,vy);} 大小：向量的大小，是其各个分量的平方和开方。 1234// 获取向量长度length(){ return Math.sqrt(this.vx * this.vx + this.vy * this.vy);} 点积：从代数角度看，先对两个数字序列中的每组对应元素求积，再对所有积求和，结果即为点积。 1234// 向量的数量积static dot(vec,vec2){ return vec.vx * vec2.vx + vec.vy * vec2.vy;} 旋转：向量的旋转可以用旋转矩阵求解 12345678//向量的旋转 static rotate(vec,angle){ const cosVal = Math.cos(angle); const sinVal = Math.sin(angle); const vx = vec.vx * cosVal - vec.vy * sinVal; const vy = vec.vx * sinVal + vec.vy * cosVal; return new Vector2d(vx,vy);} 圆圆形比较简单，只要确认圆心x,y和半径r就行了,然后推导出圆心向量。 123456789class Circle{ // x,y是圆的圆心 r是半径 constructor(x=0,y=0,r=1){ this.x = x; this.y = y; this.r = r; } get P(){ return new Vector2d(this.x,this.y) } // 圆心向量} 矩形矩形就较为复杂，定义一个矩形需要中心坐标的x,y、两边长w和h，还有根据中心的旋转角度rotation 12345678910export class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; }} 两圆相交 两圆相交比较简单，只需判断两圆心之间的距离小于两圆的半径之和。 两圆心距离可以用圆心向量相减，然后求相减向量的长度。 12345678circleCircleIntersect(circle1,circle2){ const P1 = circle1.P; const P2 = circle2.P; const r1 = circle1.r; const r2 = circle2.r; const u = Vector2d.sub(P1,P2); return u.length() &lt;= r1 + r2 ;} 圆和矩形相交涉及到矩形的相交问题都先要判断是否轴对称。 矩形轴对称 先看轴对称的情况，下面是来自知乎问题怎样判断平面上一个矩形和一个圆形是否有重叠？「Milo Yip」的回答搬运： 设c为矩形中心，h为矩形半長，p为圆心，r为半径。 方法是计算圆心与矩形的最短距离 u，若 u 的长度小于 r 则两者相交。 首先利用绝对值把 p - c 转移到第一象限，下图显示不同象限的圆心也能映射至第一象限，这不影响相交测试的结果： 然后，把 v 减去 h，负数的分量设置为0，就得到圆心与矩形最短距离的矢量 u。下图展示了4种情况，红色的u是结果。 最后要比较 u 和 r 的长度，若距离少于 r，则两者相交。可以只求 u 的长度平方是否小于 r 的平方。 下面我用js实现一下： 其中矩形的四个顶点命名为A1，A2，A3，A4，矩形在第一象限的半長h等于CA3 1234567891011121314151617181920212223class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量}rectCircleIntersect(rect,circle){ const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = circle.P; const h = Vector2d.sub(A3,C); // 矩形半长 const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 矩形非轴对称 这个问题其实也很好解决，将矩形中心视为旋转中心，将矩形和圆形一起反向旋转将矩形转为轴对称，然后就可以套用上面的解法。 矩形中心到圆心向量为是CP 反向旋转θ度得向量CP’ 然后根据向量得三角形定律得OP’ = OC + CP’ 后面就代入矩形是轴对称的公式进行计算 12345678910111213141516171819202122232425262728293031323334353637class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}p(rect,circle){ const rotation = rect.rotation; const C = rect.C; let P; if (rotation % 360 === 0) { P = circle.P; // 轴对称直接输出P } else { P = Vector2d.add(C,Vector2d.rotate(Vector2d.sub(circle.P,C),rect._rotation*-1)); // 非轴对称，计算P‘ } return P;}rectCircleIntersect(rect,circle){ const rotation = rect.rotation; const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = p(rect,circle); const h = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 查看Demo1 https://rococolate.github.io/blog/gom/test1.html 两矩形相交两矩形都轴对称AABB 想象一下两个矩形A和B，B贴着A的边走了一圈，B的矩形中心的轨迹是一个新的矩形，这样就简化成新矩形与B中心点这一点的相交问题，又因为点可以看成是半径为0的圆，所以问题又转换为圆形和矩形相交。 1234567891011121314151617181920212223242526class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}AABBrectRectIntersect(rect1,rect2){ const P = rect2.C; const w2 = rect2.w; const h2 = rect2.h; const {w,h,x,y} = rect1; const C = rect1.C; const A3 = new Vector2d(x+w/2+w2/2,y+h/2+h2/2); // 新矩形的半长 const H = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - H.vx,0),Math.max(v.vy - H.vy,0)); return u.lengthSquared() === 0; // 点可以看成是半径为0的圆} 两矩形相交非轴对称OBB 两个矩形的OBB检测使用分离轴定理（Separating Axis Theorem） 分离轴定理：通过判断任意两个矩形 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 因为矩形的对边平行，所以只要判断四条对称轴上的投影即可。 如何投影？这里补充一下向量点积的几何意义。 在欧几里得空间中，点积可以直观地定义为 A·B = |A||B|cosθ ,其中|A|cosθ是A到B的投影，如果B是单位向量，那么A·B就是A到单位向量B的投影 回到矩形，将矩形4个顶点都投影到对称轴上，我们分别将其点乘即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } get _A1(){ return new Vector2d(this.x-this.w/2,this.y-this.h/2); } // 4角顶点 get _A2(){ return new Vector2d(this.x+this.w/2,this.y-this.h/2); } get _A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } get _A4(){ return new Vector2d(this.x-this.w/2,this.y+this.h/2); } get _axisX(){ return new Vector2d(1,0); } // 未旋转时的对称轴X get _axisY(){ return new Vector2d(0,1); } // 未旋转时的对称轴Y get _CA1(){ return Vector2d.sub(this._A1,this.C); } get _CA2(){ return Vector2d.sub(this._A2,this.C); } get _CA3(){ return Vector2d.sub(this._A3,this.C); } get _CA4(){ return Vector2d.sub(this._A4,this.C); } get _rotation(){ return this.rotation / 180 * Math.PI; } get A1(){ return this.rotation % 360 === 0 ? this._A1 : Vector2d.add(this.C,Vector2d.rotate(this._CA1,this._rotation)); } // 计算上旋转后4角顶点 get A2(){ return this.rotation % 360 === 0 ? this._A2 : Vector2d.add(this.C,Vector2d.rotate(this._CA2,this._rotation)); } get A3(){ return this.rotation % 360 === 0 ? this._A3 : Vector2d.add(this.C,Vector2d.rotate(this._CA3,this._rotation)); } get A4(){ return this.rotation % 360 === 0 ? this._A4 : Vector2d.add(this.C,Vector2d.rotate(this._CA4,this._rotation)); } get axisX(){ return this.rotation % 360 === 0 ? this._axisX : Vector2d.rotate(this._axisX,this._rotation); } // 计算上旋转后的对称轴X get axisY(){ return this.rotation % 360 === 0 ? this._axisY : Vector2d.rotate(this._axisY,this._rotation); } // 计算上旋转后的对称轴Y get _vertexs(){ return [this._A1,this._A2,this._A3,this._A4]; } get vertexs(){ return [this.A1,this.A2,this.A3,this.A4]; } // 4角顶点数组}OBBrectRectIntersect(rect1,rect2){ const rect1AxisX = rect1.axisX; const rect1AxisY = rect1.axisY; const rect2AxisX = rect2.axisX; const rect2AxisY = rect2.axisY; if (!cross(rect1,rect2,rect1AxisX)) return false; // 一旦有不相交的轴就可以return false if (!cross(rect1,rect2,rect1AxisY)) return false; if (!cross(rect1,rect2,rect2AxisX)) return false; if (!cross(rect1,rect2,rect2AxisY)) return false; return true; // 4轴投影都相交 return true}cross(rect1,rect2,axis){ const vertexs1ScalarProjection = rect1.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形1的4个顶点投影并排序 const vertexs2ScalarProjection = rect2.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形2的4个顶点投影并排序 const rect1Min = vertexs1ScalarProjection[0]; // 矩形1最小长度 const rect1Max = vertexs1ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形1最大长度 const rect2Min = vertexs2ScalarProjection[0]; // 矩形2最小长度 const rect2Max = vertexs2ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形2最大长度 return rect1Max &gt;= rect2Min &amp;&amp; rect2Max &gt;= rect1Min; // 相交判断 } 最后放上一个相交的应用Demo https://rococolate.github.io/blog/gom/test2.html,Demo里的形状都可以拖拽，当碰到其他形状时会变透明。 参考文章第十五章：碰撞检测 http://blog.jmecn.net/chapter-15-collision-detection/ 方块的战争：浅谈格斗游戏的精髓 http://daily.zhihu.com/story/4761397 怎样判断平面上一个矩形和一个圆形是否有重叠？ https://www.zhihu.com/question/24251545 “等一下，我碰！”——常见的2D碰撞检测 https://aotu.io/notes/2017/02/16/2d-collision-detection/index.html 码农干货系列【1】–方向包围盒(OBB)碰撞检测 https://www.cnblogs.com/iamzhanglei/archive/2012/06/07/2539751.html Rotation matrix https://en.wikipedia.org/wiki/Rotation_matrix 数量积 https://zh.wikipedia.org/wiki/%E7%82%B9%E7%A7%AF 向量 https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F","link":"/2019/06/27/collision-detection/"},{"title":"你还在用图片做引导蒙层？","text":"作者：深山蚂蚁 引导蒙层通常在新业务上线、或者业务有变更时的给新用户的一个操作指引。下图页面即是一个蒙层，会在某个局部位置高亮我们需要重点突出的内容： 当前发现很多页面做蒙层引导，还是使用图片形式来做。 图片引导蒙层有几大缺点： 图片大，影响加载 图片的内容都是假的，和真实的底部内容没对上 全屏蒙层图片，图片的宽高和屏幕宽高不一致，显示两边留黑，或者有压缩的效果。 图片的引导位置不能点击。 low ？ not cool ？ 本文讲述六种思路来实现引导蒙层 z-index实现蒙层 动态opacity实现 border实现 box-shadow实现 节点复制实现 canvas实现 以上六种引导蒙层实现思路，在一定情况下都能满足业务需求，从不同角度来实现了引导蒙层。z-index最简单，canvas最灵活，就个人而言，更加喜欢骨架屏式的动态opacity蒙层实现，更有趣更酷!!! 思路一：使用z-index 新增一个div，设置为半透明区域，大小覆盖整个页面 半透明蒙层区域z-index大于页面元素 引导内容区域大于半透明蒙层区域z-index 这个好理解，页面元素都是有层级的，我们只需要把引导内容区域设置为最顶层的层级，在引导内容区域之下设置一个遮罩层，其他内容元素的z-index都地域这个遮罩层即可。 我们来看一个简单例子。 123456789101112131415161718192021222324252627.z1{ position:absolute; left:50px; top:50px; width:50px; height:50px; background:blue; z-index:1;}.z2{ position:absolute; left:60px; top:60px; width:50px; height:50px; background:red; z-index:2;}.z3{ position:absolute; left:70px; top:70px; width:50px; height:50px; background:yellow; z-index:3;} 我们修改一下z2的样式。 12345678910111213141516171819202122232425.z2{ position:absolute; left:50px; top:50px; width:50px; height:50px; background:black; opacity:0.5; z-index:2; animation:z_index 2s linear infinite alternate;}@keyframes z_index { from { left:50px; top:50px; width:50px; height:50px; } to { left:0px; top:0px; width:200px; height:200px; } } 只要在布局页面元素的时候，把需要做蒙层的元素确定好，配合js，动态的设置元素的z-index + opacity，就可以很好的做到页面的引导蒙层效果。 思路二：使用opacity将非蒙层元素半透明 引导内容区域无需改动 页面其他节点元素半透明 我们不再新增蒙层，而是完全操作页面节点，将需要遮罩的节点都设置为半透明，引导蒙层显现内容则完全显示出来。页面的效果和蒙层不太一样，对于空白地方，我们仍然是完全显示，只是将有内容的元素给半透明，类似骨架屏的效果。为了演示效果，我们看如下例子：页面设置6个元素。 12345678&lt;div class=\"wrap\"&gt; &lt;div class=\"z z1\"&gt;&lt;/div&gt; &lt;div class=\"z z2\"&gt;&lt;/div&gt; &lt;div class=\"z z3\"&gt;&lt;/div&gt; &lt;div class=\"z z4\"&gt;&lt;/div&gt; &lt;div class=\"z z5\"&gt;&lt;/div&gt; &lt;div class=\"z z6\"&gt;&lt;/div&gt; &lt;/div&gt; 将元素内容用flex并排布局。 12345678910111213141516171819202122232425262728.wrap{ display:flex; flex-wrap:wrap; width:150px;}.z{ width:50px; height:50px; transition:all 1s;}.z1{ background:blue;}.z2{ background:black;}.z3{ background:yellow;}.z4{ background:red;}.z5{ background:green;}.z6{ background:orange;} 使用js操作，依次半透明其他元素，显示当前元素来模拟蒙层。 1234567891011121314151617let arry = Array.from(document.querySelectorAll(\".z\"));let index = -1;let direct = 1;setInterval(()=&gt;{ if(index&gt;=5) direct = -1; else if(index&lt;=0) direct = 1; index = index+direct; arry.forEach((d,i)=&gt;{ d.style.opacity = 1; }); setTimeout(()=&gt;{ arry.forEach((d,i)=&gt;{ if(i==index) return; d.style.opacity = 0.1; }); },1000);},2000) 看了这个例子，我们清晰的看到这个引导蒙层的实现过程。这种引导蒙层其实更好玩有趣，有点类似当前流行的骨架屏，其他已有元素需要遮罩的内容就是骨架屏的灰色部分，需要显现的就是重点的蒙层内容。有趣！！！ 思路三：使用border的方式来实现没错，就是普遍不能在普遍的border了，且看如下： 123div { border:1px solid #red;} 那用border怎么实现引导蒙层呢？ 1、先了解下三角形先看一个简单的例子： 1&lt;div class=\"border_1\"&gt;&lt;/div&gt; 123456789.border_1{ width: 100px; height: 100px; border-top:50px solid red; border-right: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid transparent; box-sizing:border-box;} 实现了一个倒三角,这个应用场景是不是就比较多了，很多tips的指引，标注等都会用到。我就看到过这种倒三角使用一张图片代替的做法。仔细看这段代码，主要有实现了三点： 四边都设置了边框 宽高都为100px,即上下、左右表框之和，其实小于等于这个值都行。 只有顶部边框是红色，其他边框是透明的。 为了理解上面的实现，我们来看下如下代码： 123456789101112131415161718.border_2{ width: 100px; height: 100px; background-color:green; border-style:solid; border-color:red yellow blue black; border-width:50px; animation:border_ani 2s linear infinite alternate; box-sizing:border-box;}@keyframes border_ani { from { border-width:50px; } to { border-width:0; } } 从图中我们可以清晰的看到，随着border-width的变化，整个div的绿色背景在跟随变化。 当border-width=0的时候，整个页面只有绿色背景，即都是内容的大小 当border-width=50的时候，整个div的大小都被border给充满了，上下左右均分1/4，就是四个倒三角。 这样我们就清晰的能得到: 当border-right,border-left,border-bottom都transparent透明，border-top是红色的时候，所看到的就是一个倒三角。 同理我们还可以设置边框的大小不一致，可以实现斜三角： 123456789.border_3{ width: 0; height: 0; border-top:30px solid red; border-right: 10px solid transparent; border-bottom: 20px solid transparent; border-left: 100px solid transparent; box-sizing:border-box;} 还可以实现工作中经常碰到的梯形： 123456789.border_4{ width: 150px; height: 150px; border-top:50px solid red; border-right: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid transparent; box-sizing:border-box;} 好了，这里不累赘了，感兴趣的可以各种尝试。遇到这种简单边线图，就不要动不动使用图片了。 2、再看实现引导蒙层 新增一个div，作为蒙层元素 div中间大小和引导内容元素大小完全一致，且位置恰好重叠 div的border设置为半透明且无限放大 了解了上面的三角形的实现之后，估计你也能想出怎么做引导蒙层了。一个div有四个边框，如果我们把边框都设置成半透明，然后中间的区域（上面border_2的green）设置成全透明会不就可以实现区域引导蒙层了吗？然后再把边框设置成超过屏幕的大小呢，就是全景引导蒙层了！ 123456789.border_5{ width: 150px; height: 150px; border-top:50px solid rgba(0,0,0,.5); border-right: 50px solid rgba(0,0,0,.5); border-bottom: 50px solid rgba(0,0,0,.5); border-left: 50px solid rgba(0,0,0,.5); box-sizing:border-box;} 这是一个150px的区域蒙层，我们看下如下示例就能很明白了： 1234567891011121314151617.border_6{ width: 20px; height: 20px; border-style:solid; border-color:rgba(0,0,0,.5); border-width:20px; animation:border_ani 2s linear infinite alternate; box-sizing:content-box;}@keyframes border_ani { from { border-width:20px; } to { border-width:100px; } } 当然，我们还可以设置border-radius来实现圆形的蒙层区域，如下： 当然，这里的边框大小值都是写死的，具体实现需要根据页面内容修改或者动态修改即可。 如果是椭圆呢？ 总结： border可以实现各种边线的形状，可以实现引导蒙层，页面指定区域透明，之外的都半透明来实现即可。 思路四、使用box-shadow来实现 新增一个div，作为蒙层元素 div大小和内容元素大小完全一致，且位置恰好重叠 div的box-shadow的阴影尺寸设置为半透明且设置为比较大的约2000px大小 box-shadow，大伙都不陌生，就是盒子的阴影，我们先来了解下它的基本用法： 123456.boxshadow_1{ width:50px; height:50px; background:blue; box-shadow: 10px 10px 5px 4px #000;} 在宽高为50px的div,它的阴影水平和垂直都是10px，阴影模糊距离是5px,阴影的尺寸是4px,阴影是#000的颜色(这里给body增加了一个yellow的背景色以便于区分)。 首先我们把阴影透明： 123456.boxshadow_2{ width:50px; height:50px; background:blue; box-shadow: 10px 10px 5px 4px rgba(0,0,0,.5);} 那怎么让阴影遮盖整个页面呢？ 阴影的水平和垂直距离是指距离原dev的距离，这个调整达不到效果，只会让阴影更多的偏离元素。 阴影的模糊距离指阴影的边缘渐变模糊的距离，距离越长，只会让渐变模糊加长，蒙层大小不会变。 阴影的尺寸，这个是指多大的阴影，那我们将阴影尺寸设置很大呢？是的，就是这个了 看如下的例子，我们调整阴影的尺寸： 123456789101112131415.boxshadow_3 { width:50px; height:50px; background:blue; box-shadow: 0px 0px 5px 0px rgba(0,0,0,.5); animation:box_ani 2s linear infinite alternate;}@keyframes box_ani { from { box-shadow: 10px 10px 5px 0px rgba(0,0,0,.5); } to { box-shadow: 10px 10px 5px 100px rgba(0,0,0,.5); } } 如上，我们只需要把阴影尺寸加大就可以实现引导蒙层了。如果需要引导蒙层状态下还能响应事件呢？只需要加一个pointer-events属性即可。 box-shadow的阴影距离切勿盲目设置过大，经过测试这个值如果过大，比如4000px，在部分手机上阴影无法显示出来。经过实践，设置为2000px为佳。 思路五：使用页面节点复制 新增两个div，一个半透明蒙层元素和一个蒙层内容区域 将页面节点引导内容拷贝到蒙层内容区域 将蒙层内容区域的大小和位置与原节点引导内容完全重合 页面内容已经做好了，我们需要引导蒙层来显示某个元素，那么将元素复制到最外层，顶层增加一层蒙层来实现,需要突出的引导内容在蒙层之上即可实现。 123456&lt;div class=\"content one\"&gt;我是第一个div，我是第一个div&lt;/div&gt;&lt;div class=\"content two\"&gt;我是第二个div，我是第二个div&lt;/div&gt;&lt;div class=\"content three\"&gt;我是第三个div，我是第三个div&lt;/div&gt;&lt;div class=\"content four\"&gt;我是第四个div，我是第四个div&lt;/div&gt;&lt;div class=\"mask\"&gt;&lt;/div&gt;&lt;div id=\"maskContent\"&gt;&lt;/div&gt; 这里设置了一个固定蒙层，和一个固定的蒙层内容元素，我们只需要填充即可。 12345678910111213141516171819.content{ padding:10px; z-index:0;}.mask{ position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,.8); z-index:900 } #maskContent{ position:fixed; z-index:999; display:inline-block; background-color: #fff; } 这里内容区域都是0，然后mask是900，我们的蒙层元素是999，就是最上层了。 123456789101112131415function renderContent(cls){ let targetNode = document.querySelector(`.${cls}`); let maskContent = document.getElementById(\"maskContent\"); maskContent.innerHTML = targetNode.outerHTML; let pos = targetNode.getBoundingClientRect(); maskContent.style.top=pos.top+\"px\"; maskContent.style.left=pos.left+\"px\"; maskContent.style.width=pos.width+\"px\"; maskContent.style.height=pos.height+\"px\"; }let i = 0;setInterval(()=&gt;{ renderContent(['one','two','three','four'][i]); if(++i&gt;=4) i = 0;},1000) 这里为了演示效果，增加了一个定时器改变不同的遮罩层。易于理解，看下效果： 思路六：使用canvas实现 新增一个canvas，绘制两次图形 第一次：绘制一个全屏的半透明阴影 第二次：使用xor绘制一个和引导内容区域的大小位置完全重合的区域 第二次绘制的内容区域和第一次重叠，使用xor，所以会透明，该引导内容区域就会完全显示出来，这就是我们想要的效果了。 使用canvas的globalCompositeOperation属性来实现,内容参考http://www.tutorialspoint.com/html5/canvas_composition.htm 重点看xor：Shapes are made transparent where both overlap and drawn normal everywhere else.翻译： canvas绘制的形状在重叠处都会变成透明的，非重叠处的其他任何地方都正常绘制内容。 所以我们就可以在canvas里面绘制一个canvas蒙层，然后在蒙层中需要显示的内容用xor来绘制重叠，然后重叠内容就会被透明，那么这个透明区域的内容就是我们想要的引导蒙层突出内容区域。具体看实例： 12345 &lt;div class=\"content one\"&gt;我是第一个div，我是第一个div&lt;/div&gt;&lt;div class=\"content two\"&gt;我是第二个div，我是第二个div&lt;/div&gt;&lt;div class=\"content three\"&gt;我是第三个div，我是第三个div&lt;/div&gt;&lt;div class=\"conteent four\"&gt;我是第四个div，我是第四个div&lt;/div&gt;&lt;canvas id=\"mask\"&gt;&lt;/canvas&gt; 页面增加一个canvas节点。将canvas整体设置成半透明，然后再用xor来实现内容的绘制。 12345678910111213141516171819202122232425 function mask(cls){ let targetNode = document.querySelector(`.${cls}`); let pos = targetNode.getBoundingClientRect(); let canvas = document.getElementById(\"mask\"); let width = window.innerWidth; let height = window.innerHeight;; canvas.setAttribute(\"width\", width); canvas.setAttribute(\"height\",height); var ctx = canvas.getContext(\"2d\"); ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle ='rgba(255, 255, 255, 0.9)'; ctx.fillRect(0, 0, width, height); ctx.fill(); ctx.fillStyle ='white'; ctx.globalCompositeOperation=\"xor\"; ctx.fillRect(pos.left,pos.top,pos.width,pos.height); ctx.fill(); }let array = ['one','two','three','four'];let i = 0;setInterval(()=&gt;{ mask(array[i]); i++; if(i&gt;=4) i = 0;},1000) 看完以上实现，你最喜欢哪种实现方式呢？","link":"/2019/09/20/guid-mask/"},{"title":"【译】在生产环境中使用原生JavaScript模块","text":"原文地址：https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/原文作者：PHILIP WALTON译者：龚亮 ，校对：刘辉声明：本翻译仅做学习交流使用，转载请注明来源 两年前，我写了一篇有关module/nomodule技术的文章，这项技术允许你在编写ES2015+代码时，使用打包器和转换器生成两个版本的代码库，一个具有现代语法的版本（通过&lt;script type=&quot;module&quot;&gt;加载）和一个使用ES5语法的版本（通过&lt;script nomodule&gt;加载）。该技术允许你向支持模块（译者注：指ECMA制定的标准的export/import模块语法及其加载机制，又称为ES Module、ESM、ES6 Module、ES2015 Module，下文中将出现很多”模块”一词，都是这个含义）的浏览器发送更少的代码，现在大多数Web框架和CLI都支持它。 但是那时候，尽管能够在生产中部署现代JavaScript，大多数浏览器也都支持模块，我仍然建议打包你的代码。 为什么？主要是因为我觉得在浏览器中加载模块很慢。尽管像HTTP/2这样的新协议理论上有效地支持加载大量小文件，但当时的所有性能研究都认为使用打包器更有效。 其实当时的研究是不完整的。该研究所使用的模块测试示例由部署到生产环境中未优化和未缩小的源文件组成。它并没有将优化后的模块包与优化后的原始脚本进行比较。 不过，当时并没有更好的方法来部署模块(译者注：指遵循ES2015模块规范的文件)。但是现在，打包技术取得了一些最新进展，可以将生产代码部署为ES2015模块(包含静态导入和动态导入)，从而获得比非模块(译者注：指除ES2015模块外的传统部署方式)更好的性能。实际上，这个站点(译者注：指原文章所在的网站)已经在生产环境中使用原生模块好几个月了。 对模块的误解与我交流过的很多人都认为模块（译者注：指遵循ES2015模块规范的部署方式）是大规模生产环境下应用程序的一个选择罢了。他们中的许多人引用了我刚刚提到的研究，并建议不要在生产环境中使用模块，除非: …小型web应用程序，总共只有不到100个模块，依赖树相对较浅(即最大深度小于5)。 如果你曾经查看过node_modules目录，可能知道即使是小型应用程序也很容易有超过100个模块依赖项。我们来看看npm上一些流行的工具包有多少个模块依赖项吧： 包 模块数量 date-fns 729 lodash-es 643 rxjs 226 人们对模块的主要误解是，在生产环境中使用模块时只有两个选择：(1)按原样部署所有源代码(包括node_modules目录)，(2)完全不使用模块。 如果你仔细考虑我所引用研究给出的建议，它没有说加载模块比普通加载脚本慢，也没有说你不应该使用模块。它只是说，如果你将数百个未经过压缩的模块文件部署到生产环境中，Chrome将无法像加载单个经过压缩的模块一样快速的加载它们。所以建议继续使用打包器、编译器和压缩器（译者注：原文是minifier，指去除空格注释等）。 实际情况是，你可以在生产环境中使用上面所有技术的同时，也可以使用ES2015模块！ 事实上，因为浏览器已经知道如何加载模块（对不支持模块的浏览器可以做降级处理），所以模块才是我们应该打包出的格式。如果你检查大多数流行的打包器生成的输出代码，你会发现很多样板代码（译者注：指rollup和webpack中的runtime的代码），其唯一的目的是动态加载其它代码并管理依赖，但如果我们只使用带有import和export语句的模块，则不需要这些代码！ 幸运的是，今天至少有一个流行的打包器（Rollup）支持模块作为输出格式，这意味着可以打包代码并在生产环境中部署模块（没有加载器样板代码）。由于Rollup（根据我的经验，这是最好的打包器）具有出色的tree-shaking，使得Rollup打包出的模块是目前所有打包器输出模块中代码最少的。 更新： Parcel计划在下一版本中添加模块支持。Webpack目前不支持模块输出格式，但这里有一些相关讨论＃2933，＃8895，＃8896。 另一个误解是，除非你的所有依赖项都使用模块，否则你不能使用模块。不幸的是大多数npm包仍然以CommonJS的形式发布(甚至有些包以ES2015编写，但在发布到npm之前转换为CommonJS)！ 尽管如此，Rollup有一个插件（rollup-plugin-commonjs），它可以将CommonJS源代码转换为ES2015。如果一开始你的依赖项采用ES2015模块管理肯定会更好，但是有一些依赖关系不是这样管理的并不会阻止你部署模块。 在本文的剩余部分，我将向你展示如何打包到模块（包括使用动态导入和代码拆分的粒度），解释为什么它通常比原始脚本更高效，并展示如何处理不支持模块的浏览器。 最优打包策略打包生产代码一直是需要权衡利弊。一方面，希望代码尽快加载和执行。另一方面，又不希望加载用户实际用不到的代码。 同时，还希望代码尽可能地被缓存。打包的一个大问题是，即使只是一行代码有修改也会使整个打包后的包缓存失效。如果直接使用ES2015模块部署应用程序（就像它们在源代码中一样），那么你可以自由地进行小的更改，同时让应用程序的大部分代码仍然保留在缓存中。但就像我已经指出的那样，这也意味着你的代码需要更长时间才能被新用户的浏览器加载完成。 因此，找到最优打包粒度的挑战是在加载性能和长期缓存之间取得适当的平衡。 默认情况下，大多数打包器在动态导入时进行代码拆分，但我认为仅动态导入的代码拆分粒度不够细，特别是对于拥有大量留存用户的站点（缓存很重要）。 在我看来，你应该尽可能细粒度地拆分代码，直到开始显著地影响加载性能为止。虽然我强烈建议你自己动手进行分析，但是查阅上文引用的研究可以得出一个大致的结论。当加载少于100个模块时，没有明显的性能差异。针对HTTP/2性能的研究发现，加载少于50个文件时没有明显的差异(尽管他们只测试了1、6、50和1000，所以100个文件可能就可以了)。 那么，最好的代码拆分方法是什么呢？除了通过动态导入做代码拆分外，我还建议以npm包为粒度做代码拆分，node_modules中的模块都合并到以其包名命名的文件中。 包级别的代码拆分如上所述，打包技术的一些最新进展使得高性能模块部署成为可能。我提到的增强是指Rollup的两个新功能：通过动态import()时自动代码拆分（在v1.0.0中添加）和通过manualChunks选项进行可编程的手动代码拆分（在v1.11.0中添加）。 有了这两个功能，现在很容易在包级别进行代码拆分的构建配置。 这是一个使用manualChunks选项配置的例子，每个位于node_module里的模块将被合并到以包名命名的文件里(当然，这种模块路径里肯定包含node_modules) 1234567891011121314151617181920export default { input: { main: &apos;src/main.mjs&apos;, }, output: { dir: &apos;build&apos;, format: &apos;esm&apos;, entryFileNames: &apos;[name].[hash].mjs&apos;, }, manualChunks(id) { if (id.includes(&apos;node_modules&apos;)) { // Return the directory name following the last `node_modules`. // 返回最后一个node_modules后面跟着的目录名 // Usually this is the package, but it could also be the scope. // 通常都会是一个包名，也有可能是一个私有域 const dirs = id.split(path.sep); return dirs[dirs.lastIndexOf(&apos;node_modules&apos;) + 1]; } },} manualChunks选项接收一个函数，该函数将模块文件路径作为惟一的参数，也可以返回一个文件名，参数中的模块将被加入到这个文件里。如果没有返回任何内容，参数中的模块将被添加到默认文件中。 考虑从lodash-es包中导入cloneDeep()、debounce()和find()模块的一个应用程序。上面的配置将把各个模块(以及它们导入的任何其它lodash模块)一起放入一个名为npm.lodash-es.XXXX.mjs的输出文件中，(其中XXXX是lodash-es模块文件的哈希值)。 在该文件的末尾，你会看到这样的导出语句(注意，它只包含添加到块中模块的导出语句，而不是所有lodash模块): 1export {cloneDeep, debounce, find}; 希望这个例子能清楚地说明使用Rollup手动拆分代码的工作原理。就我个人而言，我认为使用import和export语句的代码拆分比使用非标准的、特定于打包器实现的代码拆分更容易阅读和理解。 例如，跟踪这个文件中发生了什么很难(我以前使用webpack对一个项目做代码拆分后的实际输出)，而且在支持模块的浏览器中其实不需要这些代码: 12345678910111213141516171819(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[&quot;import1&quot;],{/***/ &quot;tLzr&quot;:/*!*********************************!*\\ !*** ./app/scripts/import-1.js ***! \\*********************************//*! exports provided: import1 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;import1&quot;, function() { return import1; });/* harmony import */ var _dep_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dep-1 */ &quot;6xPP&quot;);const import1 = &quot;imported: &quot; + _dep_1__WEBPACK_IMPORTED_MODULE_0__[&quot;dep1&quot;];/***/ })}]); 如果你有数百个npm依赖项怎么办？我在上面说过，我认为包级别上的代码拆分是站点代码拆分的最佳状态，而又不会太激进。 当然，如果你的应用程序从数百个不同的npm包中导入模块，那么浏览器可能无法有效地加载所有模块。 但是，如果你确实有很多npm依赖项，那么先不要完全放弃这个策略。请记住，你可能不会在每个页面上加载所有的npm依赖项，因此检查实际加载了多少依赖项非常重要。 尽管如此，确实有一些非常大的应用程序具有如此多的npm依赖关系，以至于它们不能实际地对其中的每一个应用程序进行代码拆分。如果你是这种情况，我建议你找出一种方法来将一些依赖项分组到公共文件中。一般来说，你可以将可能在同一时间发生变化的包(例如，React和react-dom)分组，因为它们必须一起失效(例如，我稍后展示的示例应用程序将所有React依赖项分组为同一个文件)。 动态导入使用原生import语句进行代码拆分和模块加载的一个缺点是，需要开发人员对不支持模块的浏览器做兼容处理。 如果你想使用动态import()懒加载代码，那么你还必须处理这样一个事实：有些浏览器支持模块，但不支持动态import()（Edge 16–18, Firefox 60–66, Safari 11, Chrome 61–63）。 幸运的是，一个很小的(~400字节)、非常高性能的polyfill可用于动态import()。 向站点添加polyfill很容易。你所要做的是导入它并在应用程序的主入口点初始化它(在调用import()之前): 12345import dynamicImportPolyfill from &apos;dynamic-import-polyfill&apos;;// This needs to be done before any dynamic imports are used. And if your// modules are hosted in a sub-directory, the path must be specified here.dynamicImportPolyfill.initialize({modulePath: &apos;/modules/&apos;}); 最后要做的是告诉Rollup将输出代码中的动态import()重命名为你指定的另一个名称(通过output.dynamicImportFunction选项配置)。动态导入polyfill默认使用名称为import，但是可以配置它。 需要重命名import()语句的原因是import是JavaScript中的一个关键字。这意味着不可能使用相同的名称来填充原生import()，因为这样做会导致语法错误。 让Rollup在构建时重命名它是很好的，这意味着你的源代码可以使用标准版本，并且在将来不再需要polyfill时，你将不必重新更改它。 高效加载JavaScript模块当你使用代码拆分的时候，最好预加载所有马上要使用的模块(即主入口模块导入图中的所有模块)。 但是，当你加载实际的JavaScript模块（通过&lt;script type=&quot;module&quot;&gt;以及随后import语句引用的模块时），你将希望使用modulepreload而不是传统的preload(仅适用于原始脚本)。 123456&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-one.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-two.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-three.XXXX.mjs&quot;&gt;&lt;!-- ... --&gt;&lt;script type=&quot;module&quot; src=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;/script&gt; 实际上，对于预加载原生的模块，modulepreload实际上比传统的preload要严格得多，它不仅下载文件，而且在主线程之外立即开始解析和编译文件。传统的预加载无法做到这一点，因为它不知道在预加载时该文件将用作模块脚本还是原始脚本。 这意味着通过modulepreload加载模块通常会更快，而且在实例化时不太可能导致主线程卡顿。 生成modulepreload列表Rollup的bundle对象中的每个入口文件在其静态依赖关系图中包含完整的导入列表，因此在Rollup的generateBundle钩子中很容易获得需要预加载哪些文件的列表。 虽然在npm上确实存在一些modulepreload插件，但是为图中的每个入口点生成一个modulepreload列表只需要几行代码，所以我更愿意像这样手动创建它: 123456789101112131415{ generateBundle(options, bundle) { // A mapping of entry chunk names to their full dependency list. const modulepreloadMap = {}; for (const [fileName, chunkInfo] of Object.entries(bundle)) { if (chunkInfo.isEntry || chunkInfo.isDynamicEntry) { modulepreloadMap[chunkInfo.name] = [fileName, ...chunkInfo.imports]; } } // Do something with the mapping... console.log(modulepreloadMap); }} 例如，这里是我如何为这个站点以及我的demo应用生成modulepreload列表的。 注意：虽然对于模块脚本来说，modulepreload绝对比原始的preload更好，但它对浏览器的支持更差(目前只支持chrome)。如果你的流量中有相当一部分是非chrome流量，那么使用classic preload是有意义的。 与使用modulepreload不同，使用preload时需要注意的一点是，预加载脚本不会放在浏览器的模块映射中，这意味着可能会不止一次地处理预加载的请求(例如，如果模块在浏览器完成预加载之前导入文件)。 为什么要部署原生模块？如果你已经在使用像webpack这样的打包器，并且已经在使用细粒度代码拆分和预加载这些文件(与我在这里描述的类似)，那么你可能想知道是否值得改变策略，使用原生模块。下面是我认为你应该考虑它的几个原因，以及为什么打包到原生模块比使用带有模块加载代码的原始脚本要好。 更小的代码总量当使用原生模块时，现代浏览器不必为用户加载任何不必要的模块加载或依赖关系管理代码。例如，如果使用原生模块，则根本不需要webpack运行时和清单。 更好的预加载正如我在前一节中提到的，使用modulepreload允许你加载代码并在主线程之外解析/编译代码。在其他条件相同的情况下，这意味着页面的交互速度更快，并且主线程在用户交互期间不太可能被阻塞。 因此，无论你如何细粒度地对应用程序进行代码拆分，使用import语句和modulepreload加载模块要比通过原始script标签和常规preload加载更有效(特别是如果这些标签是动态生成的，并在运行时添加到DOM中)。 换句话说，由Rollup打包出的20个模块文件将比由webpack打包出的20个原始脚本文件加载得更快(不是因为webpack，而是因为它不是原生模块)。 更面向未来许多最令人兴奋的新浏览器特性都是构建在模块之上的，而不是原始的脚本。这意味着，如果你想使用这些特性中的任何一个，你的代码需要作为原生模块部署，而不是转换为ES5并通过原始的script标签加载(我在尝试使用实验性KV存储API时曾提到过这个问题)。 以下是一些仅限模块才有的最令人兴奋的新功能： 内置模块 HTML模块 CSS模块 JSON模块 导入地图 workers、service workers和window之间共享模块 支持旧版浏览器在全球范围内，超过83%的浏览器原生支持JavaScript模块(包括动态导入)，因此对于你的大多数用户来说，不需要做任何处理就可以使用这项技术。 对于支持模块但不支持动态导入的浏览器，可以使用上面提到的dynamic-import-polyfill。由于polyfill非常小，并且在可用时将使用浏览器的原生动态import()，因此添加这个polyfill几乎没有大小或性能成本。 对于根本不支持模块的浏览器，可以使用我前面提到的module/nomodule技术。 一个实际的例子由于谈论跨浏览器兼容性总是比实际实现它要容易，所以我构建了一个演示应用程序，它使用了我在这里阐述的所有技术。 这个演示程序可以在不支持动态import()的浏览器中运行(如Edge 18和Firefox ESR)，也可以在不支持模块的浏览器中运行(如Internet Explorer 11)。 为了说明这个策略不仅适用于简单的用例，我还包含了当今复杂的JavaScript应用程序需要的许多特性: Babel转换（包括JSX） CommonJS的依赖关系（例如react，react-dom） CSS依赖项 Asset hashing 代码拆分 动态导入（带有polyfill降级机制） module/nomodule降级机制 代码托管在GitHub上(因此你可以派生repo并自己构建它)，而演示则托管在Glitch上，因此你可以重新组合代码并使用这些特性。 最重要的是查看示例中使用的Rollup配置，因为它定义了如何生成最终模块。 总结希望这篇文章让你相信，现在不仅可以在生产环境中部署原生JavaScript模块，而且这样做可以提高站点的加载和运行时性能。 以下是快速完成此工作所需步骤的摘要： 使用打包器，但要确保输出格式为ES2015模块 积极地进行代码拆分(如果可能的话，一直到node包) 预加载静态依赖关系图中的所有模块(通过modulepreload) 使用polyfill来支持不支持动态import()的浏览器 使用&lt;script nomodule&gt;支持根本不支持模块的浏览器 如果你已经在构建设置中使用了Rollup，我希望你尝试这里介绍的技术，并在生产环境中部署原生模块(带有代码拆分和动态导入)。如果你这样做了，请告诉我进展如何，因为我既想听你的问题，也想听你的成功故事！ 模块是JavaScript的明确未来，我希望我们所有的工具和依赖都能尽快包含模块。希望本文能在这个方向上起到一点推动作用。 译者评：1.作者上一篇文章的译文：https://jdc.jd.com/archives/49112.另外一篇讲JavaScript原生模块的文章：https://www.jianshu.com/p/9aae3884b05b","link":"/2019/09/10/【译】在生产环境中使用原生JavaScript模块/"},{"title":"TypeScript安利指南","text":"作者：李逸君 骚年，你感受过debug一年找不到问题，最后发现是变量名写错时的绝望吗？骚年，你感受过生产线上代码出现Uncaught TypeError时的恐惧吗？骚年，你感受过写代码找一万个文件还找不到方法定义时委屈吗？ 拿起键盘，让我们对谋害生命的代码拖进垃圾箱！(划掉) 前言据了解，目前有相当一部分同学不想去学习ts，毕竟没(xue)时(bu)间(dong)。很不幸两个月前我也是其中的一员。在看到尤大大都用ts写vue3了，蠢蠢欲动的我小心翼翼的踏入了这个深坑。在经历了长达一天的摸爬滚打之后，领悟到了真谛 经过了一段时间的理解之后，写了这篇文章，旨在给犹豫是否学习或者还在观望TypeScript的同学做个使用ts的收益分析，希望能够打动屏幕面前的你。 安利ts难写吗？不难。最简单的做法三步就搞定。 找一个js文件 按下重命名 把.js改成.ts 大功告成！ （打人别打脸，还要靠它吃饭的…） ⬇️ ts初体验 -ts是什么ts是js的超集，意味着js本身的语法在ts里面也能跑的通。ts一方面是对js加上了很多条条框框的限制，另一方面是拓展了js的一些能力，就像es6提供了那么多神奇的语法糖一样。只要按照一定的规则去书写js，就能享受到ts带来的好处。 当然因为现在的ts足够强大，并且有自家的vscode保驾护航，才方便了我们这些过去想都不(lan)敢(de)想的苦逼程序员。 js改造成ts的工作量很大程度取决于你想对自己的代码限制的有多细致，描述的有多完善。最简单的就像上面说的，改个拓展名就行了(当然很大程度上可能会通过不了各种静态检查)。如果你写的越多，用你代码的同志就越大可能喜欢你写的东西。 下面先简单介绍一下ts语法，便于后面的理解。 -ts语法简介1234567891011121314151617181920212223242526272829303132// 'xxx: number' 表示声明一个number类型const num: number = 123// 声明一个函数的参数类型(number以及any)和返回值(void)function fn (arg1: number, arg2: any): void { // todo}fn(num, [1,2,3,4])// 声明一个接口interface IPerson { name: string // IPerson需要包含一个name属性，类型是string age: number // IPerson需要包含一个age属性，类型是number family: Array&lt;string&gt; // IPerson需要包含一个family属性，类型是数组，数组里面都是string类型的数据 sex?: '男' | '女' // IPerson可选一个sex属性，值为'男'或者'女'或者undefined}// 使用IPerson接口定义一个对象，如果对象不符合IPerson的定义，编译器会飘红报错const person: IPerson = { name: '小王', age: 12, family: ['爹', '娘'],}// type类似interface，以下写法等同用interface声明IPersontype IPerson2 = { name: string age: number family: Array&lt;string&gt; sex?: '男' | '女'}// 因此可以直接定义过来const person2: IPerson2 = person 可能有的同学看了上面的介绍，会说： “要写这么多其他代码，还增加了文件体积，搞个啥子咧” 一般情况下，ts需要编译成js才能运行。编译后长这样： 123456789101112131415// 'xxx: number' 表示声明一个number类型var num = 123;// 声明一个函数的参数类型(number以及any)和返回值(void)function fn(arg1, arg2) { // todo}fn(num, [1, 2, 3, 4]);// 使用IPerson接口定义一个对象，如果对象不符合IPerson的定义，编译器会飘红报错var person = { name: '小王', age: 12, family: ['爹', '娘'],};// 因此可以直接定义过来var person2 = person; 通过人肉diff，发现编译后的去掉了ts的所有代码。 可能就又有同学想问了： “学这些有啥好处?” 别急，接着往下看🤓 应用场景这块介绍ts的几个应用场景，给点启发~ -用我的代码就要听我的平时为了代码的健壮性，不得不对代码做很多容错的操作。 假如成功避免了因为自己年龄大了而眼睛花了，使用自己写的方法时这里漏了一个参数，那里传错了参数类型。经常会有些不靠谱的使用者，不看你辛辛苦苦耕耘的api文档，瞎jb传参。最后出了问题还怪你没有做好兼容处理，领导群里一顿数落。 我们就得像孩子他妈一样，考虑熊孩子会传些什么乱七八糟的东西进来，然后在代码里面加上各种分支。 现在用ts，就可以在传参的时候友好的提示出来“你写了个什么玩意”的意思。 首先用ts定义一个函数 12345678interface IArgs { name: string age: string}function youFoo (arg1: string, arg2: 'a'|'b', arg3: IArgs) { // 这里啥都不干，你传参吧} 假如同事小明这么写 1234youFoo('sss', 'c', { name: 'xiaoming', age: 18}) 他就会发现哪里好像不太对 第二个参数要求’a’或者’b’，于是小明默默的改过来了，但是又发现 原来age是要求传string类型。 于是小明一边心里mmp一边改了过来。 -找文档平时在干活的时候，我们一般喜欢多一个屏幕，可以开个chrome，查查问题找找文档等。不过经常还得看网速，用搜索去搜api啥的，遇到在乡下写代码，分分钟有想shi的心。 有了ts，我们就完(da)美(gai)的决掉了这个问题: 首先按照这样的结构去写方法： 12345678910111213141516/** * 一个方法：生成错误提示信息 * * @param {string} message 提示信息，比如`you have a error` * @param {number | string} code 错误码，数字和字符都行 * @param {string} type 类型，请写`demo1`或者`demo2` * * [还不懂？点这里吧](https://www.google.com) * * // demo * genErrMsg('demo', 10086) * */export function genErrMsg (message: string, code: number | string, type?: ('demo1' | 'demo2')): string { return (message || `网络繁忙，请稍候再试`) + (code ? `(${code})` : ``)} 然后在使用过程中的体验如下： 在更完善的lib当中，体验更佳，除了开头的jquery外，还比如： -粗心大意阅读以下js代码，提问：分割线以下的代码有几处bug？ 12345678910111213141516171819202122// careless.jslet foooo = 1let fooo = 1let fooooooo = 1let foo = 1let foooooo = 1let test = 12const obj = { fn1 () {}, fn2 () {}, fn4 () {},}/*************** 分割线以下的代码有哪些地方有bug？ **************** */obj.fn3()console.leg(fooooo)function test () { alert(tast)} /* ** ** * 答案分界线 * ** ** */ 是不是觉得眼睛有点要瞎了？ 试试把.js改成.ts -隐藏的问题如果说之前的js代码还能凭眼神立刻看出哪里不对，那么下面这些就没那么简单了 阅读以下js代码，提问：代码有几处bug？ 123456import * as utils from './utils'utils.genErrMsg(10086, 'this is error') // 上面提到的genErrMsg函数let dom = window.document.getElementById('foo')dom.className = 'add' /* ** ** * 答案分界线 * ** ** */ 试试把.js改成.ts 可知问题如下： 1.genErrMsg的第一个参数应该是string 2.getElementById返回值还可能是null -接口数据不知道在维护代码的过程中，可能经常遇到某个接口不知道有啥数据，通常这个时候我们需要去查接口文档。然而当次数一多，或者后台大佬一坑起来，改了字段，可能会查到怀疑人生。 如果使用ts，可能手里的剧本就不一样了 假如有个接口如下所示 我们针对这个接口写出了如下ts代码： 123456789101112131415161718192021222324interface IPriceData { /** 标识 */ cbf: string /** id */ id: string /** 市场价格 */ m: string /** 后台价 */ op: string /** 前台价 */ p: string}// 将IPriceData塞进数组里type IPriceDataArray = Array&lt;IPriceData&gt;function getPrice () { // Promise的泛型参数使用了IPriceDataArray类型，then里面返回的数据就是IPriceDataArray类型 return new Promise&lt;IPriceDataArray&gt;((resolve, reject) =&gt; { $.get('https://xxxxxxx/prices/pgets?ids=P_100012&amp;area=&amp;source=', data =&gt; { resolve(data) }) })} 当调用getPrice函数时，体验如下： 以后每次维护这段函数的时候都不需要去看文档啦。如果后台突然改了字段，在检查的过程中我们可以马上发现问题，然后拿着数据去质问：你tm改了东西让我来背锅…(此处省略1万个字) -增强后的class和enum众所周知，js里面的class就是个语法糖，想学强类型语言，写法又是个半吊子。 但是在ts当中，class被增强了(当然还是个语法糖，只不过更甜了) 咱们看图说话： vscode中对ts下的共有属性、私有属性、保护属性和静态属性开了小灶，实例下只有公有属性才会被允许使用和提示出来。 另外ts还提供了enum语法糖： 12345678910111213141516171819enum HttpCode { /** 成功 */ '200_OK' = 200, /** 已生成了新的资源 */ '201_Created' = 201, /** 请求稍后会被处理 */ '202_Accepted' = 202, /** 资源已经不存在 */ '204_NoContent' = 204, /** 被请求的资源有一系列可供选择的回馈信息 */ '300_MultipleChoices' = 300, /** 永久性转移 */ '301_MovedPermanently' = 301, /** 暂时性转移 */ '302_MoveTemporarily' = 302,}HttpCode['200_OK']HttpCode[200] 相比简单对象定义的key-value，只能通过key去访问value，不能通过value访问key。但是在enum当中，正反都可以当做key来用。 编译后的代码有兴趣的同学可以了解下~ 1234567891011121314151617181920\"use strict\";var HttpCode;(function (HttpCode) { /** 成功 */ HttpCode[HttpCode[\"200_OK\"] = 200] = \"200_OK\"; /** 已生成了新的资源 */ HttpCode[HttpCode[\"201_Created\"] = 201] = \"201_Created\"; /** 请求稍后会被处理 */ HttpCode[HttpCode[\"202_Accepted\"] = 202] = \"202_Accepted\"; /** 资源已经不存在 */ HttpCode[HttpCode[\"204_NoContent\"] = 204] = \"204_NoContent\"; /** 被请求的资源有一系列可供选择的回馈信息 */ HttpCode[HttpCode[\"300_MultipleChoices\"] = 300] = \"300_MultipleChoices\"; /** 永久性转移 */ HttpCode[HttpCode[\"301_MovedPermanently\"] = 301] = \"301_MovedPermanently\"; /** 暂时性转移 */ HttpCode[HttpCode[\"302_MoveTemporarily\"] = 302] = \"302_MoveTemporarily\";})(HttpCode || (HttpCode = {}));HttpCode['200_OK'];HttpCode[200]; 优点以及不足通过上面的几个栗子，大概可以看出使用了ts后，可以获得以下技能点： 清晰的函数参数/接口属性，增加了代码可读性和可维护性 静态检查 生成API文档 配合现代编辑器，各种提示 活跃的社区 以及对应的技术成本 维护者(包的作者) 使用者 收益 清晰的函数参数/接口属性 静态检查 生成api文档 清晰的函数参数/接口属性 配合现代编辑器，各种提示 代价 标记类型 声明(interface/type) 和某些库结合的不是很完美(没错，说的就是vue 2.x) 这里提到的vue2.x由于ts先天能力的不足，导致vue的ts语法需要使用class风格(运行时会被转换回原本的vue构造函数的语法)，和我们平时熟悉的vue风格有些差异 这里是因为vue的this下的环境比较复杂，对于ide来说需要在运行时才能确定，因此在编写ts的时候需要手动去设置属性(比如props,data,methods等)到this下面，非常麻烦。早期ts并不支持手动编写this的作用域，后来专门为其设计了一个ThisType的方法。 在上面的代码里用了class的写法，本身所有需要的属性就在this下，规避了运行时才能确定this下需要的作用域的问题。 另一方面，由于ts提示能力比较局限，比如在函数场景中，如果数据来源是独立的对象，体验就会比较糟糕。 请阅读以下栗子(这一块稍微超纲了标题’安利’的范畴，不太理解的新同学可以入坑以后再消化~) 1234567891011121314151617181920212223interface IOptions { name: string age: number extra: { data: Object methods: Object }}// 参数options要求符合IOptions定义的规则function sthConstructor (options: IOptions) {}// options对象当中并没有任何ts的静态检查和提示const options = { name: 'peter', age: '13', // error: age应该为数字 extra: { data: [], methods: {} }}// options飘红报错，然而提示内容废话太多，关键信息藏得太深sthConstructor(options) 在上面的场景，我们希望在options当中能够获得完整的ts检查能力。达成这个目的有三种方法： 1.将options里面的东西挪进函数当中 2.将options用IObject定义 3.提供一个helper方法 这三种方式当中： 方法1是最简单的方式，但是在大型项目当中，这样的写法反而很少见到。 方法2是维护者常用的方式，但是对于使用者而言，成本较高。因为使用者需要去lib里翻到方法对应的type类型，将它import进来。 方法3是个人觉得相对比较好的方式，只要维护者提供一个类似helper的函数包装一下，就可以获得对应的提示。是不是很像vue ts的装饰器? 但上述三种解决方式我觉得都不优雅，这就是ts当前的不足之一。 ts在js中的玩法TypeScript是和vscode都是微软的亲儿子，他们兄弟俩相互协作肯定会有更多小花样，甚至你用的只是js文件，也可以享受到。 这里抛砖引玉列出两条： -配置文件自动提示只要有types文件，所有配置都可以自动提示： 12345678910/** * webpack配置自动提示 * * 先安装对应的types包： `npm i @types/webpack -D` * * @type {import(&apos;webpack&apos;).Configuration} */const config = { } -js语法检查在js中也可以获得自动提示和静态检查。只要在vscode的setting当中勾上Check JS即可。虽然你的js代码可能会被各种飘红🤪 ⬇️ 之前的例子在js中也可以提示出一些bug了 写在最后有的同学会问：我才学js，可以学ts吗？可以，并且建议，因为会对js基础知识加深理解。有用法问题在stackoverflow上搜搜就解决了。 那么这么有用的工具，去哪可以学到呢？或许你可以参考下我学习的轨迹： 传送门–TypeScript 入门教程 (墙裂推荐) 传送门–为 Vue3 学点 TypeScript , 体验 TypeScript 传送门–一篇朴实的文章带你30分钟捋完TypeScript,方法是正反对比 传送门–stack overflow (墙裂推荐) 传送门–google 今年ts突然遍地开花，似乎成为了潮流。各种ts改造、学习教程、心得出现在了各大学习、交友网站上。有的同学可能也发现了：这不就就是java这类语言玩剩了的东西了吗？ 那年轻的时候谁不都想自由嘛，然而随着年龄大了都被管的服服帖帖的","link":"/2019/10/08/TypeScript安利指南/"},{"title":"Electron 实践笔记","text":"作者：周全 社交魔方平台是京东的 SNS 活动搭建平台，其内置了很多模板，每一个模板都有一个模板 JSON 用于生成表单，运营同学、商家配置了这个表单后就可以生成活动页面了。模板 JSON 是标准的结构化数据，包含名称、类型、控件类型、校验器、默认值等等字段。以往都是采用手写 JSON 的方式，这是非常低效的，而且容易出错。针对其结构化数据的特点可以用 GUI 的方式去编辑，我们基于 Electron 参考 Github Desktop 客户端 的架构编写了一个 编辑器，通过填写表单的方式生成 JSON。所以在这里记录下这个 Electron 编辑器开发过程中可以记录的点和从 Github Desktop 客户端代码中值得学习的点。 一、关于 Electron Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。 上面是来自 Electron 官方的介绍。基于 Electron 平台，我们可以使用熟悉的前端技术栈来开发桌面应用。Electron 运行 package.json 的 main 脚本的进程被称为主进程（以下简称main）。 在主进程中运行的脚本通过创建 web 页面来展示用户界面（以下简称 renderer）。 一个 Electron 应用总是有且只有一个主进程。main 用于创建应用，创建浏览器窗口，它就是一个彻底的 Node 进程，获取不到 DOM, BOM 这些接口。在 main 创建的浏览器窗口中运行的就是 renderer 进程，它既可以获取 DOM, BOM 这些接口，也可以使用 Node 的 API。两类进程之间可以通过 Electron 提供的 IPC 接口通信。 二、开发环境搭建我们了解到 Electron 分为两类进程，main 和 renderer。所以搭建开发环境时不能像普通的前端应用一样一个 webpack 配置搞定。并且我们想要实现 一键启动开发环境 一键打包 一键发布 那么就需要两个 webpack 配置文件。 一个用于开发环境 – webpack.dev.ts。 1234567891011121314151617181920212223242526272829// webpack.dev.tsconst mainConfig = merge({}, base.mainConfig, config, { watch: true})const rendererConfig = merge({}, base.rendererConfig, config, { module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'], }, { test: /\\.styl$/, use: ['style-loader', 'css-loader', 'stylus-loader'], } ] }, devServer: { contentBase: path.join(__dirname, base.outputDir), port: 8000, hot: true, inline: true, historyApiFallback: true, writeToDisk: true },})module.exports = [rendererConfig, mainConfig] 另一个用于生产环境 – webpack.prod.ts。 12345678910111213141516171819202122232425262728293031const config: webpack.Configuration = { mode: 'production', devtool: 'source-map',}const mainConfig = merge({}, base.mainConfig, config)const rendererConfig = merge({}, base.rendererConfig, config, { module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'], }, { test: /\\.styl$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'stylus-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: 'renderer.css' }), new BundleAnalyzerPlugin({ analyzerMode: 'static', openAnalyzer: false, reportFilename: 'renderer.report.html', }), ],})module.exports = [mainConfig, rendererConfig] 这里参考了 Desktop 使用 Typescript 编写 webpack 配置文件。配合 interface 可以实现 webpack 配置文件的编辑器自动补全。具体使用方法可参考 webpack 文档 https://webpack.js.org/configuration/configuration-languages/#typescript 每一个配置文件导出一个数组，分别是 main, renderer 的配置对象。 使用 webpack-dev-server 启动能实现 renderer 的热更新，main 则是使用 webpack 的 watch 模式。 123{ \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\"} 使用 nodemon 监听 main 编译后的产物，nodemon 监听到改动则重新运行 electron . 重启应用,这样间接实现了 main 的 livereload。 Nodemon is a utility that will monitor for any changes in your source and automatically restart your server. 1234{ \"app\": \"electron .\", \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\",} 这样就实现了一键启动开发环境，且能够监听代码变化，重新启动应用。 Tips: 开源社区有更好的 electron-webpack, HMR for both renderer and main processes 生产环境则使用 webpack 顺序编译 main 和 renderer。编译完成后使用 electron-builder 打包。这样就实现了一键打包。 由于工具链的缺失实现不了一键发布，就只能打包后手动发布了（后面详细说明）。 下面就是完整的 scripts。 123456789101112131415161718{ \"scripts\": { \"start\": \"run-p -c compile:dev typecheck:watch app:watch\", \"dist\": \"npm run compile:prod &amp;&amp; electron-builder build --win --mac\", \"compile:dev\": \"webpack-dev-server --config scripts/webpack.dev.ts\", \"compile:prod\": \"npm run clean &amp;&amp; webpack --config scripts/webpack.prod.ts\", \"app\": \"electron .\", \"app:watch\": \"nodemon --watch 'dest/main.js' --exec npm run app\", \"clean\": \"rimraf dest dist\", \"typecheck\": \"tsc --noEmit\", \"typecheck:watch\": \"tsc --noEmit --watch\", \"lint\": \"eslint src --ext .ts,.js --fix\", \"release:patch\": \"standard-version --release-as patch &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\", \"release:minor\": \"standard-version --release-as minor &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\", \"release:major\": \"standard-version --release-as major &amp;&amp; git push --follow-tags origin master &amp;&amp; npm run dist\", \"repush\": \"git push --follow-tags origin master &amp;&amp; npm run dist\" },} 三、目录结构1. 项目目录结构123456789101112131415161718192021222324252627282930src├── lib│ ├── cube│ ├── databases│ ├── enviroment│ ├── files│ ├── local-storage│ ├── log│ ├── shell│ ├── stores│ ├── update│ ├── validator│ └── watcher├── main│ ├── app-window.ts│ ├── event-bus.ts│ ├── index.ts│ ├── keyboard│ └── menu├── models│ ├── popup.ts│ └── project.ts└── renderer ├── App.tsx ├── assets ├── components ├── index.html ├── index.tsx ├── pages └── types 在目录结构上模仿了 Desktop。main 目录存放 main 进程相关代码，包括应用入口，窗口创建，菜单，快捷键等等；而 renderer 目录则是整个 UI 渲染层的代码。lib 目录则是一些和 UI 无关也和 main 无强相关的业务逻辑代码。models 则存放一些领域模型。 2. CSS 规范在这个 React 中项目中没有使用 css-modules 这类方案。而是使用 BEM 这类能形成命名空间的规范来实现模块化，这样做的好处是能够比较好的对样式进行覆盖。 在文件的组织方式上采用一个独立的 React 组件搭配一个独立的样式文件，这样在重构的时候，我们想要修改一个组件的样式只需要找到对应的样式文件进行修改即可，提高重构的效率。 123456789101112stylesheets ├── common.styl ├── components │ ├── editor.styl │ ├── empty-guide.styl │ ├── find-in-page.styl │ ├── reindex.styl │ ├── sidebar.styl │ ├── source-viewer.styl │ └── upload.styl ├── index.styl └── reset.styl 三、IPC 通信 进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 Electron 的 main 进程和 renderer 进程的通信是通过 Electron 提供的 ipcMain 和 ipcRenderer 来实现的。 1. main 端在 main 中向某一个窗口 renderer 发送消息可以使用 window.webContents.send。在 main 端监听 renderer 消息可以使用 ipcMain.on。 1234567891011// 在主进程中.const { ipcMain } = require('electron')ipcMain.on('asynchronous-message', (event, arg) =&gt; { console.log(arg) // prints \"ping\" event.reply('asynchronous-reply', 'pong')})ipcMain.on('synchronous-message', (event, arg) =&gt; { console.log(arg) // prints \"ping\" event.returnValue = 'pong'}) 2. renderer 端回复同步消息可以使用 event.returnValue。同步消息的返回值可以直接读取。回复异步消息可以使用 event.reply。那么在 renderer 就要监听回复的 channel 得到返回值。 12345678//在渲染器进程 (网页) 中。const { ipcRenderer } = require('electron')console.log(ipcRenderer.sendSync('synchronous-message', 'ping')) // prints \"pong\"ipcRenderer.on('asynchronous-reply', (event, arg) =&gt; { console.log(arg) // prints \"pong\"})ipcRenderer.send('asynchronous-message', 'ping') 可以看到 renderer 可以使用 ipcRenderer.send 向主进程发送异步消息。用 ipcRenderer.sendSync 发送同步消息。 四、数据持久化及状态管理1. 复杂数据持久化数据持久化可选的方案有很多，比如 electron-store等基于 JSON 文件实现的存储方案。对于更复杂的应用场景还可以使用 lowdb，nedb ，sqlite等。 最初我使用的是 electron-store, 并且一直有一个执念是对磁盘的读写只能在 main 进程进行，renderer 进程只负责渲染界面。所以在最初设计的是在 renderer 进程渲染数据或者更新数据的时候都需要通过 IPC 到 main 进程来完成最终的磁盘读写。除去读写正常的情况，还要考虑读写磁盘的异常，这样导致数据流异常的绕。而且还需要自己维护 ID 的生成。借鉴了 Desktop 的代码后，重构了数据持久化部分，也采用了 Dexie，它是对浏览器标准数据库 indexedDB 的一个封装。从它的 Readme 可以看到它主要解决了indexedDB 的三个问题： 不明确的异常处理 查询很烂 代码复杂 1234567891011121314151617181920import Dexie from 'dexie';export interface IDatabaseProject { id?: number; name: string; filePath: string;}export class ProjectsDatabase extends Dexie { public projects: Dexie.Table&lt;IDatabaseProject, number&gt;; constructor() { super('ProjectsDatabase'); this.version(1).stores({ projects: '++id,&amp;name,&amp;filePath', }); this.projects = this.table('projects'); }} 继承 Dexie 来实现我们自己的数据库类，在构造函数中声明数据库的版本，表的 schema 等等。具体可以参考 Dexie 官方文档。 2. 简单数据持久化一些 UI 状态的标志位存储（比如某个弹窗是否显示过），我们一般会把这种标志位存储到 localStorage 中。在查看 Desktop 的源码过程中，发现他们对 number, boolean 类型的数据的 get, set 进行了简单的封装。使用起来非常方便，这里贴一下对于 boolean 型数据的处理。 12345678910111213141516171819202122232425export function getBoolean(key: string): boolean | undefinedexport function getBoolean(key: string, defaultValue: boolean): booleanexport function getBoolean( key: string, defaultValue?: boolean): boolean | undefined { const value = localStorage.getItem(key) if (value === null) { return defaultValue } if (value === '1' || value === 'true') { return true } if (value === '0' || value === 'false') { return false } return defaultValue}export function setBoolean(key: string, value: boolean) { localStorage.setItem(key, value ? '1' : '0')} 源码详见 五、功能实现1. 磁盘/编辑器版本实时同步一般情况下，在编辑器中我们编辑的内容其实是编辑器读取磁盘文件到内存中的副本。所以说如果磁盘的文件发生了改动，比如 Git 切换分支造成文件变动，抑或是删除了磁盘文件，重命名等等都会造成内存版本和磁盘版本的不一致，即磁盘版本领先于内存版本，这个时候就可能产生冲突。解决这个问题很简单，可以使用 fs.watch/watchFile 监听当前编辑的文件，一旦发生变化，就重新读取磁盘版本，更新内存版本来实现同步。但是 fs.watch 这个 API 在工程上不是可以开箱即用的，有许多兼容问题和一些 bug。比如说 Node.js fs.watch: Doesn’t report filenames on MacOS. Doesn’t report events at all when using editors like Sublime on MacOS. Often reports events twice. Emits most changes as rename. Does not provide an easy way to recursively watch file trees. Node.js fs.watchFile: Almost as bad at event handling. Also does not provide any recursive watching. Results in high CPU utilization. 上面列举的点来自 chokidar，它是一个 Node 模块，提供了开箱可用的监听文件变化的能力。只需要监听 add, unlink, change 等事件读取最新版本的文本到编辑器就可以实现磁盘/编辑器版本的同步了。 2. Context-MenuDesktop 的 contextmenu (右键菜单)的实现基于原生 IPC 的，比较绕。 首先我们需要知道的是 Menu 类是 main process only 的。 在需要 contextmenu 的 JSX.Element 上绑定 onContextMenu 事件。构造对象数组 Array&lt;MenuItem&gt;, 并且为每个 MenuItem 对象绑定触发事件，再通过 IPC 将对象传递至 main 进程，值得一提的是这个时候将 MenuItem 数组赋值给了一个全局对象，暂存起来。在 main 进程构造出真正的 MenuItem 实例，绑定 MenuItem 的点击事件，触发 MenuItem 点击事件的时候记录 MenuItem 的 序列号 index，再将 index 通过 event.sender.send 将 index 传递到 renderer 进程。renderer 进程拿到 index 之后根据之前保存的全局对象取出单个 MenuItem， 执行绑定的事件。 1onContextMenu =&gt; showContextualMenu (暂存MenuItems，ipcRenderer.send) =&gt; icpMain =&gt; menu.popup() =&gt; MenuItem.onClick(index) =&gt; event.sernder.send(index) =&gt; MenuItem.action() 所以在我的应用中使用了 remote 对象屏蔽上述复杂的 IPC 通信。在 renderer 进程完成 Menu 的构造展示和事件的绑定触发。 123456789101112131415161718192021222324252627import { remote } from 'electron';const { MenuItem, dialog, getCurrentWindow, Menu } = remote;const onContextMenu = (project: Project) =&gt; { const menu = new Menu(); const menus = [ new MenuItem({ label: '在终端中打开', visible: __DARWIN__, click() { const accessor = new FileAccessor(project.filePath); accessor.openInTerminal(); }, }), new MenuItem({ label: '在 vscode 中打开', click() { const accessor = new FileAccessor(project.filePath); accessor.openInVscode(); }, }), ]; menus.forEach(menu.append); menu.popup({ window: getCurrentWindow() });}; 六、日志完善的日志不论是开发环境还是生产环境都是非常重要的，大致记录 UI 状态迁移背后的数据变动，流程的分支走向，能很好的辅助开发。 参考 Desktop，他们的日志基于日志库：winston。 在 main 进程和 renderer 进程都提供了全局 log 对象，接口都是一致的。分别是 debug, info, warn, error。在 renderer 进程，简单的封装了 window.console 对象上的 debug, info, warn, error 方法，日志打印到浏览器控制台的时候也通过 IPC 传递到 main 进程，由 main 进程统一管理。 main 进程接收了来自 renderer 进程的日志信息和 main 进程自身的日志信息。设置了两个 transports。winston.transports.Console 和 winston.transports.DailyRotateFile 分别用于将日志信息打印在终端控制台和存储在磁盘文件。DailyRotateFile 以天为单位，设置了最多存储 14 天的上限。 在 main 进程和 renderer 进程启动时分别引入日志安装模块。因为 log 方法都是暴露在全局，因此只需要在进程启动时引入一次即可。同时在 TS 环境中还需要添加 log 方法的类型声明。 七、打包，发布及更新开源世界已经有非常完善的打包和发布的工具 – electron-builder。它集多平台打包，签名，自动更新，发布到Github等平台等等功能于一身。 鉴于这个工具只能在内网使用，不能发布到 Github 而且也没有没有苹果开发者工具无法进行签名，只能利用 electron-builder 在本机打包，发布的话只能使用手动打包上传了，用户也只能手动下载安装包覆盖安装，不能像 VSCODE 这样实现自动更新。 既然不能自动更新，那么新版本下发后，如何通知到用户去下载新版本安装包更新呢？从用户这一端来看，在应用每次启动的时候可以做一次请求，查询是否有版本更新，或者是在应用菜单栏提供入口，让用户手动触发更新查询。查询到服务端的最新版本后，使用 sermver 比较本机版本是否低于服务器版本，如果是就下发通知给用户，提示用户去下载更新。 在有限的条件下怎么实现这个功能呢？ 实现这个功能必需的三个元素：服务端标识着最新版本的可读文件；托管各个版本安装包的云空间；应用代码中的更新逻辑。 服务端标识着最新版本的可读文件：每次打包时都会更新 package.json，所以我们直接把 package.json 上传到某个不带鉴权的 CDN 就可以，更新的时候就请求这个文件。 托管各个版本安装包的云空间：这个可以使用云盘，云盘可以生成分享链接，把这个链接手动拷贝到 Gitlab 该版本的 tag 的 Notes 中。 应用代码中的更新逻辑： 1234567891011121314151617181920212223import got from 'got';import semver from 'semver';import { app, remote, BrowserWindow } from 'electron';const realApp = app || remote.app;const currentVersion = realApp.getVersion();export async function checkForUpdates(window: BrowserWindow, silent: boolean = false) { const url = `http://yourcdn/package.json?t=${Date.now()}`; try { const response = await got(url); const pkg = JSON.parse(response.body); log.debug('检查更新，云端版本：', pkg.version); log.debug('当前版本', currentVersion); if (semver.lt(currentVersion, pkg.version)) { window.webContents.send('update-available', pkg.version); } else { window.webContents.send('update-not-available', silent); } } catch (error) { window.webContents.send('update-error', silent); }} 分别在应用主进程启动、用户点击应用菜单检查更新时调用这个方法，从而通知 UI 进程下发通知。我们期望应用主进程启动时的更新是在失败或者无更新时是静默的，不用打扰用户，所以在 IPC 管道可以提供一个 silent 参数。检测到更新后就可以通知用户，用户点击更新后就可以跳转到最新版本的 Gitlab tags ，引导用户下载最新版本进行手动安装。 八、其他1. devtools开发 Electron 应用中 renderer 端也是使用 Chrome devtools 来调试的。对于 React, Mobx 这类框的 devtools 扩展也可以通过 electron-devtools-installer 来安装。应用窗口创建之后调用electron-devtools-installer 进行 mobx、react 等扩展的安装。 123456789const { default: installExtension, MOBX_DEVTOOLS, REACT_DEVELOPER_TOOLS } = require('electron-devtools-installer');const extensions = [REACT_DEVELOPER_TOOLS, MOBX_DEVTOOLS];for (const extension of extensions) { try { installExtension(extension); } catch (e) { // log.error(e); }} 2. 保持窗口大小对于桌面应用，一个常见的需求就是关闭后重新打开，需要恢复到上次打开时的窗口大小，位置。实现这个比较简单，监听窗口的 resize 事件，把窗口信息记录到当前用户的应用数据文件夹, 即 app.getPath(appData)。下次启动应用创建窗口时读取这个文件设置窗口信息即可。开源社区已经有对这个功能封装好的库：electron-window-state 123456789101112131415161718const windowStateKeeper = require('electron-window-state');let win;app.on('ready', function () { let mainWindowState = windowStateKeeper({ defaultWidth: 1000, defaultHeight: 800 }); win = new BrowserWindow({ 'x': mainWindowState.x, 'y': mainWindowState.y, 'width': mainWindowState.width, 'height': mainWindowState.height }); mainWindowState.manage(win);}); 只需要提供缺省窗口大小，剩余的事情 electron-window-state 都帮我们搞定了。","link":"/2019/10/11/Electron-实践笔记/"},{"title":"Vue.js 3.0编译器compiler-core源码解析","text":"作者：深山蚂蚁 Vue.js 3.0的源代码正在国庆假期就这么突然放出来了，假期还没结束，陆陆续续看到努力的码农就在各种分析了。 目前还是 pre Alpha，乐观估计还有 Alpha，Beta版本，最后才是正式版。 话不多说，看 Pre-Alpha。 瞧 compiler-core 热门的 reactivity 被大佬翻来覆去再研究了，我就和大伙一起来解读一下 ”冷门“ 的 compiler 吧！😄😄😄😄 如果你对 AST 还不太熟悉，或者对如何实现一个简单的 AST解析器 还不太熟悉，可以猛戳：手把手教你写一个 AST 解析器 vue3.0的模板解析和vue2.0差异比较大，但是无论怎样变化，基本原理是一致的，我们写的各种 html 代码，js使用的时候其实就是一个字符串，将非结构化的字符串数据，转换成结构化的 AST，我们都是使用强大的正则表达式和indexOf来判断。compiler-core 的一个核心作用就是将字符串转换成 抽象对象语法树AST。 Let’s do IT ! 目录结构 _tests_ 测试用例 src/ast ts语法的大佬的类型定义，比如type，enum，interface等 src/codegen 将生成的ast转换成render字符串 src/errors 定义 compiler 错误类型 src/index 入口文件，主要有一个 baseCompile ，用来编译模板文件的 src/parse 将模板字符串转换成 AST src/runtimeHelper 生成code的时候的定义常量对应关系 src/transform 处理 AST 中的 vue 特有语法，比如 v-if ,v-on 的解析 进入 compiler-core 目录下，结构一目了然。这里说下 _tests_ 目录，是vue的jest测试用例。阅读源码前先看看用例，对阅读源码有很大帮助哦。 如下，测试一个简单的text，执行parse方法之后，得到 ast，期望 ast 的第一个节点与定义的对象是一致的。同理其他的模块测试用例，在阅读源码前可以先瞄一眼，知道这个模块如何使用，输入输出是啥。 1234567891011121314test('simple text', () =&gt; { const ast = parse('some text') const text = ast.children[0] as TextNode expect(text).toStrictEqual({ type: NodeTypes.TEXT, content: 'some text', isEmpty: false, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 9, line: 1, column: 10 }, source: 'some text' } })}) 先看一张图，重点是四块： 起始标签 结束标签 动态内容 普通内容 其中起始标签会用到递归来处理子节点。 接下来，我们开始跟着源码来阅读吧! parse：将字符串模板转换成 AST 抽象语法树这个是对外暴露的核心方法，我们先测试下结果： 12345678const source = ` &lt;div id=\"test\" :class=\"cls\"&gt; &lt;span&gt;{{ name }}&lt;/span&gt; &lt;MyCom&gt;&lt;/MyCom&gt; &lt;/div&gt;`.trim()import { parse } from './compiler-core.cjs'const result = parse(source) output: 一个简单的转换结果就呈现出来了，从生成的结构来看，相对于vue2.x有几个比较重要的变化： 新增了 loc 属性 每一个节点都记录了该节点在源码当中的 start 和 end，标识了代码的详细位置，column,line,offset。 vu3.0对于开发遇到的问题都要详细的日志输出也基于此，另外支持 source-map 新增了 tagType 属性 tagType 属性标识该节点是什么类型的。我们知道 vue2.x 判断节点类型是运行时才有的，vu3.0将判断提前到编译阶段了，提升了性能。 目前tagType有三种类型：0 element,1 component,2 slot,3 template 新增 isStatic 属性 将模板提前编译好，标识是否为动态变化的，比如动态指令 …… 新版的 AST 明显比 vue2.x 要复杂些，可以看到vue3.0将很多可以在编译阶段就能确定的就在编译阶段确定，标识编译结果，不需要等到运行时再去判断，节省内存和性能。这个也是尤大大重点说了的，优化编译，提升性能。 接下来我们来看下转换的代码，主要有如下几个方法： parse &amp; parseChildren 主入口 parseTag 处理标签 parseAttribute 处理标签上的属性 parseElement 处理起始标签 parseInterpolation 处理动态文本内容 parseText 处理静态文本内容 parse &amp; parseChildren 主入口parse 的主入口，这里创建了一个 parseContext，有利于后续直接从 context 上拿到 content，options 等。getCursor 获取当前处理的指针位置，用户生成 loc,初始都是1。 1234567891011121314export function parse(content: string, options: ParserOptions = {}): RootNode { const context = createParserContext(content, options) const start = getCursor(context) return { type: NodeTypes.ROOT, children: parseChildren(context, TextModes.DATA, []), helpers: [], components: [], directives: [], hoists: [], codegenNode: undefined, loc: getSelection(context, start) }} 重点看下 parseChildren ，这是转换的主入口方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function parseChildren( context: ParserContext, mode: TextModes, ancestors: ElementNode[]): TemplateChildNode[] { const parent = last(ancestors) const ns = parent ? parent.ns : Namespaces.HTML const nodes: TemplateChildNode[] = [] while (!isEnd(context, mode, ancestors)) { const s = context.source let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined if (startsWith(s, context.options.delimiters[0])) { // '{{' node = parseInterpolation(context, mode) } else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') { // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state if (s.length === 1) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1) } else if (s[1] === '!') { // &lt;!DOCTYPE &lt;![CDATA[ 等非节点元素 暂不讨论 } else if (s[1] === '/') { if (s.length === 2) { } else if (s[2] === '&gt;') { advanceBy(context, 3) continue } else if (/[a-z]/i.test(s[2])) { parseTag(context, TagType.End, parent) continue } else { } } else if (/[a-z]/i.test(s[1])) { node = parseElement(context, ancestors) } else if (s[1] === '?') { } else { } } if (!node) { node = parseText(context, mode) } if (Array.isArray(node)) { for (let i = 0; i &lt; node.length; i++) { pushNode(context, nodes, node[i]) } } else { pushNode(context, nodes, node) } } return nodes} ancestors 用来存储未匹配的起始节点，为后进先出的stack。 循环处理 source，循环截止条件是 isEnd 方法返回true，即是处理完成了，结束有两个条件: context.source 为空，即整个模板都处理完成。 碰到截止节点标签(&lt;/)，且能在未匹配的起始标签（ancestors）里面找到对对应的tag。这个对应 parseChildren 的子节点处理完成。 匹配尚未结束，则进入循环匹配。有三种情况： if(startsWith(s,context.options.delimiters[0]))语句， delimiters是分割符合，对于Vue来说就是‘’。开始匹配到Vue的文本输出内容，则意味着需要处理文本内容插入。 else if (mode === TextModes.DATA &amp;&amp; s[0] === ‘&lt;’) 内容是以&lt;开头，即html标签的标识符号，则开始处理起始标签和截止标签两种情况。 以上条件都不是，或者匹配未成功,那么就是动态文本内容了。 如果是第三种动态文本插入，则执行 parseInterpolation 组装文本节点，其中 isStatic=false 标识是变量，比较简单，方法就不贴了。 12345678910return { type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, isStatic: false, content, loc: getSelection(context, innerStart, innerEnd) }, loc: getSelection(context, start) } 再看下这两个处理 source 内容后移的方法： advanceBy(context,number) : 将需要处理的模板source ，后移 number 个字符，重新记录 locadvanceSpaces() : 后移存在的连续的空格 回到上面的匹配条件，如果是 &lt; 开头，分两种情况： 第二个字符是 “/“ 对应的就是 &lt;/ 如果是 &lt;/&gt; ，那么认为是一个无效标签，直接 advanceBy 后移 3 个字符即可。 如果是 &lt;\\/a，那么认为是一个截止标签，执行 parseTag 方法处理。 第二个字符是字母 对应就是标签的起始文字了，如 &lt;\\div，执行 parseElement 方法处理起始标签。 parseTag 处理标签如果是截止标签：parseTag，则直接处理完成。如果是起始标签：parseElement 执行，调用parseTag 处理标签，然后再去递归处理子节点等。 正则：/^&lt;/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i 这个就不多说了，匹配 &lt;\\div&gt; &lt;/div&gt;这种标签。测试 match ： 12/^&lt;\\/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(\"&lt;div class='abc'&gt;\")(2) [\"&lt;div\", \"div\", index: 0, input: \"&lt;div class='abc'&gt;\", groups: undefined] 显然，mathch[1] 即匹配到的标签元素。我们看主方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined): ElementNode { // Tag open. const start = getCursor(context) const match = /^&lt;\\/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(context.source)! const tag = match[1] const props = [] const ns = context.options.getNamespace(tag, parent) let tagType = ElementTypes.ELEMENT if (tag === 'slot') tagType = ElementTypes.SLOT else if (tag === 'template') tagType = ElementTypes.TEMPLATE else if (/[A-Z-]/.test(tag)) tagType = ElementTypes.COMPONENT advanceBy(context, match[0].length) advanceSpaces(context) // Attributes. const attributeNames = new Set&lt;string&gt;() while ( context.source.length &gt; 0 &amp;&amp; !startsWith(context.source, '&gt;') &amp;&amp; !startsWith(context.source, '/&gt;') ) { const attr = parseAttribute(context, attributeNames) if (type === TagType.Start) { props.push(attr) } advanceSpaces(context) } // Tag close. let isSelfClosing = false if (context.source.length === 0) { } else { isSelfClosing = startsWith(context.source, '/&gt;') advanceBy(context, isSelfClosing ? 2 : 1) } return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined // to be created during transform phase }} tagType有四种类型，在这里定义了，分别是: 0 element,1 component,2 slot,3 template 我们看while 循环，advanceBy 去掉起始 &lt; 和标签名之后:如果跟着是 &gt; 或者 /&gt; ，那么标签处理结束，退出循环。否则是标签的元素，我们执行 parseAttribute 来处理标签属性，该节点上增加props，保存 该起始节点的 attributes; 执行方法后面的！，是ts语法，相当于告诉ts，这里一定会有值，无需做空判断，如 const match = /^&lt;/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(context.source)! parseAttribute 处理标签上的属性正则获取属性上的name 12/^[^\\t\\r\\n\\f /&gt;][^\\t\\r\\n\\f /&gt;=]*/.exec('class='abc'&gt;')[\"class\", index: 0, input: \"class='abc'&gt;\", groups: undefined] 如果不是一个孤立的属性，有value值的话（/^[\\t\\r\\n\\f ]*=/.test(context.source)），那么再获取属性的value。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990function parseAttribute( context: ParserContext, nameSet: Set&lt;string&gt;): AttributeNode | DirectiveNode { // Name. const start = getCursor(context) const match = /^[^\\t\\r\\n\\f /&gt;][^\\t\\r\\n\\f /&gt;=]*/.exec(context.source)! const name = match[0] nameSet.add(name) advanceBy(context, name.length) // Value let value: | { content: string isQuoted: boolean loc: SourceLocation } | undefined = undefined if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) { advanceSpaces(context) advanceBy(context, 1) advanceSpaces(context) value = parseAttributeValue(context) } const loc = getSelection(context, start) if (/^(v-|:|@|#)/.test(name)) { const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec( name )! let arg: ExpressionNode | undefined if (match[2]) { const startOffset = name.split(match[2], 2)!.shift()!.length const loc = getSelection( context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length) ) let content = match[2] let isStatic = true if (content.startsWith('[')) { isStatic = false content = content.substr(1, content.length - 2) } arg = { type: NodeTypes.SIMPLE_EXPRESSION, content, isStatic, loc } } if (value &amp;&amp; value.isQuoted) { const valueLoc = value.loc valueLoc.start.offset++ valueLoc.start.column++ valueLoc.end = advancePositionWithClone(valueLoc.start, value.content) valueLoc.source = valueLoc.source.slice(1, -1) } return { type: NodeTypes.DIRECTIVE, name: match[1] || (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot'), exp: value &amp;&amp; { type: NodeTypes.SIMPLE_EXPRESSION, content: value.content, isStatic: false, loc: value.loc }, arg, modifiers: match[3] ? match[3].substr(1).split('.') : [], loc } } return { type: NodeTypes.ATTRIBUTE, name, value: value &amp;&amp; { type: NodeTypes.TEXT, content: value.content, isEmpty: value.content.trim().length === 0, loc: value.loc }, loc }} parseAttributeValue 获取属性值的方法比较容易： 如果value值有引号开始，那么就找到下一个引号未value值结束 （class=”aaa” class=’aaa’） 如果value没有引号，那么就找到下一个空格为value值结束 （class=aaa） 其中有处理vue的语法特性，如果属性名称是v-,:,@,#开头的，需要特殊处理，看下这个正则： 12345/(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(\"v-name\")(4) [\"v-name\", \"name\", undefined, undefined, index: 0, input: \"v-name\", groups: undefined]/(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(\":name\")(4) [\":name\", undefined, \"name\", undefined, index: 0, input: \":name\", groups: undefined] mathch[2]如果有值，即匹配到了，说明是非 v-name，如果是名称是[]包裹的则是 动态指令，将 isStatic 置为 false parseElement 处理起始标签parseElement 处理起始标签，我们先执行 parseTag 解析标签，获取到起始节点的 标签元素和属性，如果当前也是截止标签(比如),则直接返回该标签。否则，将起始标签 push 到未匹配的起始 ancestors栈里面。然后继续去处理子元素 parseChildren ,注意，将未匹配的 ancestors 传进去了，parseChildren 的截止条件有两个： context.source为空，即处理完成 碰到截止节点标签(&lt;/)，且能在未匹配的起始标签（ancestors）里面找到对对应的tag。 因此，如果是循环碰到匹配的截止标签了，则需要 ancestors.pop()，将节点添加到当前的子节点。 当然，处理当前起始节点，该节点也可能是截止节点，比如：&lt;\\img src=”xxx”/&gt;，则继续去执行处理截止节点即可。方法如下： 12345678910111213141516171819202122232425262728function parseElement( context: ParserContext, ancestors: ElementNode[]): ElementNode | undefined { // Start tag. const parent = last(ancestors) const element = parseTag(context, TagType.Start, parent) if (element.isSelfClosing || context.options.isVoidTag(element.tag)) { return element } // Children. ancestors.push(element) const mode = (context.options.getTextMode( element.tag, element.ns ) as unknown) as TextModes const children = parseChildren(context, mode, ancestors) ancestors.pop() element.children = children // End tag. if (startsWithEndTagOpen(context.source, element.tag)) { parseTag(context, TagType.End, parent) } else { } element.loc = getSelection(context, element.loc.start) return element} 至此，vue3.0的 将 模板文件转换成 AST 的主流程已经基本完成。静待下篇，AST 的 transform 处理。","link":"/2019/10/09/Vue-js-3-0编译器compiler-core源码解析/"},{"title":"浏览器层合成与页面渲染优化","text":"作者：黄浩群 一个 CSS 属性引发的血案Web 页面性能是前端开发特别需要关注的重点，评判前端 Web 页面性能的指标有很多，页面的流畅度是其中的一种，如何让页面变得 “柔顺丝滑”，要讨论起来可就是个相当有料的话题了。之前开发移动端 H5 页面的时候，就遇到过一个有趣的性能问题 —— 某个卖场页面在 IOS 手机上出现了严重的卡顿，但在安卓机型下却表现得十分流畅。归纳一下在 iPhoneX 上测试的具体表现： 页面加载时存在明显的延迟，但通过代理抓到的网络请求耗时并不比 Android 的高； 页面滚动时会出现短暂的局部白屏，即丢帧。 根据这些表征情况不难推断出，应该是有什么东西在疯狂占用 CPU，卡住了渲染进程。 然而具体是什么东西，要问我我也并不知道。对于这种没法通过断点定位到的问题，恐怕只有用上祖师爷亲传的 “代码二分法” 才能制服得了了。一番艰苦排查之后，问题的根源终于聚焦到了下边这行 CSS 代码上： 1filter: blur(100px); 这行 CSS 代码用于实现一个高斯模糊，来构造一个优惠券模块的底部阴影。由于活动配置了多个优惠券，导致页面里存在多个设置了这个属性的 div 元素，而 IOS 手机的浏览器似乎对这个属性的渲染十分吃力（然而为何吃力的原因不得而知），进而导致渲染进程的 CPU 占用率过高，最终造成卡顿。 哦？CPU 忙不过来了？好办嘛！我给优惠券模块又加了这样一行代码，然后问题迎刃而解 …… 1will-change: transform; 你没看错，我也没写少，确实就是靠一行代码解决的。 认识它的人可能已经看出来了，大致原理其实很简单，这行代码能够开启 GPU 加速页面渲染，从而大大降低了 CPU 的负载压力，达到优化页面渲染性能的目的，不了解 CSS 硬件加速的可以看看这篇文章 Increase Your Site’s Performance with Hardware-Accelerated CSS 。 问题解决了，但是真的就这么完事了吗？本着 “拔树寻根” 的伟大原则，我把这个东西好好地研究了一番，才发现 GPU 加速其实没那么简单。 浏览器渲染流程在具体讨论原理之前，我们需要了解一下浏览器渲染流程的一些基本概念。浏览器渲染流程是个老生常谈的话题了，对于 “浏览器如何呈现一个页面的内容” 的这类问题，不少人都可以讲出一个相对完整的过程，从网络请求到浏览器解析，可以具体到很多的细节。除去网络资源获取的步骤，我们理解的 Web 页面的展示，一般可以分为 构建 DOM 树、构建渲染树、布局、绘制、渲染层合成 几个步骤。 构建 DOM 树：浏览器将 HTML 解析成树形结构的 DOM 树，一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候。 构建渲染树：浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树。 布局（Layout）：浏览器根据渲染树所体现的节点、各个节点的CSS定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流（Reflow）。 绘制（Paint）：遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘（Repaint）。实际上，绘制过程是在多个层上完成的，这些层我们称为渲染层（RenderLayer）。 渲染层合成（Composite）：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。 这是一个基本的浏览器从解析到绘制一个 Web 页面的过程，跟上边页面卡顿问题的解决方法相关的，主要是最后一个环节 —— 渲染层合成。 渲染层合成一、什么是渲染层合成在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。 这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。 对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。 二、浏览器的渲染原理从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化。 1、渲染对象（RenderObject）一个 DOM 节点对应了一个渲染对象，渲染对象依然维持着 DOM 树的树形结构。一个渲染对象知道如何绘制一个 DOM 节点的内容，它通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 DOM 节点。 2、渲染层（RenderLayer）这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。能够导致浏览器为其创建新的渲染层的，包括以下几类常见的情况： 根元素 document 有明确的定位属性（relative、fixed、sticky、absolute） opacity &lt; 1 有 CSS fliter 属性 有 CSS mask 属性 有 CSS mix-blend-mode 属性且值不为 normal 有 CSS transform 属性且值不为 none backface-visibility 属性为 hidden 有 CSS reflection 属性 有 CSS column-count 属性且值不为 auto或者有 CSS column-width 属性且值不为 auto 当前有对于 opacity、transform、fliter、backdrop-filter 应用动画 overflow 不为 visible DOM 节点和渲染对象是一一对应的，满足以上条件的渲染对象就能拥有独立的渲染层。当然这里的独立是不完全准确的，并不代表着它们完全独享了渲染层，由于不满足上述条件的渲染对象将会与其第一个拥有渲染层的父元素共用同一个渲染层，因此实际上，这些渲染对象会与它的部分子元素共用这个渲染层。 3、图形层（GraphicsLayer）GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。 所以 GraphicsLayer 是一个重要的渲染载体和工具，但它并不直接处理渲染层，而是处理合成层。 4、合成层（CompositingLayer）满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。 那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况： 3D transforms：translate3d、translateZ 等 video、canvas、iframe 等元素 通过 Element.animate() 实现的 opacity 动画转换 通过 СSS 动画实现的 opacity 动画转换 position: fixed 具有 will-change 属性 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition 因此，文首例子的解决方案，其实就是利用 will-change 属性，将 CPU 消耗高的渲染元素提升为一个新的合成层，才能开启 GPU 加速的，因此你也可以使用 transform: translateZ(0) 来解决这个问题。 这里值得注意的是，不少人会将这些合成层的条件和渲染层产生的条件混淆，这两种条件发生在两个不同的层处理环节，是完全不一样的。 另外，有些文章会把 CSS Filter 也列为影响 Composite 的因素之一，然而我验证后发现并没有效果。 三、隐式合成上边提到，满足某些显性的特殊条件时，渲染层会被浏览器提升为合成层。除此之外，在浏览器的 Composite 阶段，还存在一种隐式合成，部分渲染层在一些特定场景下，会被默认提升为合成层。 对于隐式合成，CSS GPU Animation 中是这么描述的： This is called implicit compositing: One or more non-composited elements that should appear above a composited one in the stacking order are promoted to composite layers.(一个或多个非合成元素应出现在堆叠顺序上的合成元素之上，被提升到合成层。) 这句话可能不好理解，它其实是在描述一个交叠问题（overlap）。举个例子说明一下： 两个 absolute 定位的 div 在屏幕上交叠了，根据 z-index 的关系，其中一个 div 就会”盖在“了另外一个上边。 这个时候，如果处于下方的 div 被加上了 CSS 属性：transform: translateZ(0)，就会被浏览器提升为合成层。提升后的合成层位于 Document 上方，假如没有隐式合成，原本应该处于上方的 div 就依然还是跟 Document 共用一个 GraphicsLayer，层级反而降了，就出现了元素交叠关系错乱的问题。 所以为了纠正错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。 四、层爆炸和层压缩1、层爆炸从上边的研究中我们可以发现，一些产生合成层的原因太过于隐蔽了，尤其是隐式合成。在平时的开发过程中，我们很少会去关注层合成的问题，很容易就产生一些不在预期范围内的合成层，当这些不符合预期的合成层达到一定量级时，就会变成层爆炸。 层爆炸会占用 GPU 和大量的内存资源，严重损耗页面性能，因此盲目地使用 GPU 加速，结果有可能会是适得其反。CSS3硬件加速也有坑 这篇文章提供了一个很有趣的 DEMO，这个 DEMO 页面中包含了一个 h1 标题，它对 transform 应用了 animation 动画，进而导致被放到了合成层中渲染。由于 animation transform 的特殊性（动态交叠不确定），隐式合成在不需要交叠的情况下也能发生，就导致了页面中所有 z-index 高于它的节点所对应的渲染层全部提升为合成层，最终让这个页面整整产生了几千个合成层。 消除隐式合成就是要消除元素交叠，拿这个 DEMO 来说，我们只需要给 h1 标题的 z-index 属性设置一个较高的数值，就能让它高于页面中其他元素，自然也就没有合成层提升的必要了。点击 DEMO 中的复选按钮就可以给 h1 标题加上一个较大的 z-index，前后效果对比十分明显。 2、层压缩当然了，面对这种问题，浏览器也有相应的应对策略，如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。这句话不好理解，具体可以看看这个例子： 还是之前的模型，只不过这次不同的是，有四个 absolute 定位的 div 在屏幕内发生了交叠。此时处于最下方的 div 在加上了 CSS 属性 transform: translateZ(0) 后被浏览器提升为合成层，如果按照隐式合成的原理，盖在它上边的 div 会提升为一个新的合成层，第三个 div 又盖在了第二个上，自然也会被提升为合成层，第四个也同理。这样一来，岂不是就会产生四个合成层了？ 然而事实并不是这样的，浏览器的层压缩机制，会将隐式合成的多个渲染层压缩到同一个 GraphicsLayer 中进行渲染，也就是说，上方的三个 div 最终会处于同一个合成层中，这就是浏览器的层压缩。 当然了，浏览器的自动层压缩并不是万能的，有很多特定情况下，浏览器是无法进行层压缩的，无线性能优化：Composite 这篇文章列举了许多详细的场景。 基于层合成的页面渲染优化一、层合成的得与失层合成是一个相对复杂的浏览器特性，为什么我们需要关注这么底层又难理解的东西呢？那是因为渲染层提升为合成层之后，会给我们带来不少好处： 合成层的位图，会交由 GPU 合成，比 CPU 处理要快得多； 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层； 元素提升为合成层后，transform 和 opacity 才不会触发 repaint，如果不是合成层，则其依然会触发 repaint。 当然了，利弊是相对和共存的，层合成也存在一些缺点，这很多时候也成为了我们网页性能问题的根源所在： 绘制的图层必须传输到 GPU，这些层的数量和大小达到一定量级后，可能会导致传输非常慢，进而导致一些低端和中端设备上出现闪烁； 隐式合成容易产生过量的合成层，每个合成层都占用额外的内存，而内存是移动设备上的宝贵资源，过多使用内存可能会导致浏览器崩溃，让性能优化适得其反。 二、Chrome Devtools 如何查看合成层层合成的特性给我们提供了一个利用终端硬件能力来优化页面性能的方式，对于一些重交互、重动画的页面，合理地利用层合成可以让页面的渲染效率得到极大提升，改善交互体验。而我们需要关注的是如何规避层合成对页面造成的负面影响，或者换个说法来讲，更多时候是如何权衡利害，合理组织页面的合成层，这就要求我们事先要对页面的层合成情况有一个详细的了解。Chrome Devtools 给我们提供了一些工具，可以方便的查看页面的合成层情况。 首先是看看页面的渲染情况，以一个栏目页为例，点击 More tools -&gt; Rendering，选择 Layer borders，你就能看到页面中的合成层都带上了黄色边框。 这还不够，我们还需要更加详尽的层合成情况，点击 More tools -&gt; Layers，你可以看到像这样的一个视图： 左侧列出了所有提升为独立合成层的元素，右侧则是一个整体合成层边界视图，以及选定合成层的详细情况，包括以下几个比较关键的信息： Size：合成层的大小，其实也就是对应元素的尺寸； Compositing Reasons：形成复合层原因，这是最关键的，也是我们分析问题的突破口，比如图中的合成层产生的原因就是交叠问题； Memory estimate：内存占用估算； Paint count：绘制次数； Slow scroll regions：缓慢滚动区域。 可以看出我们在不经意间就已经制造出了很多意料之外的合成层，这些没有实际意义的合成层都是可以被优化的。 三、一些优化建议1、动画使用 transform 实现对于一些体验要求较高的关键动画，比如一些交互复杂的玩法页面，存在持续变化位置的 animation 元素，我们最好是使用 transform 来实现而不是通过改变 left/top 的方式。这样做的原因是，如果使用 left/top 来实现位置变化，animation 节点和 Document 将被放到了同一个 GraphicsLayer 中进行渲染，持续的动画效果将导致整个 Document 不断地执行重绘，而使用 transform 的话，能够让 animation 节点被放置到一个独立合成层中进行渲染绘制，动画发生时不会影响到其它层。并且另一方面，动画会完全运行在 GPU 上，相比起 CPU 处理图层后再发送给显卡进行显示绘制来说，这样的动画往往更加流畅。 2、减少隐式合成虽然隐式合成从根本上来说是为了保证正确的图层重叠顺序，但具体到实际开发中，隐式合成很容易就导致一些无意义的合成层生成，归根结底其实就要求我们在开发时约束自己的布局习惯，避免踩坑。 比如上边提到的栏目页面，就因为平时开发的不注意造成页面生成了过多的合成层，我在试图查看页面合成层情况的时候，在 PC 上已经能明显感到卡顿了。利用 Chrome Devtools 分析之后不难发现，页面里边存在的一个带动画 transform 的 button 按钮，提升为了合成层，动画交叠的不确定性使得页面内其他 z-index 大于它但其实并没有交叠的节点也都全部提升为了合成层（这个原因真的好坑）。 这个时候我们只需要把这个动画节点的 z-index 属性值设置得大一些，让层叠顺序高过于页面其他无关节点就行。当然并不是盲目地设置 z-index 就能避免，有时候 z-index 也还是会导致隐式合成，这个时候可以试着调整一下文档中节点的先后顺序直接让后边的节点来覆盖前边的节点，而不用 z-index 来调整重叠关系。方法不是唯一的，具体方式还是得根据不同的页面具体分析。 改善后的页面效果如下，可以看到相比优化前，我们消除了很多无意义的合成层。 3、减小合成层的尺寸举个简单的例子，分别画两个尺寸一样的 div，但实现方式有点差别：一个直接设置尺寸 100x100，另一个设置尺寸 10x10，然后通过 scale 放大 10 倍，并且我们让这两个 div 都提升为合成层： 123456789101112131415161718192021222324252627&lt;style&gt; .bottom, .top { position: absolute; will-change: transform; } .bottom { width: 100px; height: 100px; top: 20px; left: 20px; z-index: 3; background: rosybrown; } .top { width: 10px; height: 10px; transform: scale(10); top: 200px; left: 200px; z-index: 5; background: indianred; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt; &lt;div class=\"top\"&gt;&lt;/div&gt;&lt;/body&gt; 利用 Chrome Devtools 查看这两个合成层的内存占用后发现，.bottom 内存占用是 39.1 KB，而 .top 是 400 B，差距十分明显。这是因为 .top 是合成层，transform 位于的 Composite 阶段，现在完全在 GPU 上执行。因此对于一些纯色图层来说，我们可以使用 width 和 height 属性减小合成层的物理尺寸，然后再用 transform: scale(…) 放大，这样一来可以极大地减少层合成带来的内存消耗。 参考文章 CSS3硬件加速也有坑无线性能优化：CompositeCSS GPU Animation详谈层合成","link":"/2019/10/15/浏览器层合成与页面渲染优化/"},{"title":"换种方式读源码：如何实现一个简易版的Mocha","text":"作者：黄浩群 前言Mocha 是目前最流行的 JavaScript 测试框架，理解 Mocha 的内部实现原理有助于我们更深入地了解和学习自动化测试。然而阅读源码一直是个让人望而生畏的过程，大量的高级写法经常是晦涩难懂，大量的边缘情况的处理也十分影响对核心代码的理解，以至于写一篇源码解析过后往往是连自己都看不懂。所以，这次我们不生啃 Mocha 源码，换个方式，从零开始一步步实现一个简易版的 Mocha。 我们将实现什么？ 实现 Mocha 框架的 BDD 风格测试，能通过 describe/it 函数定义一组或单个的测试用例； 实现 Mocha 框架的 Hook 机制，包括 before、after、beforeEach、afterEach； 实现简单格式的测试报告输出。 Mocha 的 BDD 测试 Mocha 支持 BDD/TDD 等多种测试风格，默认使用 BDD 接口。BDD（行为驱动开发）是一种以需求为导向的敏捷开发方法，相比主张”测试先行“的 TDD（测试驱动开发）而言，它强调”需求先行“，从一个更加宏观的角度去关注包括开发、QA、需求方在内的多方利益相关者的协作关系，力求让开发者“做正确的事“。在 Mocha 中，一个简单的 BDD 式测试用例如下： 12345678910111213141516describe('Array', function() { describe('#indexOf()', function() { before(function() { // ... }); it('should return -1 when not present', function() { // ... }); it('should return the index when present', function() { // ... }); after(function() { // ... }); });}); Mocha 的 BDD 测试主要包括以下几个 API： describe/context：行为描述，代表一个测试块，是一组测试单元的集合； it/specify：描述了一个测试单元，是最小的测试单位； before：Hook 函数，在执行该测试块之前执行； after：Hook 函数，在执行该测试块之后执行； beforeEach：Hook 函数，在执行该测试块中每个测试单元之前执行； afterEach：Hook 函数，在执行该测试块中每个测试单元之后执行。 开始话不多说，我们直接开始。 一、目录设计新建一个项目，命名为 simple-mocha。目录结构如下： 1234567├─ mocha/│ ├─ index.js│ ├─ src/│ ├─ interfaces/│ └─ reporters/├─ test/└─ package.json 先对这个目录结构作简单解释： mocha/：存放我们即将实现的 simple-mocha 的源代码 mocha/index.js：simple-mocha 入口 mocha/src/：simple-mocha 核心代码 mocha/interfaces/：存放各类风格的测试接口，如 BDD mocha/reporters/：存放用于输出测试报告的各种 reporter，如 SPEC test/：存放我们编写的测试用例 package.json 其中 package.json 内容如下： 1234567891011{ \"name\": \"simple-mocha\", \"version\": \"1.0.0\", \"description\": \"a simple mocha for understanding the mechanism of mocha\", \"main\": \"\", \"scripts\": { \"test\": \"node mocha/index.js\" }, \"author\": \"hankle\", \"license\": \"ISC\"} 执行 npm test 就可以启动执行测试用例。 二、模块设计Mocha 的 BDD 测试应该是一个”先定义后执行“的过程，这样才能保证其 Hook 机制正确执行，而与代码编写顺序无关，因此我们把整个测试流程分为两个阶段：收集测试用例（定义）和执行测试用例（执行）。我们构造了一个 Mocha 类来完成这两个过程，同时这个类也负责统筹协调其他各模块的执行，因此它是整个测试流程的核心。 1234567// mocha/src/mocha.jsclass Mocha { constructor() {} run() {}}module.exports = Mocha; 12345// mocha/index.jsconst Mocha = require('./src/mocha');const mocha = new Mocha();mocha.run(); 另一方面我们知道，describe 函数描述了一个测试集合，这个测试集合除包括若干测试单元外，还拥有着一些自身的 Hook 函数，维护了一套严格的执行流。it 函数描述了一个测试单元，它需要执行测试用例，并且接收断言结果。这是两个逻辑复杂的单元，同时需要维护一定的内部状态，我们用两个类（Suite/Test）来分别构造它们。此外我们可以看出，BDD 风格的测试用例是一个典型的树形结构，describe 定义的测试块可以包含测试块，也可以包含 it 定义的测试单元。所以 Suite/Test 实例还将作为节点，构造出一棵 suite-test 树。比如下边这个测试用例： 12345678910111213141516describe('Array', function () { describe('#indexOf()', function () { it('should return -1 when not present', function () { // ... }) it('should return the index when present', function () { // ... }) }) describe('#every()', function () { it('should return true when all items are satisfied', function () { // ... }) })}) 由它构造出来的 suite-test 树是这样的： 1234567891011 ┌────────────────────────────────────────────────────────┐ ┌─┤ test:\"should return -1 when not present\" │ ┌────────────────────┐ │ └────────────────────────────────────────────────────────┘ ┌─┤ suite:\"#indexOf()\" ├─┤ │ └────────────────────┘ │ ┌────────────────────────────────────────────────────────┐┌───────────────┐ │ └─┤ test:\"should return the index when present\" ││ suite:\"Array\" ├─┤ └────────────────────────────────────────────────────────┘└───────────────┘ │ │ ┌────────────────────┐ ┌────────────────────────────────────────────────────────┐ └─┤ suite:\"#every()\" ├───┤ test:\"should return true when all items are satisfied\" │ └────────────────────┘ └────────────────────────────────────────────────────────┘ 因此，Suite/Test 除了要能够表示 describe/it 之外，还应该能够诠释这种树状结构的父子级关系： 12345678910111213141516171819// mocha/src/suite.jsclass Suite { constructor(props) { this.title = props.title; // Suite名称，即describe传入的第一个参数 this.suites = []; // 子级suite this.tests = []; // 包含的test this.parent = props.parent; // 父suite this._beforeAll = []; // before hook this._afterAll = []; // after hook this._beforeEach = []; // beforeEach hook this._afterEach = []; // afterEach hook if (props.parent instanceof Suite) { props.parent.suites.push(this); } }}module.exports = Suite; 123456789// mocha/src/test.jsclass Test { constructor(props) { this.title = props.title; // Test名称，即it传入的第一个参数 this.fn = props.fn; // Test的执行函数，即it传入的第二个参数 }}module.exports = Test; 我们完善一下目录结构： 12345678910111213141516├─ mocha/│ ├─ index.js│ ├─ src/│ │ ├─ mocha.js│ │ ├─ runner.js│ │ ├─ suite.js│ │ ├─ test.js│ │ └─ utils.js│ ├─ interfaces/│ │ ├─ bdd.js│ │ └─ index.js│ └─ reporters/│ ├─ spec.js│ └─ index.js├─ test/└─ package.json 考虑到执行测试用例的过程较为复杂，我们把这块逻辑单独抽离到 runner.js，它将在执行阶段负责调度 suite 和 test 节点并运行测试用例，后续会详细说到。 三、收集测试用例收集测试用例环节首先需要创建一个 suite 根节点，并把 API 挂载到全局，然后再执行测试用例文件 *.spec.js 进行用例收集，最终将生成一棵与之结构对应的 suite-test 树。 1、suite 根节点我们先创建一个 suite 实例，作为整棵 suite-test 树的根节点，同时它也是我们收集和执行测试用例的起点。 12345678910111213// mocha/src/mocha.jsconst Suite = require('./suite');class Mocha { constructor() { // 创建一个suite根节点 this.rootSuite = new Suite({ title: '', parent: null }); } // ...} 2、BDD API 的全局挂载在我们使用 Mocha 编写测试用例时，我们不需要手动引入 Mocha 提供的任何模块，就能够直接使用 describe、it 等一系列 API。那怎么样才能实现这一点呢？很简单，把 API 挂载到 global 对象上就行。因此，我们需要在执行测试用例文件之前，先将 BDD 风格的 API 全部作全局挂载。 1234567891011121314// mocha/src/mocha.js// ...const interfaces = require('../interfaces');class Mocha { constructor() { // 创建一个根suite // ... // 使用bdd测试风格，将API挂载到global对象上 const ui = 'bdd'; interfaces[ui](global, this.rootSuite); } // ...} 12// mocha/interfaces/index.jsmodule.exports.bdd = require('./bdd'); 123456789// mocha/interfaces/bdd.jsmodule.exports = function (context, root) { context.describe = context.context = function (title, fn) {} context.it = context.specify = function (title, fn) {} context.before = function (fn) {} context.after = function (fn) {} context.beforeEach = function (fn) {} context.afterEach = function (fn) {}} 3、BDD API 的具体实现我们先看看 describe 函数怎么实现。 describe 传入的 fn 参数是一个函数，它描述了一个测试块，测试块包含了若干子测试块和测试单元。因此我们需要执行 describe 传入的 fn 函数，才能够获知到它的子层结构，从而构造出一棵完整的 suite-test 树。而逐层执行 describe 的 fn 函数，本质上就是一个深度优先遍历的过程，因此我们需要利用一个栈（stack）来记录 suite 根节点到当前节点的路径。 1234567891011121314151617181920// mocha/interfaces/bdd.jsconst Suite = require('../src/suite');const Test = require('../src/test');module.exports = function (context, root) { // 记录 suite 根节点到当前节点的路径 const suites = [root]; context.describe = context.context = function (title, fn) { const parent = suites[0]; const suite = new Suite({ title, parent }); suites.unshift(suite); fn.call(suite); suites.shift(suite); }} 每次处理一个 describe 时，我们都会构建一个 Suite 实例来表示它，并且在执行 fn 前入栈，执行 fn 后出栈，保证 suites[0] 始终是当前正在处理的 suite 节点。利用这个栈列表，我们可以在遍历过程中构建出 suite 的树级关系。 同样的，其他 API 也都需要依赖这个栈列表来实现： 123456789101112131415161718192021222324252627282930313233343536// mocha/interfaces/bdd.jsmodule.exports = function (context, root) { // 记录 suite 根节点到当前节点的路径 const suites = [root]; // context.describe = ... context.it = context.specify = function (title, fn) { const parent = suites[0]; const test = new Test({ title, fn }); parent.tests.push(test); } context.before = function (fn) { const cur = suites[0]; cur._beforeAll.push(fn); } context.after = function (fn) { const cur = suites[0]; cur._afterAll.push(fn); } context.beforeEach = function (fn) { const cur = suites[0]; cur._beforeEach.push(fn); } context.afterEach = function (fn) { const cur = suites[0]; cur._afterEach.push(fn); }} 4、执行测试用例文件一切准备就绪，我们开始 require 测试用例文件。要完成这个步骤，我们需要一个函数来协助完成，它负责解析 test 路径下的资源，返回一个文件列表，并且能够支持 test 路径为文件和为目录的两种情况。 1234567891011121314151617181920212223242526272829303132333435// mocha/src/utils.jsconst path = require('path');const fs = require('fs');module.exports.lookupFiles = function lookupFiles(filepath) { let stat; // 假设路径是文件 try { stat = fs.statSync(`${filepath}.js`); if (stat.isFile()) { // 确实是文件，直接以数组形式返回 return [filepath]; } } catch(e) {} // 假设路径是目录 let files = []; // 存放目录下的所有文件 fs.readdirSync(filepath).forEach(function(dirent) { let pathname = path.join(filepath, dirent); try { stat = fs.statSync(pathname); if (stat.isDirectory()) { // 是目录，进一步递归 files = files.concat(lookupFiles(pathname)); } else if (stat.isFile()) { // 是文件，补充到待返回的文件列表中 files.push(pathname); } } catch(e) {} }); return files;} 1234567891011121314151617181920// mocha/src/mocha.js// ...const path = require('path');const utils = require('./utils');class Mocha { constructor() { // 创建一个根suite // ... // 使用bdd测试风格，将API挂载到global对象上 // ... // 执行测试用例文件，构建suite-test树 const spec = path.resolve(__dirname, '../../test'); const files = utils.lookupFiles(spec); files.forEach(file =&gt; { require(file); }); } // ...} 四、执行测试用例在这个环节中，我们需要通过遍历 suite-test 树来递归执行 suite 节点和 test 节点，并同步地输出测试报告。 1、异步执行Mocha 的测试用例和 Hook 函数是支持异步执行的。异步执行的写法有两种，一种是函数返回值为一个 promise 对象，另一种是函数接收一个入参 done，并由开发者在异步代码中手动调用 done(error) 来向 Mocha 传递断言结果。所以，在执行测试用例之前，我们需要一个包装函数，将开发者传入的函数 promise 化： 123456789101112131415161718192021222324// mocha/src/utils.js// ...module.exports.adaptPromise = function(fn) { return () =&gt; new Promise(resolve =&gt; { if (fn.length == 0) { // 不使用参数 done try { const ret = fn(); // 判断是否返回promise if (ret instanceof Promise) { return ret.then(resolve, resolve); } else { resolve(); } } catch (error) { resolve(error); } } else { // 使用参数 done function done(error) { resolve(error); } fn(done); } })} 这个工具函数传入一个函数 fn 并返回另外一个函数，执行返回的函数能够以 promise 的形式去运行 fn。这样一来，我们需要稍微修改一下之前的代码： 1234567891011121314151617181920212223242526272829303132333435// mocha/interfaces/bdd.js// ...const { adaptPromise } = require('../src/utils');module.exports = function (context, root) { // ... context.it = context.specify = function (title, fn) { // ... const test = new Test({ title, fn: adaptPromise(fn) }); // ... } context.before = function (fn) { // ... cur._beforeAll.push(adaptPromise(fn)); } context.after = function (fn) { // ... cur._afterAll.push(adaptPromise(fn)); } context.beforeEach = function (fn) { // ... cur._beforeEach.push(adaptPromise(fn)); } context.afterEach = function (fn) { // ... cur._afterEach.push(adaptPromise(fn)); }} 2、测试用例执行器执行测试用例需要调度 suite 和 test 节点，因此我们需要一个执行器（runner）来统一负责执行过程。这是执行阶段的核心，我们先直接贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// mocha/src/runner.jsconst EventEmitter = require('events').EventEmitter;// 监听事件的标识const constants = { EVENT_RUN_BEGIN: 'EVENT_RUN_BEGIN', // 执行流程开始 EVENT_RUN_END: 'EVENT_RUN_END', // 执行流程结束 EVENT_SUITE_BEGIN: 'EVENT_SUITE_BEGIN', // 执行suite开始 EVENT_SUITE_END: 'EVENT_SUITE_END', // 执行suite开始 EVENT_FAIL: 'EVENT_FAIL', // 执行用例失败 EVENT_PASS: 'EVENT_PASS' // 执行用例成功}class Runner extends EventEmitter { constructor() { super(); // 记录 suite 根节点到当前节点的路径 this.suites = []; } /* * 主入口 */ async run(root) { this.emit(constants.EVENT_RUN_BEGIN); await this.runSuite(root); this.emit(constants.EVENT_RUN_END); } /* * 执行suite */ async runSuite(suite) { // suite执行开始 this.emit(constants.EVENT_SUITE_BEGIN, suite); // 1）执行before钩子函数 if (suite._beforeAll.length) { for (const fn of suite._beforeAll) { const result = await fn(); if (result instanceof Error) { this.emit(constants.EVENT_FAIL, `\"before all\" hook in ${suite.title}: ${result.message}`); // suite执行结束 this.emit(constants.EVENT_SUITE_END); return; } } } // 路径栈推入当前节点 this.suites.unshift(suite); // 2）执行test if (suite.tests.length) { for (const test of suite.tests) { await this.runTest(test); } } // 3）执行子级suite if (suite.suites.length) { for (const child of suite.suites) { await this.runSuite(child); } } // 路径栈推出当前节点 this.suites.shift(suite); // 4）执行after钩子函数 if (suite._afterAll.length) { for (const fn of suite._afterAll) { const result = await fn(); if (result instanceof Error) { this.emit(constants.EVENT_FAIL, `\"after all\" hook in ${suite.title}: ${result.message}`); // suite执行结束 this.emit(constants.EVENT_SUITE_END); return; } } } // suite结束 this.emit(constants.EVENT_SUITE_END); } /* * 执行suite */ async runTest(test) { // 1）由suite根节点向当前suite节点，依次执行beforeEach钩子函数 const _beforeEach = [].concat(this.suites).reverse().reduce((list, suite) =&gt; list.concat(suite._beforeEach), []); if (_beforeEach.length) { for (const fn of _beforeEach) { const result = await fn(); if (result instanceof Error) { return this.emit(constants.EVENT_FAIL, `\"before each\" hook for ${test.title}: ${result.message}`) } } } // 2）执行测试用例 const result = await test.fn(); if (result instanceof Error) { return this.emit(constants.EVENT_FAIL, `${test.title}`); } else { this.emit(constants.EVENT_PASS, `${test.title}`); } // 3）由当前suite节点向suite根节点，依次执行afterEach钩子函数 const _afterEach = [].concat(this.suites).reduce((list, suite) =&gt; list.concat(suite._afterEach), []); if (_afterEach.length) { for (const fn of _afterEach) { const result = await fn(); if (result instanceof Error) { return this.emit(constants.EVENT_FAIL, `\"after each\" hook for ${test.title}: ${result.message}`) } } } }}Runner.constants = constants;module.exports = Runner 代码很长，我们稍微捋一下。 首先，我们构造一个 Runner 类，利用两个 async 方法来完成对 suite-test 树的遍历： runSuite ：负责执行 suite 节点。它不仅需要调用 runTest 执行该 suite 节点上的若干 test 节点，还需要调用 runSuite 执行下一级的若干 suite 节点来实现遍历，同时，before/after 也将在这里得到调用。执行顺序依次是：before -&gt; runTest -&gt; runSuite -&gt; after。 runTest ：负责执行 test 节点，主要是执行该 test 对象上定义的测试用例。另外，beforeEach/afterEach 的执行有一个类似浏览器事件捕获和冒泡的过程，我们需要沿节点路径向当前 suite 节点方向和向 suite 根节点方向分别执行各 suite 的 beforeEach/afterEach 钩子函数。执行顺序依次是：beforeEach -&gt; run test case -&gt; afterEach。 在遍历过程中，我们依然是利用一个栈列表来维护 suite 根节点到当前节点的路径。同时，这两个流程都用 async/await 写法来组织，保证所有任务在异步场景下依然是按序执行的。 其次，测试结论是“边执行边输出”的。为了在执行过程中能向 reporter 实时通知执行结果和执行状态，我们让 Runner 类继承自 EventEmitter 类，使其具备订阅/发布事件的能力，这个后续会细讲。 最后，我们在 Mocha 实例的 run 方法中去实例化 Runner 并调用它： 1234567891011// mocha/src/mocha.js// ...const Runner = require('./runner');class Mocha { // ... run() { const runner = new Runner(); runner.run(this.rootSuite); }} 3、输出测试报告reporter 负责测试报告输出，这个过程是在执行测试用例的过程中同步进行的，因此我们利用 EventEmitter 让 reporter 和 runner 保持通信。在 runner 中我们已经在各个关键节点都作了 event emit，所以我们只需要在 reporter 中加上相应的事件监听即可： 12// mocha/reporters/index.jsmodule.exports.spec = require('./spec'); 1234567891011121314151617181920212223// mocha/reporters/spec.jsconst constants = require('../src/runner').constants;module.exports = function (runner) { // 执行开始 runner.on(constants.EVENT_RUN_BEGIN, function() {}); // suite执行开始 runner.on(constants.EVENT_SUITE_BEGIN, function(suite) {}); // suite执行结束 runner.on(constants.EVENT_SUITE_END, function() {}); // 用例通过 runner.on(constants.EVENT_PASS, function(title) {}); // 用例失败 runner.on(constants.EVENT_FAIL, function(title) {}); // 执行结束 runner.once(constants.EVENT_RUN_END, function() {});} Mocha 类中引入 reporter，执行事件订阅，就能让 runner 将测试的状态结果实时推送给 reporter 了： 1234567891011// mocha/src/mocha.jsconst reporters = require('../reporters');// ...class Mocha { // ... run() { const runner = new Runner(); reporters['spec'](runner); runner.run(this.rootSuite); }} reporter 中可以任意构造你想要的报告样式输出，例如这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// mocha/reporters/spec.jsconst constants = require('../src/runner').constants;const colors = { pass: 90, fail: 31, green: 32,}function color(type, str) { return '\\u001b[' + colors[type] + 'm' + str + '\\u001b[0m';}module.exports = function (runner) { let indents = 0; let passes = 0; let failures = 0; function indent(i = 0) { return Array(indents + i).join(' '); } // 执行开始 runner.on(constants.EVENT_RUN_BEGIN, function() { console.log(); }); // suite执行开始 runner.on(constants.EVENT_SUITE_BEGIN, function(suite) { console.log(); ++indents; console.log(indent(), suite.title); }); // suite执行结束 runner.on(constants.EVENT_SUITE_END, function() { --indents; if (indents == 1) console.log(); }); // 用例通过 runner.on(constants.EVENT_PASS, function(title) { passes++; const fmt = indent(1) + color('green', ' ✓') + color('pass', ' %s'); console.log(fmt, title); }); // 用例失败 runner.on(constants.EVENT_FAIL, function(title) { failures++; const fmt = indent(1) + color('fail', ' × %s'); console.log(fmt, title); }); // 执行结束 runner.once(constants.EVENT_RUN_END, function() { console.log(color('green', ' %d passing'), passes); console.log(color('fail', ' %d failing'), failures); });} 五、验证到这里，我们的 simple-mocha 就基本完成了，我们可以编写一个测试用例来简单验证一下： 12345678910111213141516171819202122232425262728// test/test.spec.jsconst assert = require('assert');describe('Array', function () { describe('#indexOf()', function () { it('should return -1 when not present', function () { assert.equal(-1, [1, 2, 3].indexOf(4)) }) it('should return the index when present', function () { assert.equal(-1, [1, 2, 3].indexOf(3)) }) }) describe('#every()', function () { it('should return true when all items are satisfied', function () { assert.equal(true, [1, 2, 3].every(item =&gt; !isNaN(item))) }) })})describe('Srting', function () { describe('#replace', function () { it('should return a string that has been replaced', function () { assert.equal('hey Hankle', 'hey Densy'.replace('Densy', 'Hankle')) }) })}) 这里我们用 node 内置的 assert 模块来执行断言测试。下边是执行结果： 123456789101112131415161718npm test&gt; simple-mocha@1.0.0 test /Documents/simple-mocha&gt; node mocha Array #indexOf() ✓ should return -1 when not present × should return the index when present #every() ✓ should return true when all items are satisfied String #replace ✓ should return a string that has been replaced 3 passing 1 failing 测试用例执行成功。附上完整的流程图： 结尾如果你看到了这里，看完并看懂了上边实现 simple-mocha 的整个流程，那么很高兴地告诉你，你已经掌握了 Mocha 最核心的运行机理。simple-mocha 的整个实现过程其实就是 Mocha 实现的一个简化。而为了让大家在看完这篇文章后再去阅读 Mocha 源码时能够更快速地理解，我在简化和浅化 Mocha 实现流程的同时，也尽可能地保留了其中的一些命名和实现细节。有差别的地方，如执行测试用例环节，Mocha 源码利用了一个复杂的 Hook 机制来实现异步测试的依序执行，而我为了方便理解，用 async/await 来替代实现。当然这不是说 Mocha 实现得繁琐，在更加复杂的测试场景下，这套 Hook 机制是十分必要的。所以，这篇文章仅仅希望能够帮助我们攻克 Mocha 源码阅读的第一道陡坡，而要理解 Mocha 的精髓，光看这篇文章是远远不够的，还得深入阅读 Mocha 源码。 参考文章 Mocha官方文档BDD和Mocha框架","link":"/2019/10/09/换种方式读源码：如何实现一个简易版的Mocha/"},{"title":"记一次Node.js直出服务的性能优化","text":"作者：肖睦群、李刚松 一.问题背景MPM（Market Page Maker）是京东社交电商部的组件化的页面可视化搭建平台，于2016年9月份上线，平均每周150+个页面，目前已经成为社交电商部的一个核心系统。系统使用Vue.js作为组件化的基础框架,并于2017年5月份上线了Node.js直出服务。MPM的页面会被运营同学拿到各种渠道投放，整体流量很不稳定，对于流量的暴涨情况要能够及时处理，这对于开发同学来说是一个比较烦的工作。 前几天突然收到告警信息，由于运营同学将某个MPM活动页面投放了外部广告，直出服务流量大涨，服务器CPU使用率达到了80%以上，于是立马申请扩容，问题虽解决，但是留给了我们一个问题：直出服务能否优化，这次量级的流量进来之后，是否可以稳定支撑而不需要扩容？ 二.分析方法及问题点由于本次告警问题主要是流量暴涨导致的CPU使用率过大，我们本次重点优化服务的CPU消耗性能。分析CPU消耗的方法有多种,我们选择其中操作比较简单的v8-profiler方案：安装NPM包v8-profiler，在直出服务中添加监控代码，打包发布到预发布环境进行压测，收集监控数据再进行分析。监控代码如下： 12345678910111213141516const profiler = require('v8-profiler');const fs = require('fs');(function cpuProf() { setTimeout(function () { console.log('开始收集CPU数据'); profiler.startProfiling('CPU profile'); setTimeout(function () { const profile = profiler.stopProfiling(); profile.export(function (err, result) { fs.writeFileSync('profile.json', result); profile.delete(); console.log('CPU数据收集完成'); }); }, 1000 * 60 * 5);//监控数据采集5分钟 }, 1000);})(); 上述代码会采集服务端5分钟的CPU消耗数据，并生成一个JSON文件，将此文件下载到本地后，导入到在线分析网址https://www.speedscope.app/ （或者用Chrome DevTool也可以），可以看到火焰图如下： 从火焰图可以看到函数的调用栈，从上而下就是调用栈，其中横条长度越长代表这占用cpu的时间越长。如果某个横条很长，但是下面又没有很细小的子调用，一般就表示该调用消耗时间比较长，可以考虑做优化。从图中我们可以看到，消耗性能的主要有几个地方：1）replace函数2）compile函数3）parse函数4）vue渲染 为了方便后文的分析，我们先了解一下直出服务的处理过程： 步骤 处理流程 资源消耗类型 备注 1 服务收到请求，解析页面参数 CPU计算 2 从Redis中读取页面数据(PageData) 网络IO PageData包括页面的各种配置信息，如页面头尾模板、页面楼层信息、身份判断要求、组件元数据等 3 解析PageData CPU计算 4 组装后端请求参数 CPU计算 5 发起后端请求并等待返回 网络IO 6 解析后端接口返回的JSON数据 CPU计算 7 页面模板构造 CPU计算 由于存在用户身份判断（如某些组件仅对新人可见）、楼层BI等原因，组件的容器是动态构造的 8 组件渲染 CPU计算 此处的组件渲染是Vue组件的服务端渲染 9 吐出页面HTML 网络IO 三.replace函数调用优化分析具体的replace函数调用之前，我们先详细分析一下上面表格的第7步:页面模板构造。 1.页面模板构造由于存在用户身份判断（如某些组件仅对新人或者VIP用户可见）、楼层BI（每个用户展示的楼层顺序都不一样）等原因，相同页面对于不同的用户展示的组件数量、顺序都是不一样（即千人千面），因此页面的模板是基于各个组件的模板动态构造的。为方便对组件进行操作，每个组件都有一个div容器，容器构造很简单，示例代码如下： 1234&lt;div id='com_1001'&gt;__vue_com_1001_replace__&lt;/div&gt;&lt;div id='com_1002'&gt;__vue_com_1002_replace__&lt;/div&gt;&lt;div id='com_1003'&gt;__vue_com_1003_replace__&lt;/div&gt;&lt;div id='com_1004'&gt;__vue_com_1004_replace__&lt;/div&gt; 其中vue_com_1001_replace这种是占位符，需要用相应位置的组件的实际模板来替换。但是这里有个问题，Vue渲染的时候，使用Render Function进行渲染的，并不是普通的字符串模板或者Vue模板。下面是一段模板编译后的Render Function： 1_c('commontag',{ref:\"__uid__replace__str__\",attrs:{\"uid\":\"__uid__replace__str__\",\"params\":params___uid__replace__str__},inlineTemplate:{render:function(){with(this){return _c('div',[(true)?[(params.transparent != 1)?_c('div',{staticClass:\"vueSeparator\",style:({'background-color':params.color, height: params.height + 'px'})}):_c('div',{staticClass:\"vueSeparator\",style:({height: params.height + 'px'})})]:_e()],2)}},staticRenderFns:[]}}) 若使用的是Vue模板，则会在运行时做一次编译，编译为Render Function，比较耗性能，因此官方推荐的做法是在构建时预编译，并且运行时使用不包含编译函数的精简版。目前MPM每个组件存储到Redis中的也是Render Function，而不是原始的Vue模板。所以现在的问题是，已知子组件编译后的Render Function，并且知道各个组件的DOM结构形式的容器，能否构造出父组件的Render Function？ 答案当然是可以：可以通过字符串操作，构造出父组件的Render Function！ 我们以下面这段代码为例，看看构造过程（为了简单处理，我们用了内联模板）： 1234567891011&lt;ParentComponent&gt; &lt;SubComponent1 inline-template :param=\"data.sub1\"&gt; &lt;p&gt;this is SubComponent1{{param.name}}&lt;/&gt; &lt;/SubComponent1&gt; &lt;SubComponent2 inline-template :param=\"data.sub2\"&gt; &lt;p&gt;this is SubComponent2{{param.name}}&lt;/&gt; &lt;/SubComponent2&gt; &lt;SubComponent3 inline-template :param=\"data.sub3\"&gt; &lt;p&gt;this is SubComponent3{{param.name}}&lt;/&gt; &lt;/SubComponent3&gt;&lt;/ParentComponent&gt; 上述代码经过Vue.compile函数编译处理后，会得到一个包含render和staticRenderFns两个属性的对象，我们主要看render属性，它是一个匿名函数，代码如下： 1234function anonymous() {with(this){return _c('ParentComponent',[_c('SubComponent1',{attrs:{\"param\":data.sub1},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent1\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent2',{attrs:{\"param\":data.sub2},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent2\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent3',{attrs:{\"param\":data.sub3},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent3\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}})],1)}} 将上面的代码再格式化一下： 123456789function anonymous() {with(this){return _c('ParentComponent',[_c('SubComponent1',{attrs:{\"param\":data.sub1},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent1\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent2',{attrs:{\"param\":data.sub2},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent2\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}}),_v(\" \"),_c('SubComponent3',{attrs:{\"param\":data.sub3},inlineTemplate:{render:function(){with(this){return _c('p',[_v(\"this is SubComponent3\"+_s(param.name)+\"\\n\\t\")])}},staticRenderFns:[]}})],1)}} 可以看到上面第4、5、6行代码，就是子组件的Render Function，他们包裹在一个数组里。因此，如果知道子组件的Render Function，配合形如下面的模板，就可以反过来构造出父组件的Render Function（当然有一个从字符串到函数的反序列化过程，但是在我们的场景这个不可避免，因为模板是从Redis中读取出来的）。 123456789function anonymous() {with(this){return _c(&apos;ParentComponent&apos;,[__SubComponent1_replace__,__SubComponent2_replace__,__SubComponent3_replace__],1)}} 再回到我们的问题，我们已知子组件的Render Function，并且已知父组件的容器，需要构造出父组件的Render Function。现在思路就很清晰了，我们只需要把开头那段包含占位符的div容器代码， 1234&lt;div id='com_1001'&gt;__vue_com_1001_replace__&lt;/div&gt;&lt;div id='com_1002'&gt;__vue_com_1002_replace__&lt;/div&gt;&lt;div id='com_1003'&gt;__vue_com_1003_replace__&lt;/div&gt;&lt;div id='com_1004'&gt;__vue_com_1004_replace__&lt;/div&gt; 使用Vue.compile函数将其编译成Render Function，处理成字符串后，再通过正则替换其中的子组件的占位符，变成子组件模板，最后反序列化为父组件的Render Function即可。整体处理逻辑如下： 2.问题代码分析了解了上述处理过程，我们再根据火焰图中的调用栈，找到replace函数调用的问题代码： 12345678910111213141516171819Object.keys(MPM_COM_STYLE_MAP).forEach(function(comId){ var styleKey = MPM_COM_STYLE_MAP[comId]; var code = ''; if(hideComIds.indexOf(comId)!=-1){ code = HIDE_TPL; }else if(loadingComs.indexOf(comId)!=-1){ code = LOADING_TPL; }else if(MPM_STYLE_TPL_MAP[styleKey]) { // 第一次replace替换 code = MPM_STYLE_TPL_MAP[styleKey].replace(/__uid__replace__str__/g, comId); } else{ console.error('最终替换，发现无模板组件',comId); } if(code) { //第二次replace替换 compileTpl = compileTpl.replace(`_v(\"__vue__${comId}__replace__\")`,code); } }); 可以看到有两次replace函数调用，第一次是组件ID替换（即uid替换），第二次是组件模板替换。 先分析第一次replace函数调用。前面提到，每个组件的模板已经编译为Render Function并存在Redis中。但是同一个组件在页面中可能有多个实例，每个实例需要有一个ID来区分，我们称为uid（unique ID的意思），uid只有在运行的时候才生成，在编译的时候是不知道的，因此用了一个占位符（即下图中的uidreplace__str__），在直出服务中需要做替换，即上面代码中的uid替换。下面是一段编译后的代码： 每个页面会有很多个组件（数十个甚至上百个），每次替换都是在之前替换的结果之上进行的，形成了循环替换，前面导致告警的那个页面用到的编译之后的模版最大的有20+KB，而每次正则替换之后的模版会越来越长，所以这里耗时较多也就不奇怪了。 从逻辑上讲，这段代码是必不可少的，但是又有性能瓶颈，如何优化？ 3.uid替换优化我们研究发现：对于比较长的字符串，先用字符串的split方法分割成数组，再用数组的join方法将切割的数组合并为一个字符串，比正则替换的效率要高。此法我们称为数组粘合法。以下为测试代码： 12345678910111213141516171819202122const exeCount = 10000000; //执行次数,此处分别换成1W、10W、100W、1000W//测试字符串，需要比较长的字符串才能看到效果，下面是从我们的组件模板中摘取的一段const str = `_c('ds',{ref:\"__uid__replace__str__\",attrs:{\"uid\":\"__uid__replace__str__\",\"params\":params___uid__replace__str__,\"tab-index\":\"3\"},inlineTemplate:{render:function(){with(this){return _c('div',{attrs:{\"stylkey\":data.styleKey,\"pc\":data.pc,\"actid\":data.actid,\"areaid\":data.areaid}},[_c('ul',{directives:[{name:\"getskuad\",rawName:\"v-getskuad\",value:({bindObj:data, appendName:'skuAd', show: params.extend.showAds}),expression:\"{bindObj:data, appendName:'skuAd', show: params.extend.showAds}\"}],staticClass:\"pinlei_g3col\"},[(true)?_l((params.fnObj.translate(data.itemList)),function(item,index){return (!params.shownum || index &lt; params.shownum || data.showMore)?_c('li',{class:['pinlei_g3col_col', (params.extend.imgSize == '1' ? 'size_230x230' : 'size_230x320')],attrs:{\"index\":index}},[_c('div',{staticClass:\"pinlei_g3col_img\"},[_c('a',{attrs:{\"href\":params.extend.buttonType == '5' ? addRd(goPingouUrl(item.sUrl),params.ptag) : addRd(item.sUrl,params.ptag)}},[_c('img',{attrs:{\"init_src\":getImgUrl('//img12.360buyimg.com/mcoss/'+ item.sPicturesUrl),\"data-size\":\"230x230\"}})]),((params.extend.sellOut != '0') &amp;&amp; (item.dwStock - 0 &gt; 0))?_c('div',{staticClass:\"pinlei_g3col_msk\"},[_m(0,true)]):_e()]),_c('div',{staticClass:\"pinlei_g3col_info\"},[_c('div',{class:['pinlei_g3col_t1', 'red', (params.extend.titleHeight == '1' ? 'oneline' : '')]},[_v(\"\\n \"+_s(item.sProductName)+\"\\n \")]),(!params.fnObj.isBeforeActive(params.extend.beginTime))?_c('div',{staticClass:\"pinlei_g3col_price red\",style:({color: params.extend.isShowTokenPrice == '1' &amp;&amp; item.dwTokenPrice &amp;&amp; (Number(item.dwTokenPrice) != 0)?'#888':''})},[_v(\"\\n ￥\"),_c('b',[_v(_s(item.dwRealTimePrice.split('.')[0]))]),_v(\".\"+_s(item.dwRealTimePrice.split('.')[1])+\"\\n \")]):_e(),(params.fnObj.isBeforeActive(params.extend.beginTime))?_c('div',{staticClass:\"pinlei_g3col_price red\",style:({color: params.extend.isShowTokenPrice == '1' &amp;&amp; item.dwTokenPrice &amp;&amp; (Number(item.dwTokenPrice) != 0)?'#888':''})},[_v(\"\\n ￥\"),_c('b',[_v(_s(params.fnObj.getYushouInt(item, params.extend.priceType)))]),_v(_s(params.fnObj.getYushouDecimal(item, params.extend.priceType))+\"\\n \")]):_e(),(params.extend.isShowTokenPrice == '1')?[_c('div',{staticClass:\"pinlei_g3col_token\"},[(item.dwTokenPrice &amp;&amp; (Number(item.dwTokenPrice) != 0))?_c('div',{staticClass:\"pinlei_g3col_token_price\"},[_v(\"专属价:￥\"),_c('b',[_v(_s(parseFloat(item.dwTokenPrice)))])]):_e()])]:_e(),(params.fnObj.isBeforeActive(params.extend.beginTime))?[_c('div',{staticClass:\"pinlei_g3col_desc red\"},[(item.sBackUpWords[0] &amp;&amp; (params.fnObj.getYushouJiaDiff(item,params.extend.priceType) &gt; 0))?[_v(\"比现在买省\"+_s(params.fnObj.getYushouJiaDiff(item,params.extend.priceType))+\"元\")]:(item.sTag)?[_v(_s(item.sTag.split('|')[0]))]:(params.extend.showAds == '1' &amp;&amp; item.skuAd)?[_v(_s(item.skuAd))]:_e()],2)]:_e(),(!params.fnObj.isBeforeActive(params.extend.beginTime))?[_c('div',{staticClass:\"pinlei_g3col_desc red\"},[(item.sTag)?[_v(_s(item.sTag.split('|')[0]))]:(params.extend.showAds == '1' &amp;&amp; item.skuAd)?[_v(_s(item.skuAd))]:_e()],2)]:_e(),(params.fnObj.isBeforeActive(params.extend.beginTime))?[(params.extend.buttonType == '0')?[(params.extend.priceType == '1')?_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId}),expression:\"{skuId: item.ddwSkuId}\"}],class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime), 'right': item.sBackUpWords[2]},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")]):_e(),(params.extend.priceType == '0')?_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId}),expression:\"{skuId: item.ddwSkuId}\"}],class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime), 'right': item.sBackUpWords[2]},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")]):_e()]:_e(),(params.extend.buttonType == '1')?[_c('a',{attrs:{\"href\":addRd(item.sUrl,params.ptag)}},[_c('div',{class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime)},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])])]:_e(),(params.extend.buttonType == '5')?[_c('a',{attrs:{\"href\":addRd(goPingouUrl(item.sUrl),params.ptag)}},[_c('div',{class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime)},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])])]:_e(),(params.extend.buttonType == '2')?[_c('a',{attrs:{\"href\":addRd(item.sUrl,params.ptag)}},[_c('div',{class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime)},style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n 定金\"+_s(item.sBackUpWords[1].split('+')[0])+\"抵\"+_s(parseFloat((item.sBackUpWords[1].split('+')[1] * item.sBackUpWords[1].split('+')[0]).toFixed(2)))+\"\\n \")])])]:_e(),(params.extend.buttonType == '3')?[_c('div',{directives:[{name:\"yuyue\",rawName:\"v-yuyue\",value:({bindObj:data,stop:true, activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}),expression:\"{bindObj:data,stop:true, activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}\"}],class:['pinlei_g3col_btn','blue', item.state == 1 ? 'disabled' : ''],style:(params.extend.priceType == 0?'border-radius: 24px;':''),attrs:{\"yuyueid\":params.extend.yuyueID}},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])]:_e(),(params.extend.buttonType == '4' )?[((params.fnObj.getYushouJiaDiff(item,params.extend.priceType)&gt; 0))?_c('div',{directives:[{name:\"skuyuyue\",rawName:\"v-skuyuyue\",value:({bindObj:data,stop:true, skuId:item.ddwSkuId,appendTo:item,ignoreHistory:true,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'},actPrice:params.fnObj.getYushouInt(item, params.extend.priceType)+params.fnObj.getYushouDecimal(item, params.extend.priceType),classId:item.classId1+'_'+item.classId2+'_'+item.classId3}),expression:\"{bindObj:data,stop:true, skuId:item.ddwSkuId,appendTo:item,ignoreHistory:true,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'},actPrice:params.fnObj.getYushouInt(item, params.extend.priceType)+params.fnObj.getYushouDecimal(item, params.extend.priceType),classId:item.classId1+'_'+item.classId2+'_'+item.classId3}\"}],class:['pinlei_g3col_btn','blue', item.state == 1 ? 'disabled' : ''],style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")]):_c('div',{directives:[{name:\"skuyuyue\",rawName:\"v-skuyuyue\",value:({bindObj:data,stop:true, skuId:item.ddwSkuId,ignoreHistory:true,appendTo:item,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'}}),expression:\"{bindObj:data,stop:true, skuId:item.ddwSkuId,ignoreHistory:true,appendTo:item,msg:{success: '预约成功，请留意京东JD.COM服务号的活动提醒',exist: '已设置预约，无需再进行设置',systemError: '该商品不是预约活动商品'}}\"}],class:['pinlei_g3col_btn','blue', item.state == 1 ? 'disabled' : ''],style:(params.extend.priceType == 0?'border-radius: 24px;':'')},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])]:_e(),(params.extend.buttonType == '6' )?[_c('div',{directives:[{name:\"yuyue\",rawName:\"v-yuyue\",value:({bindObj:data,stop:true,noTip:true,activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}),expression:\"{bindObj:data,stop:true,noTip:true,activeId:params.extend.yuyueID,appendTo:item,appendName:'state',msg:[]}\"},{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: {skuId: item.ddwSkuId,successTxt:'预约加车成功'}}),expression:\"{skuId: {skuId: item.ddwSkuId,successTxt:'预约加车成功'}}\"}],class:{'pinlei_g3col_btn':true, 'blue':params.extend.beginTime, 'red':(!params.extend.beginTime), 'left': params.fnObj.getCouponInfo(item.sBackUpWords[2])},style:(params.extend.priceType == 0?'border-radius: 24px;':''),attrs:{\"yuyueid\":params.extend.yuyueID}},[_v(\"\\n \"+_s(params.extend.buttonWording)+\"\\n \")])]:_e()]:_e(),(!params.fnObj.isBeforeActive(params.extend.beginTime))?[(params.extend.buttonActiveType == '0')?[_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId}),expression:\"{skuId: item.ddwSkuId}\"}],staticClass:\"pinlei_g3col_btn\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])]:_e(),(params.extend.buttonActiveType == '1')?[_c('a',{attrs:{\"href\":addRd(item.sUrl,params.ptag)}},[_c('div',{staticClass:\"pinlei_g3col_btn red\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])])]:_e(),(params.extend.buttonActiveType == '2')?[_c('a',{attrs:{\"href\":addRd(goPingouUrl(item.sUrl),params.ptag)}},[_c('div',{staticClass:\"pinlei_g3col_btn red\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])])]:_e(),(params.extend.buttonActiveType == '4')?[_c('div',{directives:[{name:\"addcart\",rawName:\"v-addcart\",value:({skuId: item.ddwSkuId, bindObject: item, bindPropertyName: 'addCartMsg', isPullQuan: true}),expression:\"{skuId: item.ddwSkuId, bindObject: item, bindPropertyName: 'addCartMsg', isPullQuan: true}\"},{name:\"quan\",rawName:\"v-quan\",value:({bindObj:data,key:params.extend.key, level:params.extend.level, num:1, msg:{}, appendTo:item, appendName:'status', ignoreHistory:false, style:2, successUrl:item.successUrl, type:1, coupondes:{value: params.extend.price, gate: params.extend.gate, name: params.extend.name}}),expression:\"{bindObj:data,key:params.extend.key, level:params.extend.level, num:1, msg:{}, appendTo:item, appendName:'status', ignoreHistory:false, style:2, successUrl:item.successUrl, type:1, coupondes:{value: params.extend.price, gate: params.extend.gate, name: params.extend.name}}\"}],staticClass:\"pinlei_g3col_btn\",style:(params.extend.priceType == 0?'border-radius: 24px;background-color: #ea1e54;':'')},[_v(\"\\n \"+_s(params.extend.buttonActiveWording)+\"\\n \")])]:_e()]:_e()],2),(params.extend.corner != '0')?[(isRange(params.extend.cornerBegin, params.extend.cornerEnd) &amp;&amp; params.extend.cornerDes)?_c('div',{staticClass:\"pinlei_g3col_stamp red\"},[_v(_s(params.extend.cornerDes))]):(item.sCopyWriting)?_c('div',{staticClass:\"pinlei_g3col_stamp red\"},[_v(_s(item.sCopyWriting))]):_e()]:_e()],2):_e()}):_e()],2),(params.shownum &amp;&amp; data.itemList.length &gt; params.shownum)?[_c('div',{class:'pinlei_more '+ (data.showMore?'pinlei_more_unfold':''),on:{\"click\":function($event){toggleMore($event)}}},[_v(_s(data.showMore?'收起更多':'展开更多'))])]:_e()],2)}},staticRenderFns:[function(){with(this){return _c('div',{staticClass:\"pinlei_g3col_msk_ico\"},[_c('div',{staticClass:\"pinlei_g3col_msk_text\"},[_v(\"\\n 已抢光\\n \"),_c('br'),_v(\"over\\n \")])])}}]}})`//正则替换法startconst timeStart = new Date().getTime();for(var i = 0; i &lt; exeCount; i++) { str.replace(/__uid__replace__str__/g, 'com_1001');}const timeEnd = new Date().getTime();console.log('正则替换耗时：', timeEnd - timeStart);//正则替换法end//数组粘合法startconst timeStart2 = new Date().getTime();const segs = str.split('__uid__replace__str__');for(var i = 0; i &lt; exeCount; i++) { segs.join('com_1001');}const timeEnd2 = new Date().getTime();console.log('数组粘贴耗时：', timeEnd2 - timeStart2);//数组粘合法end 结果如下： 执行次数 正则替换法耗时(ms) 数组粘合法耗时(ms) 正则替换法耗时/数组粘合法耗时 1W 42 25 1.68 10W 362 179 2.01 100W 3555 1623 2.2 1000W 36449 18634 1.95 可以看到数组粘合法的耗时是正则替换法的一半左右。 考虑到我们的场景就是字符串比较大，存在循环替换，且是海量服务的场景，因此上面第一次替换，直接改成数组粘合法即可。 4.组件模板替换优化问题代码中的第二次替换，是将容器里的组件占位符替换为子组件的Render Function。即下图所示：子模板替换优化的替换次数其实是跟组件的数量相关的，即使有150个组件，用数组粘合法也不会有明显的性能提升，因此需要考虑别的办法。 我们查了一下vue-template-compiler的源码(Vue的compile能力也是用此模块)，发现Vue.compile的函数有2个参数，第一个参数是待编译的Vue模板，第二个参数是一个option对象，包含一个名为tansformCode钩子函数(参见资料https://github.com/vuejs/vue/blob/dev/flow/compiler.js#L38-L45 ，此参数并未在官网的文档中暴露，关于此函数的用处后面可以再写一篇文章) ，这个钩子函数接受两个参数，第一个是ast节点，第二个是编译该节点之后的render code，而该函数的返回值会就是最终的render code。于是在之前的生成dom函数那里把com占位符替换为一个空的div元素，div元素的id为之前的占位符，然后在编译的时候在transformCode钩子函数这里做一个替换，当发现ast节点为div并且id符合组件占位符的规则，那么就返回该组件对应的编译之后样式模版。具体代码如下： 1234567891011121314var compileTpl = compiler.compile(`&lt;div&gt;${html}&lt;/div&gt;`, { modules: { transformCode: function (el, code) { if (el.attrsMap &amp;&amp; el.attrsMap['id'] &amp;&amp; el.attrsMap['id'].match(/__vue__com_\\d{4,5}__replace__/)) { var comId = el.attrsMap['id'].match(/com_\\d{4,5}/)[0]; // console.log('--------------------------------', comId); var styleTemplate = compiledComTplMap[comId]; // console.log(styleTemplate); return styleTemplate; } return code; } } }).staticRenderFns.toString(); 这样一来就完全省去了第二次字符串替换的操作，于是组件编译这里的流程了下面这样： 这两次优化之后然后重新压测并收集性能数据，得到的火焰图如下： 可以看到createApp函数里面原来的那个replace函数的横条已经消失不见了，说明前面的优化是有效果的，最耗时的操作已经不是replace而是vue的compile方法即模版的编译。从此次优化前后的服务端压测的CPU数据也能说明问题： 四.compile函数调用优化compile函数调用，就是前面”组件模板构造”那一节提到的，将组件的容器模板用Vue.compile函数编译成Render Function，虽然这段容器模板很简单，但是他是一个很耗性能的操作。而且这是Vue自身提供的能力，似乎已经没有多大的优化余地了。有没有其他优化方法呢？ 仔细观察一下组件容器dom以及编译之后的代码，似乎是有规律的。如果组件树的结构是下面这样的： 12345678910[ {id: \"com_1001\"}, { id: \"com_1002\", child: [ {id: \"com_1003\"}, {id: \"com_1004\"} ] }]; 拼接之后的html内容大概是下面这样的： 12345678&lt;div&gt; &lt;div id=\"com_1001_con\"&gt;&lt;/div&gt; &lt;div id=\"com_1002_con\"&gt;&lt;/div&gt; &lt;div mpm_edit_child_box tabpid=\"com_1002\" class=\"childBox\"&gt; &lt;div id=\"com_1003_con\"&gt;&lt;/div&gt; &lt;div id=\"com_1004_con\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这里一般都只是一些简单的模版，编译出来大概是这样的： 1234567891011121314with(this) { return _c('div', [ _c('div', {attrs: {\"id\": \"com_1001_con\"}}), _v(\" \"), _c('div', {attrs: {\"id\": \"com_1002_con\"}}), _v(\" \"), _c('div', {staticClass: \"childBox\", attrs: {\"mpm_edit_child_box\": \"\", \"tabpid\": \"com_1002\"}}, [ _c('div', {attrs: {\"id\": \"com_1003_con\"}}), _v(\" \"), _c('div', {attrs: {\"id\": \"com_1004_con\"}}) ]) ])} 通过观察可以发现，这里都是生成的div元素，div上的属性都是静态属性，由此我们可以自己实现一个简单的“编译”函数，不用走vue的编译： 1234567891011121314151617function simpleCompile(comList) { function genTree(tree) { var html = ''; for (var i = 0, len = tree.length; i &lt; len; i++) { var node = tree[i]; var comId = node.id; html += `_c('div',{attrs:{\"id\":\"${comId}_con\"}},[`; html = html + compiledComTplMap[comId] + '])'; // compiledComTplMap[comId] 该组件对应的编译后的样式模版 if (node.child &amp;&amp; node.child.length) { html += `,_c('div',{staticClass:\"childBox\",attrs:{\"mpm_edit_child_box\":\"\",\"tabpid\":\"${comId}\"}},[` + genTree(node.child) + `])`; } html += (i === len - 1) ? '' : ','; } return html; } return genTree(comList); } 经测试，这样简单“编译”之后生成的代码跟之前编译的代码是一样的，在预发布环境测试了多个页面之后，页面渲染也没有问题。去掉Vue模版编译之后整个组件渲染的逻辑就变成了下面这样： Vue编译优化之后收集cpu数据得到的火焰图如下： 从火焰图可以看出，原来的那个compile函数调用的横条也消失了，说明优化有效果。再看看压测的CPU消耗情况： 需要提到的是，由于是自己实现了一个简单版的compile函数，前文中关于compile函数调用优化的代码，也直接去掉了，当然也到达了优化的效果。 五.其他优化研究经过上面两次优化之后，剩下最耗性能的地方是JSON解析和Vue渲染了。我们也做了一下研究，但是很可惜，暂时没什么成果，不过我们的探索也可以提一下：1）JSON解析。我们的服务从Redis中读出来的PageData比较大，一般有100多KB，很需要有一个高性能的JSON反序列化的库(即代替JSON.parse)。目前有一个高性能的库fast-json-stringify，但是可惜他是做序列化的（即做的是JSON.stringify做的事情）。我们测试了多个方案，目前原生的JSON.parse函数性能是最好的。2）Vue渲染。有位腾讯的同学提到，用string-based的模板代替VirtualDom的渲染方案提升性能,不过他忽略了一点，Vue是完全的组件化的、是有生命周期钩子、方法、计算属性等，不是一个简简单单的模板引擎，按照他的思路是需要把生命周期的钩子、方法、计算属性等全部算好后拿到的数据对象，再跟string-based模板结合才能渲染，这个显然是和组件化的思路背道而驰的。 上面2点，各位看官如果有好的思路，欢迎不吝赐教！ 六.总结这次优化总的来说，CPU性能消耗得到了有效优化，整体提升了大概20%，一方面为公司节省了资源，另外一方面也减少了因流量暴涨导致我们要扩容的几率，一举两得。","link":"/2019/09/27/记一次Node-js直出服务的性能优化/"},{"title":"【译】Interection Observer如何观察变化","text":"原文地址：https://css-tricks.com/an-explanation-of-how-the-intersection-observer-watches/原文作者：Travis Almand翻译：刘辉 有几篇精彩的文章探讨了如何使用Intersection Observer API，包括Phil Hawksworth，Preethi和Mateusz Rybczonek等。 我这篇文章将讲一些不一样的东西。 我在今年早些时候有幸向达拉斯VueJS聚会介绍了VueJS过渡组件，我在CSS-Tricks的第一篇文章就是以此为基础的。 在演讲的问答环节中，有人问我基于滚动事件触发过渡怎么样 - 我说当然可以，但是一些听众建议我了解一下Intersection Observer。 这让我开始思考。我对Intersection Observer有基本的了解，并且能够用其完成简单的示例。 我是否知道它的工作原理而不仅仅是使用它？它到底为我们开发人员提供了什么？ 作为一个资深开发者，我如何向新手甚至不知道它存在的开发者解释它的工作原理？ 在花了一些时间进行研究，测试和验证后，我决定分享自己学到的东西。 Intersection Observer 简述W3C公共工作草案摘要（日期为2017年9月14日的初稿）将Intersection Observer API描述为： 本规范描述了一个API，可用于了解DOM元素（targets）相对于包含元素或顶级视口（root）的可见性和位置。 该位置是异步传递的，对于理解元素的可见性以及实现DOM内容的预加载和延迟加载很有用。 这个API的总体思路是提供一种观察子元素并在其进入其父元素之一的边界框内时得到通知的方法。 目标元素滚动到根元素视图中时最常用。 在引入Intersection Observer之前，此类功能是通过侦听滚动事件来完成的。 尽管Intersection Observer是针对此类功能的更高性能的解决方案，但我不建议我们将其视为滚动事件的替代品。 相反，我建议我们将此API视为与滚动事件在功能上互补的额外工具。 在某些情况下，两者可以一起解决特定的问题。 基本示例我知道我有可能重复其他文章中已经讲过的内容，不过还是让我们先来看一个Intersection Observer的基本示例及其提供的能力。 Observer由四部分组成： root，是观察者所绑定的父元素，可以是viewport target，它是被观察的子元素，可以有多个 options对象，它定义了观察者某些方面的行为 回调函数，每次观察到父子元素的交集变化时都会调用 基本示例的代码如下所示： 12345678910111213141516const options = { root: document.body, rootMargin: '0px', threshold: 0}function callback (entries, observer) { console.log(observer); entries.forEach(entry =&gt; { console.log(entry); });}let observer = new IntersectionObserver(callback, options);observer.observe(targetElement); 代码的第一部分是options对象，它具有root，rootMargin和threshold属性。 root是父元素，一般是有滚动条的元素，其中包含被观察的元素。根据需要，这几乎可以是页面上的任何单个元素。如果不提供该属性，或者该值设置为null，跟元素就是viewport。 rootMargin描述了根元素的外边距，由rootMargin规定的矩形的每一边都会被添加至root元素的边框盒(bounding box)的相应边。它的行为很像CSS margin属性。你可以使用类似10px 15px 20px的值，这使我们的顶部边距为10px，左侧和右侧边距为15px，底部边距为20px。仅边界框受影响，元素本身不受影响。请记住，唯一允许的长度是像素和百分比值，可以是负数或正数。另请注意，如果root元素不是页面上的实际元素（例如viewport），则rootMargin无效。 threshold是用于确定何时触发交集改变事件的值。数组中可以包含多个值，以便同一目标可以多次触发交集改变事件。不同的值是使用0到1的百分比，非常类似于CSS中的不透明度，因此将0.5的值视为50％，依此类推。这些值与目标的交叉比例有关，稍后将对其进行说明。阈值为0时，目标元素的第一个像素与根元素相交就会触发交集改变事件。阈值为1时，整个目标元素都在根元素内部时才会触发交集改变事件。 代码的第二部分是回调函数，只要观察到交集改变，就会调用该函数。传递了两个参数；entries是个数组，代表触发交集更改的每个目标元素。这提供了很多信息为开发人员所用。第二个参数是有关观察者本身的信息。如果目标绑定到多个观察者，可以通过此参数识别是哪个观察者。 代码的第三部分是观察者本身的创建以及观察对象。创建观察者时，回调函数和options对象可以放在观察者外部。 如果需要，可以在多个观察者之间使用相同的回调和options对象。然后，将需要观察的目标元素传递给observe()方法。它只能接受一个目标，但是可以在同一观察者上针对多个目标重复调用该方法。 注意代码中的console.log,可以看看控制台输出了什么。 观察者对象传递给回调函数的观察者数据如下： 12345IntersectionObserver root: null rootMargin: \"0px 0px 0px 0px\" thresholds: Array [ 0 ] &lt;prototype&gt;: IntersectionObserverPrototype { } …本质上是创建对象时传递给观察者的选options对象。 这可用于确定相交所绑定的根元素。 注意即使原始选项对象的rootMargin值为0px，该对象也将其转为0px 0px 0px 0px，这是CSS边距规范所需要的。然后是观察者正在使用的一系列阈值。 entry对象传递给回调函数的entry对象数据如下： 12345678910111213141516171819IntersectionObserverEntry boundingClientRect: DOMRect bottom: 923.3999938964844, top: 771 height: 152.39999389648438, width: 411 left: 9, right: 420 x: 9, y: 771 &lt;prototype&gt;: DOMRectPrototype { } intersectionRatio: 0 intersectionRect: DOMRect bottom: 0, top: 0 height: 0, width: 0 left: 0, right: 0 x: 0, y: 0 &lt;prototype&gt;: DOMRectPrototype { } isIntersecting: false rootBounds: null target: &lt;div class=\"item\"&gt; time: 522 &lt;prototype&gt;: IntersectionObserverEntryPrototype { } 可以看到，这里做了很多工作。 对于大多数开发人员而言，最可能有用的两个属性是intersectionRatio和isIntersecting。 isIntersecting属性是一个布尔值，在交集更改时目标元素与根元素是否相交。intersectionRatio是当前与根元素相交的目标元素的百分比。它也是零到一之间的百分比表示，非常类似于观察者的options对象中threshold。 三个属性（boundingClientRect，intersectionRect和rootBounds）表示交集相关的三个方面的具体数据。 boundingClientRect属性为目标元素的边界框提供从viewport左上角开始的bottom，left，right和top值，就像Element.getBoundingClientRect()一样。然后，将目标元素的高度和宽度作为X和Y坐标提供。 rootBounds属性为根元素提供相同形式的数据。intersectionRect提供相似的数据，它描述了由目标元素在根元素内部的相交区域形成的矩形，该区域也被用于计算intersectionRatio值。传统的滚动事件需要手动完成此计算。 要注意的是，代表这些不同元素的所有这些形状始终都是矩形。无论所涉及元素的实际形状如何，它们总是会缩小到包含该元素的最小矩形。 target属性是指正在观察的目标元素。在观察者包含多个目标的情况下，这是确定哪个目标元素触发了此相交更改的简便方法。 time属性提供从首次创建观察者到触发此交集改变的时间（以毫秒为单位）。通过这种方式，你可以跟踪观看者遇到特定目标所花费的时间。即使稍后将目标再次滚动到视图中，此属性也会提供新的时间。这可用于跟踪目标进入和离开根元素的时间。 除了每次观察到交集改变时我们可以获得这些信息外，观察者第一次启动时也会向我们提供这些信息。例如，在页面加载时，页面上的观察者将立即调用回调函数，并提供它正在观察的每个目标元素的当前状态。 Intersection Observer以非常高效的方式提供了有关页面上元素之间关系的数据。 Intersection Observer 可用的方法Intersection Observer 主要有三个方法：observe()，unobserve()和disconnect()。 observe()：observe方法用来添加观察者要监视的目标元素。 观察者可以具有多个目标元素，但是此方法一次只能接受一个目标。 unobserve()：unobserve方法用来从观察的元素列表中移除元素。 disconnect()：disconnect方法用来停止观察其所有目标元素。观察者本身仍处于活动状态，但没有目标。在disconnect()之后，目标元素仍然可以通过observe()传递给观察者。 这些方法提供了监视和取消监视目标元素的功能，但是一旦创建，便无法更改传递给观察者的options对象。 如果需要修改，则必须手动重新创建观察者。 Intersection Observer和滚动事件的性能对比在探索Intersection Observer以及将其与使用滚动事件进行比较时，我需要进行一些性能测试。我只想大致了解两者之间的性能差异，为此我创建了三个简单的测试。 首先，我创建了一个样本HTML文件，该文件包含一百个设置了高度的div，以此创建一个长滚动页面。把页面放在静态服务器上，然后我用Puppeteer加载了HTML文件，启动了跟踪，让页面以预设的增量向下滚动到底部，一旦到达底部，就停止了跟踪，最后保存跟踪的结果。这样测试可以重复多次并输出每次的结果数据。然后，我复制了样本HTML，并为要运行的每种测试类型在脚本标签中编写了js。每个测试都有两个文件：一个用于Intersection Observer，另一个用于滚动事件。 所有测试的目的是检测目标元素何时以25％的增量向上滚动通过视口。每次增加时，都会应用CSS类来更改元素的背景颜色。换句话说，每个元素都应用了DOM修改，这将触发重绘。每次测试都在两台不同的计算机上运行了五次：我的开发用的Mac是最新的设备，而我的个人Windows 7计算机可能是当前的平均水平。记录脚本，渲染，绘画和系统的跟踪结果，然后取平均值。 第一个测试有一个观察者或一个滚动事件，每个事件都有一个回调。对于观察者和滚动事件，这是一个相当标准的设置。尽管在这种情况下，滚动事件还有很多工作要做，因为滚动事件试图模仿观察者默认提供的数据。完成所有这些计算后，就像观察者一样，将数据存储在条目数组中。然后，在两者之间删除和应用类的功能完全相同。另外我使用了requestAnimationFrame对滚动事件进行了节流处理。 第二个测试有100个观察者或100个滚动事件，每种类型都有一个回调。每个元素都分配有自己的观察者和事件，但回调函数相同。这实际上是低效的，因为每个观察者和事件的行为都完全相同，但是我想要一个简单的压力测试，而不必创建100个唯一的观察者和事件-尽管我已经看到了许多以这种方式使用观察者的示例。 第三次测试具有100个观察者或100个滚动事件，每种类型具有100个回调。这意味着每个元素都有其自己的观察器，事件和回调函数。当然，这是极其低效的，因为这是存储在巨大阵列中的所有重复功能。但是这种低效率是该测试的重点。 在上面的图表中，你可以看到，第一列代表我们的基准，根本没有运行JavaScript。接下来的两列代表第一种测试类型。 Mac的运行都非常好，符合我对开发用高端计算机的预期。 Windows机器给了我们一个不一样的结果。对我来说，主要的兴趣点是红色所代表的脚本。在Mac上，观察者的差异约为88毫秒，而滚动事件的差异约为300毫秒。在Mac上，每种测试的总体结果都相当接近，但是脚本在滚动事件方面表现出色。对于Windows机器，它要差得多得多。观察者大约是150毫秒，而第一次和最简单的测试是1400毫秒。 对于第二个测试，我们开始看到滚动测试的效率变得更加明显。 Mac和Windows机器都运行了观察者测试，结果与以前几乎相同。对于滚动事件测试，脚本陷入了更多困境，无法完成给定的任务。 Mac跃升到几乎一整秒的脚本编写时间，而Windows计算机跃升到惊人的3200ms。 对于第三次测试，情况没有变坏。结果与第二项测试大致相同。要注意的一件事是，在所有三个测试中，观察者的结果对于两台计算机都是一致的。尽管没有为提高观察者测试的效率做出任何优化，但Intersection Observer的性能表现还是远远超过了滚动事件。 因此，在我自己的两台机器上进行了非科学性测试之后，我感到对滚动事件和Intersection Observer之间的性能差异有一个不错的了解。 我敢肯定，我可以通过一些努力使滚动事件更有效，但这值得吗？ 在某些情况下，滚动事件的精度是必需的，但是在大多数情况下，Intersection Observer就足够了-尤其是因为它看起来更加高效，而无需付出任何努力。 搞清intersectionRatio属性IntersectionObserverEntry给我们提供的intersectionRatio属性，表示目标元素在交集更改上的根元素边界内的百分比。 我发现我一开始不太了解这个值的实际含义。 由于某种原因，我认为这是目标元素外观的一种简单的0％到100％的表示形式。 它与创建时传递给观察者的阈值相关。 例如，它可用于确定哪个阈值是刚刚触发相交更改的原因。 但是，它提供的值并不总是很简单。 以这个demo为例： demo 在此demo中，已为观察者分配了父容器作为根元素。 具有目标背景的子元素已分配为目标元素。 已创建阈值数组，其中包含100个条目，其顺序为0、0.01、0.02、0.03，依此类推，直到1。观察者触发目标元素在根元素内部出现或消失的每一个百分比，以便每当比率 更改至少百分之一，此框下方的输出文本将更新。 如果您感到好奇，可以使用以下代码来完成此阈值： 1[...Array(100).keys()].map(x =&gt; x / 100) } 我不建议你以这种方式为项目中的具体用途设置阈值。 首先，目标元素完全包含在根元素中，并且按钮上方的输出将显示比率1。它应该是第一次加载的，但是我们很快就会发现该比率并不总是精确的；该数字可能在0.99到1之间。这似乎很奇怪，但是有可能发生，因此，如果你对等于特定值的比率进行检查，请记住这一点。 单击“left”按钮将使目标元素向左转换，以使其一半在根元素中，另一半不在。然后，ratioRatio应该更改为0.5，或者接近0.5。现在我们知道目标元素的一半与根元素相交，但是我们不知道它在哪里。以后再说。 单击“top”按钮具有相同的功能。它将目标元素转换为根元素的顶部，并再次将其移入和移出。再一次，交集比率应该在0.5左右。即使目标元素位于与以前完全不同的位置，结果比率也相同。 再次单击“corner”按钮，会将目标元素转换为根元素的右上角。此时，目标元素中只有四分之一位于根元素内。intersectionRatio应以大约0.25的值反映出来。单击“center”会将目标元素转换回中心并完全包含在根元素中。 如果单击“large”按钮，则将目标元素的高度更改为高于根元素。相交比应为0.8左右。这是依赖intersectionRatio的棘手部分。根据提供给观察者的阈值创建代码可以使阈值永远不会触发。在此“large”示例中，基于阈值1的任何代码都将无法执行。还要考虑可以调整根元素大小的情况，例如将视口从纵向旋转为横向。 查找位置那么，我们如何知道目标元素相对于根元素的位置呢？此数据由IntersectionObserverEntry提供，因此我们只需要进行简单的比较即可。 看这个demo: demo2 该演示的设置与之前的设置大致相同。 父容器是根元素，内部具有目标背景的子容器是目标元素。 阈值是一个0、0.5和1的数组。在根元素中滚动时，将出现目标，并且其位置将在按钮上方的输出中报告。 下面执行这些检查的代码： 12345678910111213141516171819const output = document.querySelector('#output pre');function io_callback (entries) { const ratio = entries[0].intersectionRatio; const boundingRect = entries[0].boundingClientRect; const intersectionRect = entries[0].intersectionRect; if (ratio === 0) { output.innerText = 'outside'; } else if (ratio &lt; 1) { if (boundingRect.top &lt; intersectionRect.top) { output.innerText = 'on the top'; } else { output.innerText = 'on the bottom'; } } else { output.innerText = 'inside'; }} 我应该指出，我没有遍历entrys数组，因为我知道总是只有一个条目，因为只有一个目标。我走了捷径，使用entries[0]。 您会发现比率为零会将目标置于“外部”。小于1的比率将其放在顶部或底部。这样一来，我们就可以查看目标的“顶部”是否小于交集矩形的顶部，这实际上意味着目标在页面上更高，并被视为“顶部”。实际上，检查根元素的“顶部”也可以解决此问题。从逻辑上讲，如果目标不在顶部，则它必须在底部。如果比率恰好等于1，则它在根元素“内部”。除了使用left或right属性检查水平位置外，其他检查方法相同。 这是高效使用Intersection Observer的一部分。开发人员无需在节流的滚动事件上从多处请求此数据，然后进行计算。它是由观察者提供的，所需要的只是一个简单的if检查。 首先，目标元素要比根元素高，因此永远不会将其报告为“内部”。单击“切换目标大小”按钮以使其小于根。现在，上下滚动时目标元素可以位于根元素内部。 通过再次单击“toggle target size”，然后单击“toggle root size”按钮，将目标元素恢复为其原始大小。这将调整根元素的大小，使其比目标元素高。再次，当上下滚动时，目标元素可能位于根元素内部。 此demo演示了有关Intersection Observer的两件事：如何确定目标元素相对于根元素的位置以及调整两个元素的大小时会发生什么。这种对调整大小的响应让我们看到了Intersection Observer相对于滚动事件的另一个优势-不用再单独处理resize事件。 创建位置粘性事件CSS position属性的“sticky”是一个有用的功能，但在CSS和JavaScript方面却有一些限制。粘性节点的样式只能是一种设计，无论是处于其正常状态还是处于其粘性状态内。没办法让js知道这些变化。到目前为止，还没有伪类或js事件使我们知道元素的状态变化。 我已经看到了使用滚动事件和Intersection Observer进行粘性定位事件的示例。使用滚动事件的解决方案始终存在与将滚动事件用于其他目的相似的问题。观察者的通常解决方案是用一个定位元素，仅作为观察者的目标元素使用。我喜欢避免使用诸如此类的单一目的的元素，因此我决定修改这个特定的想法。 在此demo中，上下滚动以查看章节标题对各自章节的粘性反应。 demo3 这个示例检测粘性元素何时位于滚动容器顶部，然后给其添加一个css类。 这是通过在给观察者特定的rootMargin时利用DOM的一个有趣的特性来实现的。 给出的值是： 1rootMargin: '0px 0px -100% 0px' 这样会将根边界的底部边缘推到根元素的顶部，从而留下一小部分可用于相交检测的零像素区域。 可以说，即使目标元素碰触到零像素区域，也会触发相交变化，即使它不存在于数字中也是如此。 考虑一下，我们可以在DOM中具有折叠高度为零的元素。 该解决方案通过识别粘性元素始终位于根元素顶部的“粘性”位置来利用这一优势。 随着滚动的继续，粘性元素最终移出视野，并且相交停止。 因此，我们根据输入对象的isIntersecting属性添加和删除类。 下面是HTML： 1234567891011&lt;section&gt; &lt;div class=\"sticky-container\"&gt; &lt;div class=\"sticky-content\"&gt; &lt;span&gt;&amp;sect;&lt;/span&gt; &lt;h2&gt;Section 1&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; {{ content here }} &lt;/section&gt; class为sticky-container的外部div是观察者的目标。 该div将被设置为粘性元素并充当容器。 用于根据粘性状态设置样式和更改元素的元素是class为sticky-content的div及其子元素。 这样可以确保实际的粘性元素始终与根元素顶部缩小的rootMargin接触。 下面是CSS： 12345678910111213141516171819202122232425262728293031323334.sticky-content { position: relative; transition: 0.25s;}.sticky-content span { display: inline-block; font-size: 20px; opacity: 0; overflow: hidden; transition: 0.25s; width: 0;}.sticky-content h2 { display: inline-block;} .sticky-container { position: sticky; top: 0;}.sticky-container.active .sticky-content { background-color: rgba(0, 0, 0, 0.8); color: #fff; padding: 10px;}.sticky-container.active .sticky-content span { opacity: 1; transition: 0.25s 0.5s; width: 20px;} 你会看到.sticky-container在top为0的位置创建了我们的粘滞元素。 其余部分是.sticky-content中的常规状态和.active .sticky-content中的粘滞状态样式的混合。 同样，您几乎可以在粘性内容div中做任何您想做的事情。 在此demo中，当粘滞状态处于活动状态时，在延迟的过渡中会出现一个隐藏的章节符号。没有Intersection Observer之类的辅助手段，很难达到这种效果。 JavaScript： 1234567891011121314151617const stickyContainers = document.querySelectorAll('.sticky-container');const io_options = { root: document.body, rootMargin: '0px 0px -100% 0px', threshold: 0};const io_observer = new IntersectionObserver(io_callback, io_options);stickyContainers.forEach(element =&gt; { io_observer.observe(element);});function io_callback (entries, observer) { entries.forEach(entry =&gt; { entry.target.classList.toggle('active', entry.isIntersecting); });} 这实际上是使用Intersection Observer完成此任务的非常简单的示例。 唯一的例外是rootMargin中的-100％值。 请注意，这对于其他三个方面也可以重复； 它只需要一个具有自己独特的rootMargin的新观察者，对于相应方面，它具有-100％的值。 将会有更多独特的粘性容器，它们具有自己的类，例如sticky-container-top和sticky-container-bottom。 这样做的限制是，粘性元素的top，right，bottom或left属性必须始终为零。 从技术上讲，你可以使用其他值，但随后必须进行数学运算以找出rootMargin的正确值。 这很容易做到，但是如果调整大小，不仅需要再次进行数学运算，还必须停止观察者并使用新值重新启动它。 将position属性设置为零，并使用内部元素以所需的方式设置样式更加容易。 和滚动事件结合到目前为止，我们已经在一些演示中看到了，intersectionRatio可能不精确且有些局限。使用滚动事件可以更精确，但会降低性能的效率。那把两者结合起来怎么样？ demo4 在此demo中，我们创建了一个Intersection Observer，并且回调函数的唯一目的是添加和删除侦听根元素上的scroll事件的事件侦听器。 当目标首次进入根元素时，将创建滚动事件侦听器，然后在目标离开根元素时将其删除。 滚动时，输出仅显示每个事件的时间戳，以实时显示事件的变化-比单独的观察者要精确得多。 下面是JavaScript。 12345678910111213141516171819202122232425const root = document.querySelector('#root');const target = document.querySelector('#target');const output = document.querySelector('#output pre');const io_options = { root: root, rootMargin: '0px', threshold: 0};let io_observer;function scrollingEvents (e) { output.innerText = e.timeStamp;}function io_callback (entries) { if (entries[0].isIntersecting) { root.addEventListener('scroll', scrollingEvents); } else { root.removeEventListener('scroll', scrollingEvents); output.innerText = 0; }}io_observer = new IntersectionObserver(io_callback, io_options);io_observer.observe(target); 这是一个相当标准的例子。 请注意，我们希望阈值为零，因为如果阈值不止一个，我们将同时获得多个事件监听器。 回调函数是我们感兴趣的，甚至是一个简单的设置：在if-else块中添加和删除事件监听器。 事件的回调函数仅更新输出中的div。 每当目标触发相交变化并且不与根相交时，我们会将输出设置回零。 这个实例利用了Intersection Observer和滚动事件的优点。 考虑使用一个滚动动画库，该动画库仅在页面上需要它的部分实际可见时才起作用。 库和滚动事件在整个页面中并非无效地活动。 浏览器的有趣差异您可能想知道Intersection Observer有多少浏览器支持。 实际上，还蛮多的！ 该浏览器支持数据来自Caniuse，更多信息。 数字表示浏览器支持该版本及更高版本的功能。 所有主要的浏览器都已经支持了一段时间。和预期一样，IE在任何级别都不支持它，但是W3C提供了一个polyfill来解决这个问题。 当我使用Intersection Observer尝试不同的想法时，我确实遇到了两个示例在Firefox和Chrome之间的行为有所不同。我不会在生产站点上使用这些示例，但是这些行为很有趣。 这是第一个示例： example1 目标元素通过CSS transform属性在根元素内移动。 该演示具有CSS动画，该动画可在水平轴上将目标元素移入和移出根元素。 当目标元素进入或离开根元素时，intersectionRatio会更新。 如果您在Firefox中查看此演示，则应在目标元素前后滑动时正确地看到intersectionRatio更新。 Chrome的行为有所不同，完全不更新intersectionRatio。 Chrome似乎没有保留使用CSS转换过的目标元素的标签。 但是，如果我们在目标元素移入和移出根元素时在浏览器中四处移动鼠标，则intersectionRatio确实会更新。 我的猜测是，只有在存在某种形式的用户交互时，Chrome才会“激活”观察者。 这是第二个示例： example2 这次，我们对一个剪裁路径进行动画处理，该剪裁路径将一个正方形变成重复循环中的一个圆形。正方形与根元素的大小相同，因此我们得到的intersectionRatio将始终小于1。随着剪裁路径的动画化，Firefox根本不会更新intersectionRatio。这次移动鼠标不起作用。Firefox只是忽略元素大小的变化。另一方面，Chrome实际上会实时更新intersectionRatio显示。即使没有用户交互，也会发生这种情况。 之所以会发生这种情况，是因为规范的一部分指出交集区域（intersectionRect）的边界应包括剪裁目标元素。 如果容器具有溢出剪裁或css剪裁路径属性，请通过应用容器的剪裁来更新intersectionRect。 因此，当剪裁目标时，将重新计算相交区域的边界。 Firefox显然尚未实现。 Intersection Observer, version 2那么，该API的未来前景如何？ Google提供了一些建议，这些建议会为观察者添加一个有趣的功能。 即使Intersection Observer告诉我们目标元素何时跨越根元素的边界，也不一定意味着该元素实际上对用户是可见的。 它可能具有零不透明度，或者可能被页面上的另一个元素覆盖。 观察者能不能被用来确定这些事情？ 请记住，我们仍在早期阶段才使用此功能，因此不应在生产代码中使用它。 这是更新后的提案，其中突出显示了与规范第一个版本的差异。 如果您一直在使用Chrome浏览本文中的演示，则可能已经注意到控制台中的几件事-例如Firefox中未出现的entries对象属性。 这是Firefox在控制台中打印内容的示例： 123456789101112131415IntersectionObserver root: null rootMargin: \"0px 0px 0px 0px\" thresholds: Array [ 0 ] &lt;prototype&gt;: IntersectionObserverPrototype { }IntersectionObserverEntry boundingClientRect: DOMRect { x: 9, y: 779, width: 707, ... } intersectionRatio: 0 intersectionRect: DOMRect { x: 0, y: 0, width: 0, ... } isIntersecting: false rootBounds: null target: &lt;div class=\"item\"&gt; time: 261 &lt;prototype&gt;: IntersectionObserverEntryPrototype { } 现在，这是来自Chrome中相同控制台代码的输出： 12345678910111213141516171819 IntersectionObserver delay: 500 root: null rootMargin: \"0px 0px 0px 0px\" thresholds: [0] trackVisibility: true __proto__: IntersectionObserverIntersectionObserverEntry boundingClientRect: DOMRectReadOnly {x: 9, y: 740, width: 914, height: 146, top: 740, ...} intersectionRatio: 0 intersectionRect: DOMRectReadOnly {x: 0, y: 0, width: 0, height: 0, top: 0, ...} isIntersecting: false isVisible: false rootBounds: null target: div.item time: 355.6550000066636 __proto__: IntersectionObserverEntry 在一些属性（例如target和prototype）的显示方式上存在一些差异，但是它们在两种浏览器中的操作相同。区别在于Chrome具有Firefox中不会显示的一些其他属性。observer对象具有一个称为trackVisibility的布尔值，一个称为delay的数字，并且entry对象具有一个称为isVisible的布尔值。这些是新提议的属性，这些属性试图确定目标元素是否实际上对用户可见。 我将对这些属性进行简要说明，但如果您需要更多详细信息，请阅读此文章。 trackVisibility属性是在options对象中提供给观察者的布尔值。此属性可以使浏览器承担确定目标元素的真实可见性的任务。 delay属性用途的猜测：它将交集改变的回调方法延迟指定的时间（以毫秒为单位）。这有点类似于将回调函数的代码包装在setTimeout中。为了使trackVisibility起作用，该值是必需的，并且必须至少为100。如果未提供适当的值，则控制台将显示此错误，并且将不会创建观察者。 123456Uncaught DOMException: Failed to construct &apos;IntersectionObserver&apos;: To enable the &apos;trackVisibility&apos; option, you must also use a &apos;delay&apos; option with a value of atleast 100. Visibility is more expensive to compute than the basic intersection;enabling this option may negatively affect your page&apos;s performance.Please make sure you really need visibility tracking before enabling the&apos;trackVisibility&apos; option. 目标entry对象中的isVisible属性是报告可见性跟踪输出的布尔值。可以将它用作任何代码的一部分，就像使用isIntersecting一样。 在我使用这些功能进行的所有实验中，看到它实际上有时候有效有时候无效。 例如，当元素清晰可见时，延迟始终有效，但是isVisible并不总是报告true（至少对我而言）。 有时这是设计使然，因为规范确实允许出现第二类错误。这将有助于解释不一致的结果。 我个人迫不及待地希望这项功能尽快完成，并在所有支持Intersection Observer的浏览器中都能正常工作。 写在最后我对Intersection Observer的研究到此结束。 我花了很多晚上研究，试验和构建示例，以了解其工作原理。 这篇文章涉及了一些有关如何利用观察者的不同功能的新想法。除此之外，我觉得我可以清晰的解释观察者的工作原理。希望本文对你有所帮助。","link":"/2019/10/17/【译】interection-observer如何观察变化/"},{"title":"写一个四则运算表达式转换成AST的方法","text":"作者：吴冠禧 0 前言晓强哥在他的上篇文章里介绍了 Javascript 抽象语法树里面「提到获得抽象语法树的过程为：代码 =&gt; 词法分析 =&gt; 语法分析 =&gt; AST」，抱着深究技术细节的目的，我决定研究这里的词法分析和语法分析，写一个简单的四则运算表达式转换成AST的方法，于是就有了下面的内容。 1 人类和计算机对于表达式的看法是不同的人类习惯 a + b 这种表达叫做「中序表达式」，优点是比较简单直观，缺点是要用一堆括号来确定优先级 (a + b) * (c + d)。 这里说简单直观是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。 为了计算机计算方便，我们需要将中序表达式转换成树形结构，也就是「抽象语法树AST」。 2 javascript 与抽象语法树 AST我们知道，几乎任何语言中，代码在 “编译”（解释型语言在运行时也有编译的过程） 的过程中，都会生成一种树状的中间状态，这就是 AST。有些语言会直接把类似 AST 的语法暴露给程序员（例如：lisp、elixir、python等）。但是 javascript 并没有这个能力，但是我们可以用 javascript 自身实现这个过程。 获得抽象语法树的过程为：代码（字符串） =&gt; 词法分析（Lexer）=&gt; Tokens =&gt; 语法分析（Parser） =&gt; AST 3 词法分析（Lexer）词法分析有点像中文的分词，就是将字符串流根据规则生成一个一个的有具体意义的 Token ，形成 Token 流，然后流入下一步。 我们看一个简单的例子， 11 + 2.3 很明显这个表达式是可以分成三个 Token ，分别是 1 , + , 2.3。 词法分析这里，我们可以用有限状态机来解决。 3.1 有限状态机绝大多数语言的词法部分都是用状态机实现的，我们下面就画出有限状态机的图形，然后根据图形直观地写出解析代码，总体图大概是这样。 下面拆开细看。 3.2 开始（start）状态 状态机的初始状态是 start 。 start 状态下输入数字（0 ～ 9）就会迁移到 inInt 状态。 start 状态下输入符号（.）就会迁移到 inFloat 状态。 start 状态下输入符号（+ - * /）就会输出 「符号 Token」 ，并回到 start 状态。 start 状态下输入 EOF 就会输出 「EOF Token」 ，并回到 start 状态。 代码大概是这个样子： 12345678910111213141516171819202122start(char) { // 数字 if ([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"].includes(char)) { this.token.push(char); return this.inInt; } // . if (char === \".\"){ this.token.push(char); return this.inFloat; } // 符号 if ([\"+\",\"-\",\"*\",\"/\"].includes(char)) { this.emmitToken(\"SIGN\", char); return this.start; } // 结束符 if (char === EOF){ this.emmitToken(\"EOF\", EOF); return this.start; }} 3.3 在整数（inInt）状态start 状态下输入输入数字（0 ～ 9）就会迁移到 inInt 状态。 inInt 状态下输入输入符号（.）就会迁移到 inFloat 状态。 inInt 状态下输入数字（0 ～ 9）就继续留在 inInt 状态。 inInt 状态下输入非数字和.（0 ～ 9 .）就会就会输出 「整数 Token」 ，并迁移到 start 状态。 代码： 12345678910111213inInt(char) { if ([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"].includes(char)) { this.token.push(char); return this.inInt; } else if (char === '.') { this.token.push(char); return this.inFloat; } else { this.emmitToken(\"NUMBER\", this.token.join(\"\")); this.token = []; return this.start(char); // put back char }} 3.4 在浮点数（inFloat）状态start 状态下输入符号（.）就会迁移到 inFloat 状态。 inInt 状态下输入输入符号（.）就会迁移到 inFloat 状态。 inFloat 状态下输入数字（0 ～ 9）就继续留在 inFloat 状态。 inFloat 状态下输入非数字（0 ～ 9 ）就会就会输出 「浮点数 Token」，并迁移到 start 状态。 代码： 12345678910111213inFloat(char) { if ([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"].includes(char)) { this.token.push(char); return this.inFloat; } else if (char === \".\") { throw new Error(\"不能出现`..`\"); } else { if (this.token.length === 1 &amp;&amp; this.token[0] === \".\") throw new Error(\"不能单独出现`.`\"); this.emmitToken(\"NUMBER\", this.token.join(\"\")); this.token = []; return this.start(char); // put back char }} 3.5 输出的 Token 种类 和定义我将 「浮点数 Token」 和 「整数 Token」 合并为 [NUMBER Token] , 其他的 Token 还有 「SIGN Token」 和 「EOF Token」。 Token 的 定义： 1234interface Token{ type:String, value:String,} 3.6 完整的 Lexer 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const EOF = Symbol('EOF');class Lexer { constructor(){ this.token = []; // 临时 token 字符存储 this.tokens = []; // 生成的正式 token // state 默认是 start 状态，后面通过 push 函数实现状态迁移 this.state = this.start; } start(char) { // 数字 if ([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"].includes(char)) { this.token.push(char); return this.inInt; } // . if (char === \".\"){ this.token.push(char); return this.inFloat; } // 符号 if ([\"+\",\"-\",\"*\",\"/\"].includes(char)) { this.emmitToken(\"SIGN\", char); return this.start; } // 结束符 if (char === EOF){ this.emmitToken(\"EOF\", EOF); return this.start; } } inInt(char) { if ([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"].includes(char)) { this.token.push(char); return this.inInt; } else if (char === '.') { this.token.push(char); return this.inFloat; } else { this.emmitToken(\"NUMBER\", this.token.join(\"\")); this.token = []; return this.start(char); // put back char } } inFloat(char) { if ([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"].includes(char)) { this.token.push(char); return this.inFloat; } else if (char === \".\") { throw new Error(\"不能出现`..`\"); } else { if (this.token.length === 1 &amp;&amp; this.token[0] === \".\") throw new Error(\"不能单独出现`.`\"); this.emmitToken(\"NUMBER\", this.token.join(\"\")); this.token = []; return this.start(char); // put back char } } emmitToken(type, value) { this.tokens.push({ type, value, }) } push(char){ // 每次执行 state 函数都会返回新的状态函数，实现状态迁移 this.state = this.state(char); return this.check(); } end(){ this.state(EOF); return this.check(); } check(){ // 检测是否有 token 生成并返回。 const _token = [...this.tokens]; this.tokens = []; return _token; } clear(){ this.token = []; this.tokens = []; this.state = this.start; }}const lexer = new lexer();const input = `1 + 2.3`;let tokens = [];for (let c of input.split('')){ tokens = [...tokens,...lexer.push(c)];}tokens = [...tokens,...lexer.end()]; 效果如下图： 自此，我们成功实现了词法分析，后面进入到语法分析。 4 语法分析（Parser）前面的词法分析，已经将字符串划分成一个个有意义的 Token 进入到语法分析（Parser）。语法分析在编译原理里面属于比较高深的学问，我是没有怎么看懂。但总的来说就是把 Token流 组装成 AST ，AST 的结构是既定的，后面我就通过对不同节点制定不同规则把 AST 组装起来。 4.1 定义 AST 结构 和 节点（Node）简单来说 AST 就是一棵树形结构，由节点（Node）和 叶子（字面量 Literal ）组成，节点 下面可以连接 其他节点 或者 字面量。最顶端的节点就是 根节点。 节点的定义就是一个简单的 javascript Object 12345interface Node { type:string, children:[],// children栈 里面可以是 Node 或者 Literal maxChildren:number,} 4.2 栈 和 根节点（Root）语法分析（Parser）这里，我使用的是一个栈结构，每来一个 Token 就入栈，然后通过一定的规则组装 AST。 第一步就是压入 根节点 &lt;Root&gt;。 123456789function RootNode(){ return { type:\"ROOT\", children:[], maxChildren:0, }}const stack = [RootNode()]; 4.3 通用规则在说明不同类型节点的规则前，先说一下通用规则。 没有后代的节点（NoChildrenNode），就是节点的 maxChildren 属性为 0。 非满的节点（NotFullNode），就是节点的 maxChildren 属性大于 0，而且其 children.length &lt; maxChildren。 满的节点（FullNode），就是节点的 maxChildren 属性大于 0，而且其 children.length &gt;= maxChildren。 对应的3个函数: 12345678910111213function isFullNode(node){ if (isNoChildrenNode(node)) return false; return node &amp;&amp; node.children &amp;&amp; node.children.length &gt;= node.maxChildren;}function isNotFullNode(node){ if (isNoChildrenNode(node)) return false; return node &amp;&amp; node.children &amp;&amp; node.children.length &lt; node.maxChildren;}function isNoChildrenNode(node){ return node.maxChildren === 0;} 4.4 数字节点（Number）定义一个数字节点，其children就是 数字字面量。 1234567function NumberNode(){ return { type:\"NUMBER\", children:[...arguments], maxChildren:1, // 只能有一个 child }} 4.5 数字节点的规则 找到栈顶 top 和数字节点 number top 不能是满项 如果 top 为非满的节点，number push 到 top.children 否则（top 是没有后代的节点），number 压栈 123456789101112const top = stack[stack.length - 1]; // 栈顶if (token.type === \"NUMBER\") { // 1 1 // 1 + 1 1 if (isFullNode(top)) throw new Error(\"数字前一项不能是满项\") const number = CreateTypeNode(token.type)(token.value); if (isNotFullNode(top)){ return topChildPush(number); } else { return stackPush(number); }} 4.6 符号节点（Sign + - * /）定义一个符号节点，其 children 可以是 字面量 或者 其他节点。 12345678910111213141516171819202122232425262728function AddNode(){ return { type:\"+\", children:[...arguments], maxChildren:2, // 能有两个 child }}function SubNode(){ return { type:\"-\", children:[...arguments], maxChildren:2, // 能有两个 child }}function MulNode(){ return { type:\"*\", children:[...arguments], maxChildren:2, // 能有两个 child }}function DivNode(){ return { type:\"/\", children:[...arguments], maxChildren:2, // 能有两个 child }} 4.7 节点的优先级大家都知道，运算符有优先级，例如 * / 的优先级就比 + - 要高。我把这个优先级扩展到全部节点，所有节点都有一个优先级数值。 12345678const operatorValue = { \"ROOT\" : 0, \"+\" : 1, \"-\" : 1, \"*\" : 2, \"/\" : 2, \"NUMBER\" : 3,} 这个数值后面马上就会用到。 4.8 retire 操作我们回到 1 + 2.3 这个算术表达式。前面说到 1 这个 Token 已经压入栈了，现在轮到 + Token 。 栈顶 top （就是 number 1） 符号节点 add top 是满的节点，所以 add 是后置符号，进入后置符号规则 比较 top 节点与 符号 add 节点 的优先级数值 top &lt; add 执行 rob 操作 ，否则 执行 retire 操作 123456789101112// 后置符号 if (isFullNode(top)) { if (operatorValue[token.value] &gt; operatorValue[top.type]){ // 1 + 2 * return rob(token.value,top.children); } else { // 1 + // 1 + 2 + link(token.value); return retire(token.value); } } 先说 retire 操作，retire 有退休的意思。我是想表达，这当前条件下，栈顶节点可以退下来了，把栈顶的位置让给新节点。 步骤是把的旧栈顶节点出栈，新节点入栈，然后旧栈顶压进新节点的 children 栈里。 123const retire = (type) =&gt; { stack.push(CreateTypeNode(type)(stack.pop()));} 然后到2.3 Token，根据前面的规则，因为栈顶的 add 节点是非满节点，2.3 构建成 number 节点 后，直接 push 到 add 节点的 children 栈里。 文字有点干，我们配合图一起看。 4.9 rob 操作前面提到 retire 操作的反向条件是 rob 操作。先来看一个例子1 + 2.3 * 4。 接上一节，现在栈里是&lt;Root&gt;,&lt;+ 1 2.3&gt;，现需要压入新节点 mul，同样的 mul 节点和栈顶 add 节点比较， 优先级 mul &gt; add，执行 rob 操作。 rob 操作 很好理解，因为乘法比加法的优先级要高，所以本来属于 add 节点 下的 number(2.3) 要被 mul 节点抢走了。 12345const rob = (type,children) =&gt;{ const child = children.pop(); stack.push(CreateTypeNode(type)(child));}rob(token.value,top.children); mul 节点抢走 number(2.3) 后放压进自己的 children 栈里，然后 mul 节点入栈，成为新的栈顶。 然后到4 Token，根据前面的规则，因为栈顶的 mul 节点是非满节点，4 构建成 number 节点 后，直接 push 到 mul 节点的 children 栈里。 文字还是有点干，我们配合图一起看。 4.10 link 操作细心的朋友应该会发现，在执行 retire 操作之前还执行了一个 link 操作。这个 link 是做啥的呢？我们来看一个例子1 + 2.3 * 4 - 5。 接上一节，栈里现在是&lt;Root&gt;,&lt;+ 1&gt;,&lt;* 2.3 4&gt;，现在准备压入 sub 节点，因为优先级上 sub &lt; mul ，如果先忽略 link 直接走 retire 操作，就会变成&lt;Root&gt;,&lt;+ 1&gt;,&lt;- &lt;* 2.3 4&gt;&gt;。这个不是我想要的结果，因为+和-优先级是相同的，相同优先级应该先计算先出现的符号，理想的操作下，栈里应该变成&lt;Root&gt;,&lt;- &lt;+ 1 &lt;* 2.3 4&gt;&gt;&gt;。所以我引入了 link 操作。 link 操作会先将栈顶的满项节点 push 到前一项的 childen 栈里（如果前一项是非满节点），而且这是一个循环操作 直到 前一项是满节点 或者 前一项节点的优先级比新节点的还要低。 回看上面的例子，栈里现在是 &lt;Root&gt;,&lt;+ 1&gt;,&lt;* 2.3 4&gt; ，现在准备压入 sub 节点，因为优先级上 sub &lt; mul ，先在 link 操作下变成 &lt;Root&gt;,&lt;+ 1 &lt;* 2.3 4&gt;&gt; ，然后执行 retire ，变成 &lt;Root&gt;,&lt;- &lt;+ 1 &lt;* 2.3 4&gt;&gt;&gt; 。 12345678910function typeValue(node){ if (node === undefined) throw new Error(\"node is undefined\"); return operatorValue[node.type];}const link = (type) =&gt;{ const value = operatorValue[type]; while(isFullNode(stack[stack.length -1]) &amp;&amp; isNotFullNode(stack[stack.length - 2]) &amp;&amp; (value &lt;= typeValue(stack[stack.length -1])) &amp;&amp; (value &lt;= typeValue(stack[stack.length -2])) ) { stack[stack.length - 2].children.push(stack.pop()); }} 然后到 5 Token，根据前面的规则，因为栈顶的 sub 节点是非满节点，5 构建成 number 节点 后，直接 push 到 mul 节点的 children 栈里。 继续上图。 4.13 增加负数负数可以说是开了一个比较坏的先河，因为和减号公用一个 - 符号，导致代码逻辑的增加。负号和减号的区别在于，负号的取值是在它的右侧 1 + - 1 ，减号是从左到右 1 - 1 。这里可以通过判断栈顶节点的情况来确定究竟是 负号 还是 减号。我将 负号这种取值在右边的符号称为 前置符号 ，加减乘除这种左到右取值的符号称为 后置符号。前置符号直接压栈。 1234567891011121314151617181920212223242526272829303132// 定义负数节点function NegNode(){ return { type:\"NEGATE\", children:[...arguments], maxChildren:1, }}if (token.type === \"SIGN\") { // 后置符号 if (isFullNode(top)) { if (operatorValue[token.value] &gt; operatorValue[top.type]){ // 1 + 2 * // console.log(\"rob\"); return rob(token.value,top.children); } else { // 1 + // 1 + 2 + link(token.value); return retire(token.value); } } // 前置符号 if ( (isNoChildrenNode(top)) || // (- (isNotFullNode(top)) // 1 + - ){ if (token.value === \"-\") return stackPush(CreateTypeNode(\"NEGATE\")()); // 取负公用符号 - if (token.value === \"+\") return ; // + 号静默 throw new Error(token.value + \"符号不能前置\"); }} 例子 - 1 。 - 1 这里开始栈 &lt;Root&gt; ，然后准备压入 - ，因为 Root 节点是没有后代的节点（NoChildrenNode），所以这里判断-是前置符号，生成 NE（NEGATE） 节点直接入栈 &lt;Root&gt;&lt;NE&gt; 。然后是 1 , &lt;Root&gt;&lt;NE 1&gt; 。 例子 1 - - 1 。这里第一个 - 时 &lt;Root&gt;&lt;1&gt; ，因为 栈顶 number 节点是满的节点（FullNode），所以第一个 - 是后置符号，生成 sub 节点。第二个 - 时 &lt;Root&gt;&lt;- 1&gt;，栈顶的 sub 节点是未满的节点（NotFullNode），判定为前置符号，生成 NE（NEGATE） 节点直接入栈 &lt;Root&gt;&lt;- 1&gt;&lt;NE&gt; 。然后是 1 , &lt;Root&gt;&lt;- 1&gt;&lt;NE 1&gt; 。 4.14 增加括号括号 ( 可以改变表达式里的优先级，先定义括号节点。 首先需要在 词法分析 的时候加入 ( 。 123456// start 状态里// 符号if ([\"+\",\"-\",\"*\",\"/\",\"(\"].includes(char)) { this.emmitToken(\"SIGN\", char); return this.start;} 1234567function ParNode(){ return { type:\"(\", children:[], maxChildren:0, }} 这里 maxChildren 设为 0 ，当我们将 括号节点 push 到栈里时，就形成一个屏障，使后面节点变动时，不会越过 括号节点 。 看例子 1 * (2 + 3 * 4) 。 123456789 `&lt;Root&gt;` 1 `&lt;Root&gt;&lt;1&gt;`* `&lt;Root&gt;&lt;* 1&gt;`( `&lt;Root&gt;&lt;* 1&gt;&lt;(&gt;` // ( 隔离2 `&lt;Root&gt;&lt;* 1&gt;&lt;(&gt;&lt;2&gt;` // 把 2 和 * 隔离+ `&lt;Root&gt;&lt;* 1&gt;&lt;(&gt;&lt;+ 2&gt;` 3 `&lt;Root&gt;&lt;* 1&gt;&lt;(&gt;&lt;+ 2 3&gt;` * `&lt;Root&gt;&lt;* 1&gt;&lt;(&gt;&lt;+ 2&gt;&lt;* 3&gt;` 4 `&lt;Root&gt;&lt;* 1&gt;&lt;(&gt;&lt;+ 2&gt;&lt;* 3 4&gt;` 参考代码。 1234567if (token.value === \"(\" ) { // 1( // 1 + 1 ( if (isFullNode(top)) throw new Error(\"not a function\"); // ( return stackPush(CreateTypeNode(\"(\")());} 4.14 增加反括号 与 remove 操作反括号 ) 的作用是将当前括号后面添加的节点收缩成一个稳定节点，具体方法是把 ( 后面的节点 link 起来( ( 的优先级设定得比较小，旨在将括号里的节点都连接起来)，并推到一个临时的栈里，然后将 ( 节点 改写成 ) 节点 ，再将临时栈的节点出栈 push 到 ) 节点的 children 里。还因为 ) 节点的优先级别设置了很高，不用担心会被后面的节点 rob 。 首先需要在 词法分析 的时候加入 ) 。 123456// start 状态里// 符号if ([\"+\",\"-\",\"*\",\"/\",\"(\",\")\"].includes(char)) { this.emmitToken(\"SIGN\", char); return this.start;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (token.value === \")\" ) { // () if (isNoChildrenNode(top)) throw new Error(\"Unexpected token )\"); // (1+) if (isNotFullNode(top)) throw new Error(\"Unexpected token )\"); return remove(\"(\"); // 收拢 (}const remove = (type) =&gt; { link(type); // 找到最近的( 其余push到tempStack while(stack.length &gt; 0 &amp;&amp; !(stack[stack.length - 1].type === type &amp;&amp; !stack[stack.length - 1].children)){ tempStack.push(stack.pop()); } // 修改最近的( const top = stack[stack.length - 1]; if (top.type === type){ top.type = opposite[type]; // 取反 ( =&gt; ) top.children = []; // tempStack的Node压给( while(tempStack.length &gt; 0){ top.children.push(tempStack.pop()); } top.maxChildren = top.children.length; // maxChildren 设满 } }const operatorValue = { \"ROOT\" : 0, \"(\" : 1, // 括号的优先级低，方便 link \"+\" : 2, \"-\" : 2, \"*\" : 3, \"/\" : 3, \"NEGATE\" : 4, // 取负 \"NUMBER\" : 5, // 取正 \")\" : 6, // 反括号的优先级高，防止被 rob \"ROOT_END\" : 7,}const opposite = { \"(\" : \")\" , \"ROOT\" : \"ROOT_END\",} 4.15 EOF括号的作用是将其内部的节点包裹起来，形成一个稳定的节点，括号 ( 和反括号 ) 自成一对。还有一对有同样的功能，就是 ROOT 和 ROOT_END 。 ROOT 和 ROOT_END 标示着这个表达式的开始和结束。 ROOT 节点是初始化时就添加的，那么 ROOT_END 对应就是 EOF 这个 Token 了。 1234if (token.type === \"EOF\") { // EOF return remove(\"ROOT\");}; 来一个完整的流程gif。 5 计算求值EOF 后，我们就可以得到抽象语法树 AST 了。因为是树形结构，我们可以用递归的方法求值。 1234567891011121314151617181920212223242526272829303132333435363738394041`1 * ( 2 + 3 * 4)`const ast = { \"type\": \"ROOT_END\", \"children\": [{ \"type\": \"*\", \"children\": [{ \"type\": \"NUMBER\", \"children\": [\"1\"], }, { \"type\": \")\", \"children\": [{ \"type\": \"+\", \"children\": [{ \"type\": \"NUMBER\", \"children\": [\"2\"], }, { \"type\": \"*\", \"children\": [{ \"type\": \"NUMBER\", \"children\": [\"3\"], }, { \"type\": \"NUMBER\", \"children\": [\"4\"], }], }], }], }], }],}function evaluate(node){ const {type,children} = node; if (type === \"NUMBER\") return Number(children[0]); if (type === \"+\") return evaluate(children[0]) + evaluate(children[1]); if (type === \"-\") return evaluate(children[0]) - evaluate(children[1]); if (type === \"*\") return evaluate(children[0]) * evaluate(children[1]); if (type === \"/\") return evaluate(children[0]) / evaluate(children[1]); if (type === \")\") return evaluate(children[0]); if (type === \"ROOT_END\") return evaluate(children[0]); if (type === \"NEGATE\") return evaluate(children[0]) * -1;}console.log(evaluate(ast)); // 14 6 小结写到这里，一个简单的四则运算解析器总算完成了。一共分 3 大部分。分别是 词法分析（Lexer）、语法分析（Parser）、计算求值（evaluate）。 词法分析（Lexer）是将 表达式 字符串 转化为 Token 流，这里用到有限状态机。 语法分析（Parser）是将 Token 流 转化为 抽象语法树（AST），这里主要是手工写的语法分析，用了 两个栈 ，规定了 4 个方法 link 、 retire 、 rob 、 remove，还有定义了不同节点的入栈规则。 计算求值（evaluate）是将 AST 计算出表达式的 值，这里用了递归求值。 7 应用之自定义的向量运算弄清楚四则运算的解析方法后，我们可以创造自己制定规则的表达式运算了。 因为之前的项目我写过向量运算，但是因为函数调用的写法有点丑陋，我这里就尝试自定义向量运算表达式。 7.1 向量表示之引入符号（Sign [ , ]）这里一个 2维向量 我用 [1,2] 来表示。所以先在 词法分析（Lexer）里增加 [,] 。 123456// start 状态里// 符号if ([\"+\",\"-\",\"*\",\"/\",\"(\",\")\",\"[\",\",\",\"]\"].includes(char)) { this.emmitToken(\"SIGN\", char); return this.start;} [ 和 ] 是一对，本质和括号对 ( ) 没什么区别。 , 其定位就是一个分割符，没有成对子。而且 , 出现后，其前面的节点都要 link 起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function VecNode(){ return { type:\"[\", children:[], maxChildren:0, }}function WallNode(){ return { type:\",\", children:[], maxChildren:0, }}const opposite = { \"(\" : \")\" , \"[\" : \"]\" , \"ROOT\" : \"ROOT_END\" ,}if (token.value === \"[\" ) { // 1[ // 1 + 1 [ if (isFullNode(top)) throw new Error(\"非顶端[前面不能有满项\"); return stack.push(CreateTypeNode(\"[\")());}if (token.value === \",\" ) { // , // ,, // (, // [, if (isNoChildrenNode(top)) throw new Error(\",不能接在空符后面\"); // [ 1 + , if (isNotFullNode(top)) throw new Error(\",不能接在非满项后面\"); link(\"[\"); return stack.push(CreateTypeNode(\",\")());}if (token.value === \"]\" ) { // [1+] if (isNotFullNode(top)) throw new Error(\"]前不能有非满项\"); return remove(\"[\");} 例子 [ 1 + 2 * 3 , 4 + 5 * 6 ] 。 12345678910111213141516 `&lt;Root&gt;`[ `&lt;Root&gt;&lt;[&gt;` 1 `&lt;Root&gt;&lt;[&gt;&lt;1&gt;` + `&lt;Root&gt;&lt;[&gt;&lt;+ 1&gt;` 2 `&lt;Root&gt;&lt;[&gt;&lt;+ 1 2&gt;` * `&lt;Root&gt;&lt;[&gt;&lt;+ 1&gt;&lt;* 2&gt;` 3 `&lt;Root&gt;&lt;[&gt;&lt;+ 1&gt;&lt;* 2 3&gt;` , `&lt;Root&gt;&lt;[&gt;&lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;` 4 `&lt;Root&gt;&lt;[&gt;&lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;4&gt;` + `&lt;Root&gt;&lt;[&gt;&lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;+ 4&gt;` 5 `&lt;Root&gt;&lt;[&gt;&lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;+ 4 5&gt;` * `&lt;Root&gt;&lt;[&gt;&lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;+ 4&gt;&lt;* 5&gt;` 6 `&lt;Root&gt;&lt;[&gt;&lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;+ 4&gt;&lt;* 5 6&gt;` ] `&lt;Root&gt;&lt;[&gt;&lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;+ 4&lt;* 5 6&gt;&gt;` `&lt;Root&gt;&lt;] &lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;+ 4&lt;* 5 6&gt;&gt;&gt;` EOF `&lt;RootEnd &lt;] &lt;+ 1 &lt;* 2 3&gt;&gt;&lt;,&gt;&lt;+ 4&lt;* 5 6&gt;&gt;&gt;&gt;` 最后在 evaluate 方法里增加对向量的支持。 12345678910111213// evaluate 里if (type === \"]\") { const notWall = children.filter(item =&gt; item.type !== \",\"); const a = evaluate(notWall[0]); const b = evaluate(notWall[1]); const isNumA = typeof a === \"number\"; const isNumB = typeof b === \"number\"; if (isNumA &amp;&amp; isNumB) { return new Vector2d(a,b); } else { throw new Error(\"只有两个数量才能生成向量\"); }} 7.2 向量加减乘除法取负向量加减乘除法取负继续源用 + , - , * , / 符号，只需要在 evaluate 方法里做判断就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// evaluate 里if (type === \"+\") { const a = evaluate(children[0]); const b = evaluate(children[1]); if (Vector2d.is(a) &amp;&amp; Vector2d.is(b)){ return Vector2d.add(a,b); } else { return a + b; }}if (type === \"-\") { const a = evaluate(children[0]); const b = evaluate(children[1]); if (Vector2d.is(a) &amp;&amp; Vector2d.is(b)){ return Vector2d.sub(a,b); } else { return a - b; }}if (type === \"*\" || type === \"/\") { const a = evaluate(children[0]); const b = evaluate(children[1]); const isVecA = Vector2d.is(a); const isVecB = Vector2d.is(b); const isNumA = typeof a === \"number\"; const isNumB = typeof b === \"number\"; if ( isNumA &amp;&amp; isNumB ){ if (type === \"*\") return a * b; if (type === \"/\") return a / b; } else if(isVecA &amp;&amp; isNumB) { if (type === \"*\") return Vector2d.scale(a,b); if (type === \"/\") return Vector2d.scale(a,1/b); } else if (isVecB &amp;&amp; isNumA) { if (type === \"*\") return Vector2d.scale(b,a); if (type === \"/\") return Vector2d.scale(b,1/a); } else { throw new Error(\"两个向量不能相乘，请用@dot\"); }}if (type === \"NEGATE\") { const a = evaluate(children[0]); if (Vector2d.is(a)){ return Vector2d.scale(a,-1); } else { return a * -1; }} 7.3 向量旋转、点乘，角度的单位转换向量的旋转（@rot）、点乘（@dot），角度的单位转换（@deg），用这3个自定义符号。 这里需要修改一下 词法分析 的状态机，在 start 状态下新增一个跃迁状态 customSgin 用 @ 为标识。然后 customSgin 状态下输入[a-zA-Z]都回跃迁自身 否则 跃迁回状态 start 并输出 Token。 123456789101112131415161718192021222324252627282930313233343536373839404142// Lexer 里 start(char) { // 数字 if ([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"].includes(char)) { this.token.push(char); return this.inInt; } // . if (char === \".\"){ this.token.push(char); return this.inFloat; } // 符号 if ([\"+\",\"-\",\"*\",\"/\",\"(\",\")\",\"[\",\"]\",\",\",\"&lt;\",\"&gt;\"].includes(char)) { this.emmitToken(\"SIGN\", char); return this.start } // 空白字符 if ([\" \",\"\\r\",\"\\n\"].includes(char)) { return this.start; } // 结束 if (char === EOF){ this.emmitToken(\"EOF\", EOF); return this.start } if (char === \"@\"){ this.token.push(char); return this.customSgin; } } customSgin(char) { if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\").includes(char)) { this.token.push(char); return this.customSgin; } else { this.emmitToken(\"SIGN\", this.token.join(\"\")); this.token = []; return this.start(char); // put back char } } 然后定义节点和节点优先级。 12345678910111213141516171819202122232425262728293031323334353637383940function DegNode(){ return { type:\"@deg\", children:[...arguments], maxChildren:1, }}function DotNode(){ return { type:\"@dot\", children:[...arguments], maxChildren:2, }}function RotNode(){ return { type:\"@rot\", children:[...arguments], maxChildren:2, }}const operatorValue = { \"ROOT\" : 0, \"(\" : 1, \"[\" : 1, \"@dot\" : 2, // 向量点乘 \"&lt;\" : 3, \"&gt;\" : 3, \"+\" : 4, \"-\" : 4, \"*\" : 5, \"/\" : 5, \"@rot\" : 5, // 向量旋转 \"NEGATE\" : 6, // 取负 \"@deg\" : 7, // 角度转换 \"NUMBER\" : 8, // 取正 \")\" : 9, \"]\" : 9, \"ROOT_END\" : 10,} 还有在 evaluate 里写对应的方法。 1234567891011121314151617181920212223242526272829303132333435if (type === \"@dot\"){ const a = evaluate(children[0]); const b = evaluate(children[1]); const isVecA = Vector2d.is(a); const isVecB = Vector2d.is(b); if (isVecA &amp;&amp; isVecB) { return Vector2d.dot(a,b); } else { throw new Error(\"只有向量和向量能点乘\"); }}if (type === \"@rot\"){ const a = evaluate(children[0]); const b = evaluate(children[1]); const isVecA = Vector2d.is(a); const isVecB = Vector2d.is(b); const isNumA = typeof a === \"number\"; const isNumB = typeof b === \"number\"; if (isVecA &amp;&amp; isNumB) { return Vector2d.rotate(a,b); } else if (isVecB &amp;&amp; isNumA) { return Vector2d.rotate(b,a); } else { throw new Error(\"只有向量和数量能旋转\"); }}if (type === \"@deg\"){ const a = evaluate(children[0]); const isNumA = typeof a === \"number\"; if (isNumA){ return a / 180 * Math.PI; } else { throw new Error(\"非数字不能转换deg\"); }} 来一个例子 [1, 0] @rot - 90 @deg ,把 [1,0] 旋转负 90 度。 8 Demo手动玩最后结合 Vue 写了一个 表达式转 AST 的可视化 demo，支持数字和向量。 http://rococolate.github.io/blog/ast/index.html demo 源码: https://github.com/Rococolate/ast_demo","link":"/2019/10/17/写一个四则运算表达式转换成AST的方法/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS Houdini","slug":"CSS-Houdini","link":"/tags/CSS-Houdini/"},{"name":"AST","slug":"AST","link":"/tags/AST/"},{"name":"web内容","slug":"web内容","link":"/tags/web内容/"},{"name":"电池电量","slug":"电池电量","link":"/tags/电池电量/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"},{"name":"资源治理","slug":"资源治理","link":"/tags/资源治理/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/前端工程化/"},{"name":"webpack loader","slug":"webpack-loader","link":"/tags/webpack-loader/"},{"name":"工程化","slug":"工程化","link":"/tags/工程化/"},{"name":"V8引擎","slug":"V8引擎","link":"/tags/V8引擎/"},{"name":"字体","slug":"字体","link":"/tags/字体/"},{"name":"折叠屏适配","slug":"折叠屏适配","link":"/tags/折叠屏适配/"},{"name":"设计原则","slug":"设计原则","link":"/tags/设计原则/"},{"name":"碰撞检测","slug":"碰撞检测","link":"/tags/碰撞检测/"},{"name":"向量","slug":"向量","link":"/tags/向量/"},{"name":"引导蒙层","slug":"引导蒙层","link":"/tags/引导蒙层/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"type=\"module\"","slug":"type-module","link":"/tags/type-module/"},{"name":"代码拆分","slug":"代码拆分","link":"/tags/代码拆分/"},{"name":"rollup打包","slug":"rollup打包","link":"/tags/rollup打包/"},{"name":"modulepreload","slug":"modulepreload","link":"/tags/modulepreload/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"桌面开发","slug":"桌面开发","link":"/tags/桌面开发/"},{"name":"Mocha","slug":"Mocha","link":"/tags/Mocha/"},{"name":"BDD/TDD","slug":"BDD-TDD","link":"/tags/BDD-TDD/"},{"name":"测试框架","slug":"测试框架","link":"/tags/测试框架/"},{"name":"composite","slug":"composite","link":"/tags/composite/"},{"name":"Vue.compile","slug":"Vue-compile","link":"/tags/Vue-compile/"},{"name":"CPU性能优化","slug":"CPU性能优化","link":"/tags/CPU性能优化/"},{"name":"火焰图","slug":"火焰图","link":"/tags/火焰图/"},{"name":"Interection Observer","slug":"Interection-Observer","link":"/tags/Interection-Observer/"},{"name":"滚动优化","slug":"滚动优化","link":"/tags/滚动优化/"}],"categories":[{"name":"Web开发","slug":"Web开发","link":"/categories/Web开发/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Web前端","slug":"Web前端","link":"/categories/Web前端/"}]}