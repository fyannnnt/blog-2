{"pages":[{"title":"WecTeam | 京东社交电商前端团队","text":"维C团简介维C团(WecTeam)是京东社交电商部一群热爱技术、乐于分享的前端工程师自发成立的一个前端技术团队，希望通过技术实践总结、新技术探秘、Bug深度分析、优质英文资料引入等方式，参与和推动前端技术的发展，为公司及行业带来价值！ 联系我们","link":"/about/index.html"}],"posts":[{"title":"Javascript抽象语法树上篇(基础篇)","text":"作者：陈晓强 一、基础为什么要了解抽象语法树日常工作中，我们会碰到js代码解析的场景，比如分析代码中require了哪些包，有些什么关键API调用，大部分情况使用正则表达式来处理，可一旦场景复杂，或者依赖于代码上下文时，正则就很难处理了，这时候就要用到抽象语法树。常见的uglify、eslint、babel、webpack等等都是基于抽象语法树来处理的，如此强大，有必要好好了解一下。 什么是抽象语法树抽象语法树即：Abstract Syntax Tree。简称AST，见下图。 图中code先经过parse转换成一个树状数据结构 接着对树中节点进行转换，图中将叶子节点对换位置 将树状结构通过generate再生成code 图中树状数据结构即AST，从这个过程可以看到将代码转成AST后，通过操作节点来改变代码。 如何获得抽象语法树获得抽象语法树的过程为：代码 =&gt; 词法分析 =&gt; 语法分析 =&gt; AST词法分析：把字符串形式的代码转换为令牌（tokens）流。语法分析：把一个令牌流转换成 AST 的形式。这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。如下图，代码为一个简单的函数声明。词法分析阶段，将代码作为字符串输入获得关键词，图中function、square、(、)、{、}等都被识别为关键词(稍微回忆下编译原理，字符挨个入栈，符合一定规则即出栈)。语法分析阶段，对关键词的组合形成一个个节点，如n*n这3个关键词组合成二元表达式，关键词return与二元表达式组合成return语句。最后组合成一个函数声明语句。 二、规范如何获得AST已经简单介绍了，那AST最终应该以什么样的数据结构存在呢，先看看上述函数声明的AST结构 那解析的依据是什么，为什么要以上图的结构出现，业界已经有了一套成熟的规范。 规范起源在v8引擎之前，最早js引擎是SpiderMonkey，第一个版本由js作者Brendan Eich设计，后交给Mozilla组织维护。js引擎在执行js文件时，都会先将js代码转换成抽象语法树(AST)。有一天，一位Mozilla工程师在FireFox中公开了这个将代码转成AST的解析器Api，也就是Parser_API[1]，后来被人整理到github项目estree[2]，慢慢的成了业界的规范。 规范解读上面提到的Parser_API是规范的原文，中文版:Parser_API[3]，但读起来并不太友好，推荐直接读整理后的git项目estree，打开项目地址，如下图其中最下面的es5.md为ES5规范，仅列出ES5的内容，es2015.md为ES6规范，但只列出了针对ES5新增的内容，依次类推，最后的es2019.md即ES10是对ES9的补充，仅有一条规则。 打开最基础的es5.md，可以看到所有语法基础，这里跟大家一起读一下大类，细分类别就略过了。读规范时可以使用https://astexplorer.net/ 辅助阅读，可以实时输出AST。 Node objects Programs Identifier Literal Functions Statements Declarations Expressions Patterns Node objects1234interface Node { type: string; loc: SourceLocation | null;} 定义AST中节点基本类型，其他所有具体节点都需要实现以上接口，即每个节点都必须包含type、loc两个字段 type字段表示不同的节点类型，下边会再讲一下各个类型的情况，分别对应了 JavaScript 中的什么语法。你可以从这个字段看出这个节点实现了哪个接口loc字段表示源码的位置信息，如果没有相关信息的话为 null，否则是一个对象，包含了开始和结束的位置。接口如下 12345interface SourceLocation { source: string | null; start: Position; end: Position;} 每个 Position 对象包含了行（从1开始）和列（从0开始）信息，接口如下 1234interface Position { line: number; // &gt;= 1 column: number; // &gt;= 0} Programs1234interface Program &lt;: Node { type: \"Program\"; body: [ Directive | Statement ];} 一棵完整的程序代码树，一般作为根节点 Identifier1234interface Identifier &lt;: Expression, Pattern { type: \"Identifier\"; name: string;} 标识符，我们写代码时自定义的名称，如变量名、函数名、属性名。 Literal1234interface Literal &lt;: Expression { type: \"Literal\"; value: string | boolean | null | number | RegExp;} 字面量，如“hello”、true、null、100、/\\d/这些，注意字面量本身也是一个表达式语句(ExpressionStatement) Functions12345interface Function &lt;: Node { id: Identifier | null; params: [ Pattern ]; body: FunctionBody;} 一个函数声明或者表达式，id是函数名，params是标识符数组，body是函数体，也是一个语句块。 Statements1interface Statement &lt;: Node { } 语句，子类有很多，块语句、if/switch语句、return语句、for/while语句、with语句等等 Declarations1interface Declaration &lt;: Statement { } 声明，子类主要有变量申明、函数声明。 Expressions1interface Expression &lt;: Node { } 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式(a = 1)等等 Patterns1interface Pattern &lt;: Node { } 模式，主要在 ES6 的解构赋值中有意义(let {name} = user，其中{name}部分为ObjectPattern)，在 ES5 中，可以理解为和Identifier 差不多的东西。 三、现状通过以上规范解读，知道了最终要生成的AST以什么样的结构存在，对于javascript的解析，业界已经有很多成熟的解析器，可以将js代码转换成符合规范的AST Esprima，比较经典，出现的比较早 Acorn，fork自Esprima，代码更精简。webpack使用acorn进行模块解析 UglifyJS2，主要用于代码压缩 babylon，babel解析器，fork自Acorn，目前最新版本是babylon7,对应npm包@babel/parser Espree，eslint默认的解析器，由于遵循同一套规范，也可以使用babel的解析器替代 flow、shift等等 AST基础篇介绍完毕，下篇将从实践的角度继续介绍 References[1] Parser_API：https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API[2] estree：https://github.com/estree/estree[3] Parser_API(中文)：https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API","link":"/2019/07/19/Javascript抽象语法树上篇(基础篇)/"},{"title":"CSS Houdini实现动态波浪纹","text":"作者：黄浩群 CSS Houdini 号称 CSS 领域最令人振奋的革新。CSS 本身长期欠缺语法特性，可拓展性几乎为零，并且新特性的支持效率太低，兼容性差。而 Houdini 直接将 CSS 的 API 暴露给开发者，以往完全黑盒的浏览器解析流开始对外开放，开发者可以自定义属于自己的 CSS 属性，从而定制和扩展浏览器的展示行为。 背景我们知道，浏览器在渲染页面时，首先会解析页面的 HTML 和 CSS，生成渲染树（rendering tree），再经由布局（layout）和绘制（painting），呈现出整个页面内容。在 Houdini 出现之前，这个流程上我们能操作的空间少之甚少，尤其是 layout 和 painting 环节，可以说是完全封闭，使得我们很难通过 polyfill 等类似的手段为欠支持的 CSS 特性提供兼容。而另一方面，语法特性的缺失也极大地限制了 CSS 的编程灵活性，社区中 sass、less、stylus 等 CSS 预处理技术的出现大多都源于这个原因，它们都希望通过预编译，突破 CSS 的局限性，让 CSS 拥有更强大的组织和编写能力。所以慢慢地，我们都不再手写 CSS，更方便、更灵活的 CSS 扩展语言成了 web 开发的主角。看到这样的情况，CSS Houdini 终于坐不住了。 什么是 CSS Houdini？CSS Houdini 对外开放了浏览器解析流程的一系列 API，这些 API 允许开发者介入浏览器的 CSS engine 运作，带来了更多的 CSS 解决方案。 CSS Houdini 目前主要提供了以下几个 API： CSS Properties and Values API 允许在 CSS 中定义变量和使用变量，是目前支持程度最高的一个 API。CSS 变量以 -- 开头，通过 var() 调用： 1234div { --font-color: #9e4a9b; color: var(--font-color);} 此外，CSS 变量也可以在其他节点中使用，只不过是有作用域限制的，也就是说自身定义的 CSS 变量只能被自身或自身的子节点使用： 123456.container { --font-color: #9e4a9b;}.container .text { color: var(--font-color);} 定义和使用 CSS 变量可以让我们的 CSS 代码变得更加简洁明了，比如我们可以单纯通过改变变量来改变 box-shadow 的颜色： 1234567.text { --box-shadow-color: #3a4ba2; box-shadow: 0 0 30px var(--box-shadow-color);}.text:hover { --box-shadow-color: #7f2c2b;} Painting API 允许开发者编写自己的 Paint Module，自定义诸如 background-image 这类的绘制属性。自定义的重点在于，”怎么画” 的逻辑需要我们来描述，因此我们利用 registerPaint 来描述我们的绘制逻辑： 12345registerPaint('rect', class { paint(ctx, size, properties, args) { // @TODO }}); registerPaint 方法注册了一个 Paint 类 rect 以供调用，这个类的核心在于它的 paint 方法。paint 方法用于描述自定义的绘制逻辑，它接收四个参数： ctx：一个 Canvas 的 Context 对象，因此 paint 中的绘制方式跟 canvas 绘制是一样的。 size：包含节点的尺寸信息，同时也是 canvas 可绘制范围（画板）的尺寸信息。 properties：包含节点的 CSS 属性，需要调用静态方法 inputProperties 声明注入。 args: CSS 中调用 Paint 类时传入的参数，需要调用静态方法 inputArguments 声明注入。 编写完 Paint 类之后，我们在 CSS 中只需要这样调用，就能应用到我们自定义的绘制逻辑： 123.wrapper { background-image: paint(rect);} Painting API 目前在高版本 Chrome、Opera 浏览器已有支持，且实现起来比较简单，后边我们还将通过 demo 进一步演示。 Layout API允许开发者编写自己的 Layout Module，自定义诸如 display 这类的布局属性。同样的，”如何布局” 的逻辑需要我们自己编写： 1234567891011registerLayout('block-like', class { layout(children, edges, constraints, properties, breakToken) { // @TODO return { // inlineSize: number, // blockSize: number, // autoBlockSize: number, // childFragments: sequence&lt;LayoutFragment&gt; } }}) registerLayout 方法用于注册一个 Layout 类以供调用，它的 layout 方法用于描述自定义的布局逻辑，最终返回一个包含布局后的位置尺寸信息和子节点序列信息的对象，引擎将根据这个对象进行布局渲染。 同样的，调用时只需： 123.wrapper { display: layout('block-like');} 因此利用 Layout API，你完全可以实现对 flex 布局的手工兼容。相比 Painting，Layout 的编写显得更加复杂，涉及到盒模型的深入概念，且支持度不高，这里就不细讲了。 WorkletsregisterPaint、registerLayout 这些 API 在全局上并不存在，为什么可以直接调用呢？这是因为上述的 JS 代码并不是直接执行的，而是通过 Worklets 载入执行的。Worklets 类似于 Web Worker，是一个运行于主代码之外的独立工作进程，但比 Worker 更为轻量，负责 CSS 渲染任务是最合适的了。和 Web Worker 一样，Worklets 拥有一个隔离于主进程的全局空间，在这个空间里，没有 window 对象，却有 registerPaint、registerLayout 这些全局 API。因此，我们需要这样引入自定义 JS 代码： 123if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\");} 123if (\"layoutWorklet\" in CSS) { CSS.layoutWorklet.addModule(\"layoutworklet.js\");} 基础：三步用上 Painting API我们来自定义 background-image 属性，它将用于给作用节点绘制一个矩形背景，背景色值由该节点上的一个 CSS 变量 --rect-color 指定。 1、编写一个 Paint 类：新建一个 paintworklet.js，利用 registerPaint 方法注册一个 Paint 类 rect，定义属性的绘制逻辑： 12345678910registerPaint(\"rect\", class { static get inputProperties() { return [\"--rect-color\"]; } paint(ctx, geom, properties) { const color = properties.get(\"--rect-color\")[0]; ctx.fillStyle = color; ctx.fillRect(0, 0, geom.width, geom.height); }}); 上边定义了一个名为 rect 的 Paint 类，当 rect 被使用时，会实例化 rect 并自动触发 paint 方法执行渲染。paint 方法中，我们获取节点 CSS 定义的 --rect-color 变量，并将元素的背景填充为指定颜色。由于需要使用属性 --rect-color，我们需要在静态方法 inputProperties 中声明。 2、Worklets 加载 Paint 类：HTML 中通过 Worklets 载入上一步骤实现的 paintworklet.js 并注册 Paint 类： 123456&lt;div class=\"rect\"&gt;&lt;/div&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); }&lt;/script&gt; 3、使用 Paint 类：CSS 中使用的时候，只需要调用 paint 方法： 123456.rect { width: 100vw; height: 100vh; background-image: paint(rect); --rect-color: rgb(255, 64, 129);} 可以看得出利用 CSS Houdini，我们可以像操作 canvas 一样灵活自如地实现我们想要的样式功能。 进阶：实现动态波纹根据上述步骤，我们演示一下如何用 CSS Painting API 实现一个动态波浪的效果： 1234567891011121314151617181920212223242526&lt;!-- index.html --&gt;&lt;div id=\"wave\"&gt;&lt;/div&gt;&lt;style&gt; #wave { width: 20%; height: 70vh; margin: 10vh auto; background-color: #ff3e81; background-image: paint(wave); }&lt;/style&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); const wave = document.querySelector(\"#wave\"); let tick = 0; requestAnimationFrame(function raf(now) { tick += 1; wave.style.cssText = `--animation-tick: ${tick};`; requestAnimationFrame(raf); }); }&lt;/script&gt; 12345678910111213141516171819202122232425262728// paintworklet.jsregisterPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { let tick = Number(properties.get('--animation-tick')); const { width, height } = geom; const initY = height * 0.4; tick = tick * 2; ctx.beginPath(); ctx.moveTo(0, initY + Math.sin(tick / 20) * 10); for (let i = 1; i &lt;= width; i++) { ctx.lineTo(i, initY + Math.sin((i + tick) / 20) * 10); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + Math.sin(tick / 20) * 10); ctx.closePath(); ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fill(); }}) paintworklet 中，利用 sin 函数绘制波浪线，由于 AnimationWorklets 尚处于实验阶段，开放较少，这里我们在 worklet 外部用 requestAnimationFrame API 来做动画驱动，让波浪纹动起来。完成后能看到下边这样的效果。 然而事实上这个效果略显僵硬，sin 函数太过于规则了，现实中的波浪应该是不规则波动的，这种不规则主要体现在两个方面： 1）波纹高度（Y）随位置（X）变化而不规则变化 把图按照 x-y 正交分解之后，我们希望的不规则，可以认为是固定某一时刻，随着 x 轴变化，波纹高度 y 呈现不规则变化； 2）固定某点（X 固定），波纹高度（Y）随时间推进而不规则变化动态过程需要考虑时间维度，我们希望的不规则，还需要体现在时间的影响中，比如风吹过的前一秒和后一秒，同一个位置的波浪高度肯定是不规则变化的。 提到不规则，有朋友可能想到了用 Math.random 方法，然而这里的不规则并不适合用随机数来实现，因为前后两次取的随机数是不连续的，而前后两个点的波浪是连续的。这个不难理解，你见过长成锯齿状的波浪吗？又或者你见过上一刻 10 米高、下一刻就掉到 2 米的波浪吗？ 为了实现这种连续不规则的特征，我们弃用 sin 函数，引入了一个包 simplex-noise。由于影响波高的有两个维度，位置 X 和时间 T，这里需要用到 noise2D 方法，它提前在一个三维的空间中，构建了一个连续的不规则曲面： 123456789101112131415161718192021222324252627282930313233343536373839404142// paintworklet.jsimport SimplexNoise from 'simplex-noise';const sim = new SimplexNoise(() =&gt; 1);registerPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { const tick = Number(properties.get('--animation-tick')); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.4)', 0.004, tick, 15, 0.4); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.5)', 0.006, tick, 12, 0.4); } /** * 绘制波纹 */ drawWave(ctx, geom, fillColor, ratio, tick, amp, ih) { const { width, height } = geom; const initY = height * ih; const speedT = tick * ratio; ctx.beginPath(); for (let x = 0, speedX = 0; x &lt;= width; x++) { speedX += ratio * 1; var y = initY + sim.noise2D(speedX, speedT) * amp; ctx[x === 0 ? 'moveTo' : 'lineTo'](x, y); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + sim.noise2D(0, speedT) * amp); ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill(); }}) 修改峰值和偏置项等参数，可以再画多一个不一样的波浪纹，效果如下，完工！ 参考文章 CSS Painting API Level 1CSS Layout API Level 1CSS 魔術師 Houdini API 介紹","link":"/2019/07/12/CSS Houdini实现动态波浪纹/"},{"title":"Javascript抽象语法树下篇(实践篇)","text":"作者：陈晓强 上篇已经对AST基础做了介绍，本篇介绍AST的运用 AST应用的三个要点 需要一个解析器，将代码转换为AST 需要一个遍历器，能够遍历AST,并能够方便的对AST节点进行增删改查等操作 需要一个代码生成器，能够将AST转换为代码 esprima与babel常用的满足上述3个要点的工具包有两个，一个是esprima，一个是babel esprima相关包及使用如下 1234567891011const esprima = require('esprima'); // code =&gt; astconst estraverse = require('estraverse'); //ast遍历const escodegen = require('escodegen'); // ast =&gt; codelet code = 'const a = 1';const ast = esprima.parseScript(code);estraverse.traverse(ast, { enter: function (node) { //节点操作 }});const transformCode = escodegen.generate(ast); babel相关包及使用如下 123456789101112const parser = require('@babel/parser'); //code =&gt; astconst traverse = require('@babel/traverse').default; // ast遍历，节点增删改查，作用域处理等const generate = require('@babel/generator').default; // ast =&gt; codeconst t = require('@babel/types'); // 用于AST节点的Lodash式工具库,各节点构造、验证等let code = 'const a = 1';let ast = parser.parse(sourceCode);traverse(ast, { enter (path) { //节点操作 }})const transformCode = escodegen.generate(ast); 目前babel不管是从生态上还是文档上比esprima要好很多，因此推荐大家使用babel工具，本文示例也使用babel来做演示。 使用babel工具操作AST如上一章节所示 @babel/parser用于将代码转换为AST @babel/traverse用于对AST的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将AST转换成代码 @babel/types 用于AST节点操作的Lodash式工具库,各节点构造、验证等 更多api详见babel手册[1] 下面通过简单案例来介绍如何操作AST，注意案例只是示例，由于篇幅对部分边界问题只会注释说明，实际开发过程中需要考虑周全。 案例1:去掉代码中的console.log()实现代码 123456789101112131415161718192021const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `function square(n) { console.log(n); console.warn(n); return n * n;}`let ast = parser.parse(sourceCode);traverse(ast, { CallExpression(path) { let { callee } = path.node; if (callee.type === ‘MemberExpression’ &amp;&amp; callee.object.name === ‘console’ &amp;&amp; callee.property.name === ‘log’ ) { path.remove(); // 注意考虑对象挂载的识别，如global.console.log()，此时remove后剩下global.,会导致语法错误，此时可以判断父节点类型来排除 } }})console.log(generate(ast).code); 处理结果 12345function square(n) {- console.log(n); console.warn(n); return n * n;} 此案例涉及知识点 如何通过traverse遍历特定节点 识别出console.log()在规范中属于函数调用表达式,节点类型为CallExpression。 console.log本身即callee是在对象console上的一个方法，因此console.log是一个成员表达式，类型为MemberExpression。 MemberExpression根据规范有一个object属性代表被访问的对象，有一个property代表访问的成员。 通过path.remove()api可以对节点进行删除。 可以通过https://astexplorer.net/ 来辅助对代码节点的识别。注意选择babylon7，即babe7,对应@babel/parser 案例2:变量混淆实现代码 12345678910111213141516171819const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `function square(number) { console.warn(number); return number * number;}`let ast = parser.parse(sourceCode);traverse(ast, { FunctionDeclaration(path) { let unia = path.scope.generateUidIdentifier(\"a\"); path.scope.rename(\"number\",unia.name); }})console.log(generate(ast).code); 处理结果 1234567-function square(number) {+ function square(_a) {- console.warn(number);+ console.warn(_a);- return number * number;+ return _a * _a;} 此案例涉及知识点 path.scope保存了当前作用域的相关信息 可以通过api对作用域内的变量名进行批量修改操作 通过path.scope可以获得当前作用域唯一标识符，避免变量名冲突 案例3:转换箭头函数并去掉未使用参数实现代码 123456789101112131415161718192021222324252627const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(1); },200)});`let ast = parser.parse(sourceCode);traverse(ast, { ArrowFunctionExpression (path) { let { id, params, body } = path.node; for(let key in path.scope.bindings){ //注意考虑箭头函数的this特性，若发现函数体中有this调用，则需要在当前作用域绑定其父作用域的this if(!path.scope.bindings[key].referenced){ params = params.filter(param=&gt;{ return param.name!==key; }) } } path.replaceWith(t.functionExpression(id, params, body)); }})console.log(generate(ast).code); 处理结果 1234567-new Promise((resolve,reject)=&gt;{+new Promise(function(resolve){- setTimeout(()=&gt;{+ setTimeout(function(){ resolve(1); },200)}); 此案例涉及知识点 箭头函数节点：ArrowFunctionExpression 通过path.scope可以识别变量引用情况，是否有被引用，被哪些路径引用 通过@babel/types可以很方便的构建任意类型节点 通过path.replaceWith()可以进行节点替换 案例4:京东购物小程序的Tree-shaking删掉小程序中的冗余代码，部分实现代码示例如下 1234567891011121314151617181920212223242526272829const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');let sourceCode = `export function square (x) { return x * x;}export function cube (x) { return x * x * x;}`let ast = parser.parse(sourceCode);traverse(ast, { ExportNamedDeclaration (path) { let unused = ['cube'] // 借助webpack，我们能获得导出的方法中，哪些是没有被使用过的 let { declaration = {} } = path.node; if (declaration.type === 'FunctionDeclaration') { unused.forEach(exportItem =&gt; { // references=1表示仅有一次引用，即export的引用，没有在别处调用 if (declaration.id.name === exportItem &amp;&amp; path.scope.bindings[exportItem].references === 1) { path.remove(); } }); } }})console.log(generate(ast).code); 处理结果 123456export function square (x) { return x * x;}-export function cube (x) {- return x * x * x;-} 此案例涉及知识点 export节点：ExportNamedDeclaration 案例5:将代码转换成svg流程图此案例是git上一个比较有意思的开源项目，通过AST将代码转换为svg流程图，详见js-code-to-svg-flowchart[2] 可以体验一下：demo[3] 通过以上示例，可以看到通过AST我们可以对代码任意蹂躏，做出很多有意思的事情 AST在其他语言的应用除了Javascript，其他语言如HTML、CSS、SQL等也有广泛的AST应用。如下图，可以在这里找到对应语言的解析器，开启AST之门。 结语在上述AST网站中，可以看到HTML的解析器有个vue选项，读过vue源码的同学应该知道vue模板在转换成HTML之前会先将模板转换成AST然后生成render function进而生成VirtualDOM。我们平时开发对AST使用比较少，但其实到处都能见到AST的影子：babel、webpack、eslint、taro等等。希望能抛砖引玉，使同学们在各自团队产出更多基于AST的优秀工具、项目。 References[1] babel手册：https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md[2] js-code-to-svg-flowchart：https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart[3] demo：https://bogdan-lyashenko.github.io/js-code-to-svg-flowchart/docs/live-editor/index.html","link":"/2019/07/20/Javascript抽象语法树下篇(实践篇)/"},{"title":"碰撞检测的向量实现","text":"作者： 吴冠禧 注：1、本文只讨论2d图形碰撞检测。2、本文讨论圆形与圆形，矩形与矩形、圆形与矩形碰撞检测的向量实现 前言2D游戏中，通常使用矩形、圆形等来代替复杂图形的相交检测。因为这两种形状的碰撞检测速度是最快的。其中矩形包围盒又可以分为轴对齐包围盒（AABB, Axis Aligned Bounding Box）与转向包围盒（OBB, Oriented Bounding Box）。AABB与OBB的区别在于，AABB中的矩形的其中一条边和坐标轴平行，OBB的计算复杂度要高于AABB。根据不同的使用场景，可以用不同的方案。 如上图，明显皮卡超适合用包围盒，精灵球适合用包围球。 向量向量作为一种数学工具，在碰撞检测中发挥很大作用，后面的计算都是通过向量来完成，所以先来复习一下向量。 向量的代数表示向量的代数表示指在指定了一个坐标系之后，用一个向量在该坐标系下的坐标来表示该向量，兼具了符号的抽象性和几何形象性，因而具有最高的实用性，被广泛采用于需要定量分析的情形。 对于自由向量，将向量的起点平移到坐标原点后，向量就可以用一个坐标系下的一个点来表示，该点的坐标值即向量的终点坐标。 123456789// 二维平面向量class Vector2d{ constructor(vx=1,vy=1){ this.vx = vx; this.vy = vy; }}const vecA = new Vector2d(1,2);const vecB = new Vector2d(3,1); 向量运算加法：向量的加法满足平行四边形法则和三角形法则。具体的，两向量相加还是一个向量，分别是x与y两个分量的相加。 123456// 向量的加法运算static add(vec,vec2){ const vx = vec.vx + vec2.vx; const vy = vec.vy + vec2.vy; return new Vector2d(vx,vy);} 减法：两个向量a和b的相减得到的向量可以表示为a和b的起点重合后，从b的终点指向a的终点的向量： 123456// 向量的减法运算static sub(vec,vec2){ const vx = vec.vx - vec2.vx; const vy = vec.vy - vec2.vy; return new Vector2d(vx,vy);} 大小：向量的大小，是其各个分量的平方和开方。 1234// 获取向量长度length(){ return Math.sqrt(this.vx * this.vx + this.vy * this.vy);} 点积：从代数角度看，先对两个数字序列中的每组对应元素求积，再对所有积求和，结果即为点积。 1234// 向量的数量积static dot(vec,vec2){ return vec.vx * vec2.vx + vec.vy * vec2.vy;} 旋转：向量的旋转可以用旋转矩阵求解 12345678//向量的旋转 static rotate(vec,angle){ const cosVal = Math.cos(angle); const sinVal = Math.sin(angle); const vx = vec.vx * cosVal - vec.vy * sinVal; const vy = vec.vx * sinVal + vec.vy * cosVal; return new Vector2d(vx,vy);} 圆圆形比较简单，只要确认圆心x,y和半径r就行了,然后推导出圆心向量。 123456789class Circle{ // x,y是圆的圆心 r是半径 constructor(x=0,y=0,r=1){ this.x = x; this.y = y; this.r = r; } get P(){ return new Vector2d(this.x,this.y) } // 圆心向量} 矩形矩形就较为复杂，定义一个矩形需要中心坐标的x,y、两边长w和h，还有根据中心的旋转角度rotation 12345678910export class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; }} 两圆相交 两圆相交比较简单，只需判断两圆心之间的距离小于两圆的半径之和。 两圆心距离可以用圆心向量相减，然后求相减向量的长度。 12345678circleCircleIntersect(circle1,circle2){ const P1 = circle1.P; const P2 = circle2.P; const r1 = circle1.r; const r2 = circle2.r; const u = Vector2d.sub(P1,P2); return u.length() &lt;= r1 + r2 ;} 圆和矩形相交涉及到矩形的相交问题都先要判断是否轴对称。 矩形轴对称 先看轴对称的情况，下面是来自知乎问题怎样判断平面上一个矩形和一个圆形是否有重叠？「Milo Yip」的回答搬运： 设c为矩形中心，h为矩形半長，p为圆心，r为半径。 方法是计算圆心与矩形的最短距离 u，若 u 的长度小于 r 则两者相交。 首先利用绝对值把 p - c 转移到第一象限，下图显示不同象限的圆心也能映射至第一象限，这不影响相交测试的结果： 然后，把 v 减去 h，负数的分量设置为0，就得到圆心与矩形最短距离的矢量 u。下图展示了4种情况，红色的u是结果。 最后要比较 u 和 r 的长度，若距离少于 r，则两者相交。可以只求 u 的长度平方是否小于 r 的平方。 下面我用js实现一下： 其中矩形的四个顶点命名为A1，A2，A3，A4，矩形在第一象限的半長h等于CA3 1234567891011121314151617181920212223class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量}rectCircleIntersect(rect,circle){ const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = circle.P; const h = Vector2d.sub(A3,C); // 矩形半长 const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 矩形非轴对称 这个问题其实也很好解决，将矩形中心视为旋转中心，将矩形和圆形一起反向旋转将矩形转为轴对称，然后就可以套用上面的解法。 矩形中心到圆心向量为是CP 反向旋转θ度得向量CP’ 然后根据向量得三角形定律得OP’ = OC + CP’ 后面就代入矩形是轴对称的公式进行计算 12345678910111213141516171819202122232425262728293031323334353637class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}p(rect,circle){ const rotation = rect.rotation; const C = rect.C; let P; if (rotation % 360 === 0) { P = circle.P; // 轴对称直接输出P } else { P = Vector2d.add(C,Vector2d.rotate(Vector2d.sub(circle.P,C),rect._rotation*-1)); // 非轴对称，计算P‘ } return P;}rectCircleIntersect(rect,circle){ const rotation = rect.rotation; const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = p(rect,circle); const h = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 查看Demo1 https://rococolate.github.io/blog/gom/test1.html 两矩形相交两矩形都轴对称AABB 想象一下两个矩形A和B，B贴着A的边走了一圈，B的矩形中心的轨迹是一个新的矩形，这样就简化成新矩形与B中心点这一点的相交问题，又因为点可以看成是半径为0的圆，所以问题又转换为圆形和矩形相交。 1234567891011121314151617181920212223242526class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}AABBrectRectIntersect(rect1,rect2){ const P = rect2.C; const w2 = rect2.w; const h2 = rect2.h; const {w,h,x,y} = rect1; const C = rect1.C; const A3 = new Vector2d(x+w/2+w2/2,y+h/2+h2/2); // 新矩形的半长 const H = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - H.vx,0),Math.max(v.vy - H.vy,0)); return u.lengthSquared() === 0; // 点可以看成是半径为0的圆} 两矩形相交非轴对称OBB 两个矩形的OBB检测使用分离轴定理（Separating Axis Theorem） 分离轴定理：通过判断任意两个矩形 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 因为矩形的对边平行，所以只要判断四条对称轴上的投影即可。 如何投影？这里补充一下向量点积的几何意义。 在欧几里得空间中，点积可以直观地定义为 A·B = |A||B|cosθ ,其中|A|cosθ是A到B的投影，如果B是单位向量，那么A·B就是A到单位向量B的投影 回到矩形，将矩形4个顶点都投影到对称轴上，我们分别将其点乘即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } get _A1(){ return new Vector2d(this.x-this.w/2,this.y-this.h/2); } // 4角顶点 get _A2(){ return new Vector2d(this.x+this.w/2,this.y-this.h/2); } get _A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } get _A4(){ return new Vector2d(this.x-this.w/2,this.y+this.h/2); } get _axisX(){ return new Vector2d(1,0); } // 未旋转时的对称轴X get _axisY(){ return new Vector2d(0,1); } // 未旋转时的对称轴Y get _CA1(){ return Vector2d.sub(this._A1,this.C); } get _CA2(){ return Vector2d.sub(this._A2,this.C); } get _CA3(){ return Vector2d.sub(this._A3,this.C); } get _CA4(){ return Vector2d.sub(this._A4,this.C); } get _rotation(){ return this.rotation / 180 * Math.PI; } get A1(){ return this.rotation % 360 === 0 ? this._A1 : Vector2d.add(this.C,Vector2d.rotate(this._CA1,this._rotation)); } // 计算上旋转后4角顶点 get A2(){ return this.rotation % 360 === 0 ? this._A2 : Vector2d.add(this.C,Vector2d.rotate(this._CA2,this._rotation)); } get A3(){ return this.rotation % 360 === 0 ? this._A3 : Vector2d.add(this.C,Vector2d.rotate(this._CA3,this._rotation)); } get A4(){ return this.rotation % 360 === 0 ? this._A4 : Vector2d.add(this.C,Vector2d.rotate(this._CA4,this._rotation)); } get axisX(){ return this.rotation % 360 === 0 ? this._axisX : Vector2d.rotate(this._axisX,this._rotation); } // 计算上旋转后的对称轴X get axisY(){ return this.rotation % 360 === 0 ? this._axisY : Vector2d.rotate(this._axisY,this._rotation); } // 计算上旋转后的对称轴Y get _vertexs(){ return [this._A1,this._A2,this._A3,this._A4]; } get vertexs(){ return [this.A1,this.A2,this.A3,this.A4]; } // 4角顶点数组}OBBrectRectIntersect(rect1,rect2){ const rect1AxisX = rect1.axisX; const rect1AxisY = rect1.axisY; const rect2AxisX = rect2.axisX; const rect2AxisY = rect2.axisY; if (!cross(rect1,rect2,rect1AxisX)) return false; // 一旦有不相交的轴就可以return false if (!cross(rect1,rect2,rect1AxisY)) return false; if (!cross(rect1,rect2,rect2AxisX)) return false; if (!cross(rect1,rect2,rect2AxisY)) return false; return true; // 4轴投影都相交 return true}cross(rect1,rect2,axis){ const vertexs1ScalarProjection = rect1.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形1的4个顶点投影并排序 const vertexs2ScalarProjection = rect2.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形2的4个顶点投影并排序 const rect1Min = vertexs1ScalarProjection[0]; // 矩形1最小长度 const rect1Max = vertexs1ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形1最大长度 const rect2Min = vertexs2ScalarProjection[0]; // 矩形2最小长度 const rect2Max = vertexs2ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形2最大长度 return rect1Max &gt;= rect2Min &amp;&amp; rect2Max &gt;= rect1Min; // 相交判断 } 最后放上一个相交的应用Demo https://rococolate.github.io/blog/gom/test2.html,Demo里的形状都可以拖拽，当碰到其他形状时会变透明。 参考文章第十五章：碰撞检测 http://blog.jmecn.net/chapter-15-collision-detection/ 方块的战争：浅谈格斗游戏的精髓 http://daily.zhihu.com/story/4761397 怎样判断平面上一个矩形和一个圆形是否有重叠？ https://www.zhihu.com/question/24251545 “等一下，我碰！”——常见的2D碰撞检测 https://aotu.io/notes/2017/02/16/2d-collision-detection/index.html 码农干货系列【1】–方向包围盒(OBB)碰撞检测 https://www.cnblogs.com/iamzhanglei/archive/2012/06/07/2539751.html Rotation matrix https://en.wikipedia.org/wiki/Rotation_matrix 数量积 https://zh.wikipedia.org/wiki/%E7%82%B9%E7%A7%AF 向量 https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F","link":"/2019/06/27/collision-detection/"},{"title":"手把手教你写webpack loader","text":"作者：黄浩群 一、什么是 loaderloader 和 plugins 是 webpack 系统的两大重要组成元素。依靠对 loader、plugins 的不同组合搭配，我们可以灵活定制出高度适配自身业务的打包构建流程。 loader 是 webpack 容纳各类资源的一个重要手段，它用于对模块的源代码进行转换，允许你在 import 或加载模块时预处理文件，利用 loader，我们可以将各种类型的资源转换成 webpack 本质接受的资源类型，如 javascript。 二、如何编写一个 yaml-loader1、YAMLyaml 语言多用于编写配置文件，结构与 JSON 类似，但语法格式比 JSON 更加方便简洁。yaml 支持注释，大小写敏感，使用缩进来表示层级关系： 123456789101112131415161718192021#对象 version: 1.2.4#数组author: - Mike - Hankle#常量name: \"my project\" #定义一个字符串limit: 30 #定义一个数值es6: true #定义一个布尔值openkey: Null #定义一个null#锚点引用server: base: &amp;base port: 8005 dev: ip: 120.168.117.21 &lt;&lt;: *base gamma: ip: 120.168.117.22 &lt;&lt;: *base 等同于： 123456789101112131415161718192021{ \"version\": \"1.2.4\", \"author\": [\"Mike\", \"Hankle\"], \"name\": \"my project\", \"limit\": 30, \"es6\": true, \"openkey\": null, \"server\": { \"base\": { \"port\": 8005 }, \"dev\": { \"ip\": \"120.168.117.21\", \"port\": 8005 }, \"gamma\": { \"ip\": \"120.168.117.22\", \"port\": 8005 } }} 在基于 webpack 构建的应用中，如果希望能够引用 yaml 文件中的数据，就需要一个 yaml-loader 来支持编译。一般情况下，你都能在 npm 上找到可用的 loader，但如果万一没有对应的支持，或者你希望有一些自定义的转换，那么就需要自己编写一个 webpack loader 了。 2、loader 的原理loader 是一个 node 模块，它导出为一个函数，用于在转换资源时调用。该函数接收一个 String/Buffer 类型的入参，并返回一个 String/Buffer 类型的返回值。一个最简单的 loader 是这样的： 1234// loaders/yaml-loader.jsmodule.exports = function(source) { return source;}; loader 支持管道式传递，对同一类型的文件，我们可以使用多个 loader 进行处理，这批 loader 将按照“从下到上、从右到左”的顺序执行，并以前一个 loader 的返回值作为后一个 loader 的入参。这个机制无非是希望我们在编写 loader 的时候能够尽量避免重复造轮子，只关注需要实现的核心功能。因此配置的时候，我们可以引入 json-loader： 123456789101112131415161718192021// webpack.config.jsconst path = require(\"path\");module.exports = { // ... module: { rules: [ { test: /\\.yml$/, use: [ { loader: \"json-loader\" }, { loader: path.resolve(__dirname, \"./loaders/yaml-loader.js\") } ] } ] }}; 3、开始这样一来，我们需要的 yaml-loader，就只做一件事情：将 yaml 的数据转化成为一个 JSON 字符串。因此，我们可以很简单地实现这样一个 yaml-loader： 123456789101112var yaml = require(\"js-yaml\");module.exports = function(source) { this.cacheable &amp;&amp; this.cacheable(); try { var res = yaml.safeLoad(source); return JSON.stringify(res, undefined, \"\\t\"); } catch (err) { this.emitError(err); return null; }}; 就是这么简单。但是可能有朋友会问，这里是因为有个现成的模块 js-yaml，可以直接将 yaml 转换成 JavaScript 对象，万一没有这个模块，该怎么做呢？是的，loader 的核心工作其实就是字符串的处理，这是个相当恶心的活儿，尤其是在这类语法转换的场景上，对源代码的字符串处理将变得极其复杂。这个情况下，我们可以考虑另外一种解法，借助 AST 语法树，来协助我们更加便捷地操作转换。 4、利用 AST 作源码转换yaml-ast-parser 是一个将 yaml 转换成 AST 语法树的 node 模块，我们把字符串解析的工作交给了 AST parser，而操作 AST 语法树远比操作字符串要简单、方便得多： 1234567891011121314151617181920212223const yaml = require(\"yaml-ast-parser\");class YamlParser { constructor(source) { this.data = yaml.load(source); this.parse(); } parse() { // parse ast into javascript object }}module.exports = function(source) { this.cacheable &amp;&amp; this.cacheable(); try { const parser = new YamlParser(source); return JSON.stringify(parser.data, undefined, \"\\t\"); } catch (err) { this.emitError(err); return null; }}; 这里我们可以利用 AST parser 提供的方法直接转化出 json，如果没有或者有所定制，也可以手动实现一下 parse 的过程，仅仅只是一个树结构的迭代遍历而已，关键步骤是对 AST 语法树的各类型节点分别进行处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const yaml = require(\"yaml-ast-parser\");const types = yaml.Kind;class YamlParser { // ... parse() { this.data = this.traverse(this.data); } traverse(node) { const type = types[node.kind]; switch (type) { // 对象 case \"MAP\": { const ret = {}; node.mappings.forEach(mapping =&gt; { Object.assign(ret, this.traverse(mapping)); }); return ret; } // 键值对 case \"MAPPING\": { let ret = {}; // 验证 const keyValid = yaml.determineScalarType(node.key) == yaml.ScalarType.string; if (!keyValid) { throw Error(\"键值非法\"); } if (node.key.value == \"&lt;&lt;\" &amp;&amp; types[node.value.kind] === \"ANCHOR_REF\") { // 引用合并 ret = this.traverse(node.value); } else { ret[node.key.value] = this.traverse(node.value); } return ret; } // 常量 case \"SCALAR\": { return node.valueObject !== undefined ? node.valueObject : node.value; } // 数组 case \"SEQ\": { const ret = []; node.items.forEach(item =&gt; { ret.push(this.traverse(item)); }); return ret; } // 锚点引用 case \"ANCHOR_REF\": { return this.traverse(node.value); } default: throw Error(\"unvalid node\"); } }}// ... 当然这样的实现略为粗糙，正常来说，一些完备的 AST parser 一般都会自带遍历方法（traverse），这样的方法都是有做过优化的，我们可以直接调用，尽量避免自己手动实现。 按照相同的做法，你还可以实现一个 markdown-loader，甚至更为复杂的 vue-loader。 三、loader 的一些开发技巧1、单一任务只做一件事情，做好一件事情。loader 的管道（pipeline）设计正是希望能够将任务拆解并独立成一个个子任务，由多个 loader 分别处理，以此来保证每个 loader 的可复用性。因此我们在开发 loader 前一定要先给 loader 一个准确的功能定位，从通用的角度出发去设计，避免做多余的事。 2、无状态loader 应该是不保存状态的。这样的好处一方面是使我们 loader 中的数据流简单清晰，另一方面是保证 loader 具有良好可测性。因此我们的 loader 每次运行都不应该依赖于自身之前的编译结果，也不应该通过除出入参外的其他方式与其他编译模块进行数据交流。当然，这并不代表 loader 必须是一个无任何副作用的纯函数，loader 支持异步，因此是可以在 loader 中有 I/O 操作的。 3、尽可能使用缓存在开发时，loader 可能会被不断地执行，合理的缓存能够降低重复编译带来的成本。loader 执行时默认是开启缓存的，这样一来， webpack 在编译过程中执行到判断是否需要重编译 loader 实例的时候，会直接跳过 rebuild 环节，节省不必要重建带来的开销。 当且仅当有你的 loader 有其他不稳定的外部依赖（如 I/O 接口依赖）时，可以关闭缓存： 1this.cacheable &amp;&amp; this.cacheable(false);","link":"/2019/09/17/手把手教你写webpack-loader/"},{"title":"【译】Web内容如何影响电池的使用","text":"原文地址：https://webkit.org/blog/8970/how-web-content-can-affect-power-usage/原文作者：Benjamin Poulain &amp; Simon Fraser译者：刘辉 校验：李刚松 现在用户上网大多使用移动设备或者笔记本电脑。对这两者来说，电池寿命都很重要。在这篇文章里，我们将讨论影响电池寿命的因素，以及作为一个web开发者，我们如何让网页耗电更少，以便用户有更多时间来关注我们的内容。 是什么在耗电？移动设备的电力消耗有以下几个因素： CPU （核心处理器） GPU （图形处理） 网络 （wifi或者蜂窝移动网络） 屏幕 屏幕功耗相对稳定，并且主要由用户控制（通过屏幕使用时间和亮度），但是对于其他组件，例如CPU，GPU，网络模块，功耗是动态变化的，而且变化范围很大。 系统根据当前正在处理的任务调整CPU和GPU性能，包括在Web浏览器中用户正在交互的网页以及使用Web内容的其他应用程序。这是通过打开或关闭某些组件以及通过更改其时钟频率来完成的。总的来说，芯片所需的性能越高，其功率效率就越低。硬件可以非常快速地提升到高性能（但是需要很大的功率），然后迅速恢复到更高效的低功耗状态。 良好用电的一般原则为了最大限度地延长电池寿命，你必须尽量减少硬件处于高功率状态的时间，让硬件尽可能的处于空闲状态。 对于web开发者来说，有三种交互场景需要注意： 用户主动与内容交互 页面处于前台，但是用户没有交互 页面处于后台 高效的用户交互用户交互的时候肯定会耗电。页面需要快速的加载，并且能够快速的响应触摸。在大多数场景中，减少首次渲染时间也会降低功耗。不过，在初始页面加载后继续加载资源和运行脚本时要小心。我们要尽快让系统返回空闲状态。总的来说，浏览器已经完成了布局和渲染，js执行的越少，耗电越少。 一旦页面加载完，用户可能会滚屏或者点击页面，这同样会产生耗电（主要是CPU和GPU）,这是必要的消耗。要确保尽快返回空闲状态。并且，最好使用浏览器本身提供的功能。- 举例：普通的页面滚动肯定比用js自定义的滚动更高效。 让空闲状态耗电趋向于零当用户没有和页面交互时，尽可能的使页面不耗电，例如： 尽量少用定时器以避免唤醒CPU,可以把基于定时器的任务合并，使用尽可能少的定时器。大量滥用定时器会导致CPU被频繁唤醒，这比把这些任务合并处理要糟糕的多。 最大限度地减少动画内容，如动画图像和自动播放视频。要特别注意”loading”用的gif图片或css动画，这些动画会不断触发渲染，即使看不到也会触发。IntersectionObserver可以用来在可见时才运行动画。 尽量用css做动画和过渡，这些动画不可见时，浏览器会进行优化，并且css动画比js动画要高效的多。 避免通过轮询来获取服务器更新，可以用websocket或者持久连接来代替轮询。 看起来处于空闲状态的页面，如果正在后台进行工作，其用户交互的响应效率也会降低，因此最小化后台活动也可以提高响应能力以及电池寿命。 页面在后台时CPU零使用这几种场景时，页面变为非活动状态(不是用户的首要焦点)，例如： 用户切换到其他tab 用户切换到其他app 浏览器窗口最小化 浏览器窗口失去焦点 浏览器窗口在其他窗口后面 窗口所在的空间不是当前空间（MacOS才有空间的概念） 当页面不活动时，webkit会自动做以下处理来减少耗电： 停止调用requestAnimationFrame CSS和SVG动画会暂停 定时器会节流 此外，WebKit利用操作系统提供的能力来最大限度地提高效率： 在iOS上，不用的选项卡(tab页)会完全暂停。 在macOS上，选项卡会响应App Nap功能，这意味着不可视更新的选项卡的Web进程优先级较低，并且其计时器会做节流处理。 但是，页面可以通过计时器（setTimeout和setInterval），消息，网络事件等触发CPU唤醒。页面在后台时应避免这些唤醒，有两个API对此有用： 页面可见性API提供了一种响应页面转换为后台或前台的方法。这是一种避免页面在后台时更新UI的好方法。用visibilitychange事件，在页面可见时更新页面内容。 页面失去焦点时会发出blur事件。这时，页面依然可见，但是不是聚焦窗口。可以考虑暂停动画。 查找问题最简单的方式就是用浏览器控制台的时间线功能。页面在后台时，时间线记录中不应该有任何事件发生。 找到问题所在现在我们知道了web页面主要的耗电因素，并且给出了一些创建高效页面的一般规则。 接下来讨论一下怎样找出并解决导致功耗过大的问题。 脚本如上所述，现代CPU能够把功率从空闲态的非常低提升到非常高来满足用户交互和其他任务的要求。 也正因为如此，CPU是导致电池寿命减少的主要原因。页面加载期间CPU要做一连串工作包括加载、解析、渲染资源，并且执行js。在大多数现代web页面上，执行js花费的时间远远高出浏览器用在其余加载过程中花费的时间。因为尽量减少js执行时间对省电有最大的效益。 测量CPU使用的最佳方法是使用Web Inspector，就像之前文章里所说的，时间线面板可以显示任意选定时间范围内的CPU活动。 为了高效地使用CPU，WebKit尽可能在多核上分配工作（使用Workers的页面也可以使用多核）。Web Inspector提供与页面主线程同时运行的线程的细分图表。例如，以下屏幕截图显示了滚动具有复杂渲染和视频播放的页面时的线程： 在寻找优化点时，应关注主线程，因为js运行在主线程上（除非您正在使用Workers）。我们可以使用时间线面板的 “JavaScript and Events” 项来了解触发脚本的内容。也许你在响应用户或滚动事件或从requestAnimationFrame触发隐藏元素的更新时做了太多工作。你需要了解你在页面上使用的JavaScript库和第三方脚本所做的工作。如果要深入挖掘，你可以使用Web Inspector的JavaScript profiler来查看时间都用在哪些地方。 “WebKit线程”中的活动主要由与JavaScript相关的工作触发：JIT编译和垃圾收集。因此减少运行的脚本数量并减少短生命周期的JavaScript对象可以降低webkit线程的活动。 WebKit调用的各种其他系统框架都使用线程，“Other thread” 包括了这些工作; “Other thread” 最主要的工作是渲染，我们将在下面讨论。 渲染主线程CPU使用也可以通过大量布局和绘制来触发；这些通常由脚本触发，但是除了transform，opacity和filter之外的属性的CSS动画也可以触发它们。查看时间线面板的 “Layout and Rendering” 项将帮助你了解导致活动的原因。 如果 “Layout and Rendering” 显示的渲染过程不能清楚展示页面正在发生什么变化，可以启用 Paint Flashing： 这部分渲染将用红色背景的高亮显示，你可以滚动页面查看。注意，WebKit会保留一些“透视”图块以允许平滑滚动，因此视口中不可见的图形仍然可以正常工作以使屏幕外图块保持最新。如果渲染展示在时间轴中，说明它正在工作。 除了导致CPU耗电外，渲染通常还会触发GPU工作。macOS和iOS上的WebKit使用GPU进行渲染，因此触发渲染可以显着增加耗电。额外的CPU使用通常显示在时间线面板 “CPU” 项中的 “Other threads” 下。 GPU还用于canvas渲染，包括2D画布和WebGL / WebGPU。为了最小限度使用绘图，canvas上显示的内容没有变化时不要调用canvas API，并尝试优化canvas绘制代码。 许多Mac笔记本电脑都有两个GPU，一个与CPU相同内核的集成GPU，功能不强但功耗低，一个功能更强大但是功耗也更高的独立GPU。 WebKit默认使用集成GPU；你可以使用powerPreference上下文创建参数请求独立GPU，但只有在你可以证明电源成本合理时才执行此操作。 网络无线网络会以意想不到的方式影响电池寿命。手机有功能更强大的无线模块（WiFi和蜂窝网络芯片）和更小的电池，因此受到的影响最大。 遗憾的是，在实验室外测量网络的功率影响并不容易，但可以通过遵循一些简单的规则来减少。 降低网络功耗的最直接方法是最大限度地利用浏览器的缓存。 减少页面加载时间的所有最佳实践也可以通过减少无线模块需要打开的时间来使电池受益。 另一个重要方面是在时间上将网络请求组合在一起。每当有新请求到来时，操作系统都需要打开无线模块，连接到基站或蜂窝塔，并传输字节。在发送分组之后，在发送更多分组的情况下，无线电保持供电少量时间。 如果页面非经常性的发送少量数据，则开销可能会大于传输数据所需的能量。 可以从 Web Inspector 的时间线面板的 “Network Requests” 项中发现此类问题。例如，以下屏幕截图显示了几秒钟内发送的四个单独请求： 同时发送所有请求将提高网络用电效率。 总结我们可以对网页做很多优化来延长电池寿命。 在Web Inspector中测量对电池影响并降低损耗非常重要。 这样做可以改善用户体验并延长电池寿命。 提高电池寿命的最直接方法是最大限度地降低CPU使用率。 新的Web Inspector提供了强大的工具可以全程监控。 为了让电池寿命更长，我们要： 在空闲时将CPU使用率降至零 在用户交互期间最大化性能以快速恢复空闲","link":"/2019/09/17/【译】Web内容如何影响电池的使用/"},{"title":"你还在用图片做引导蒙层？","text":"作者：深山蚂蚁 引导蒙层通常在新业务上线、或者业务有变更时的给新用户的一个操作指引。下图页面即是一个蒙层，会在某个局部位置高亮我们需要重点突出的内容： 当前发现很多页面做蒙层引导，还是使用图片形式来做。 图片引导蒙层有几大缺点： 图片大，影响加载 图片的内容都是假的，和真实的底部内容没对上 全屏蒙层图片，图片的宽高和屏幕宽高不一致，显示两边留黑，或者有压缩的效果。 图片的引导位置不能点击。 low ？ not cool ？ 本文讲述六种思路来实现引导蒙层 z-index实现蒙层 动态opacity实现 border实现 box-shadow实现 节点复制实现 canvas实现 以上六种引导蒙层实现思路，在一定情况下都能满足业务需求，从不同角度来实现了引导蒙层。z-index最简单，canvas最灵活，就个人而言，更加喜欢骨架屏式的动态opacity蒙层实现，更有趣更酷!!! 思路一：使用z-index 新增一个div，设置为半透明区域，大小覆盖整个页面 半透明蒙层区域z-index大于页面元素 引导内容区域大于半透明蒙层区域z-index 这个好理解，页面元素都是有层级的，我们只需要把引导内容区域设置为最顶层的层级，在引导内容区域之下设置一个遮罩层，其他内容元素的z-index都地域这个遮罩层即可。 我们来看一个简单例子。 123456789101112131415161718192021222324252627.z1{ position:absolute; left:50px; top:50px; width:50px; height:50px; background:blue; z-index:1;}.z2{ position:absolute; left:60px; top:60px; width:50px; height:50px; background:red; z-index:2;}.z3{ position:absolute; left:70px; top:70px; width:50px; height:50px; background:yellow; z-index:3;} 我们修改一下z2的样式。 12345678910111213141516171819202122232425.z2{ position:absolute; left:50px; top:50px; width:50px; height:50px; background:black; opacity:0.5; z-index:2; animation:z_index 2s linear infinite alternate;}@keyframes z_index { from { left:50px; top:50px; width:50px; height:50px; } to { left:0px; top:0px; width:200px; height:200px; } } 只要在布局页面元素的时候，把需要做蒙层的元素确定好，配合js，动态的设置元素的z-index + opacity，就可以很好的做到页面的引导蒙层效果。 思路二：使用opacity将非蒙层元素半透明 引导内容区域无需改动 页面其他节点元素半透明 我们不再新增蒙层，而是完全操作页面节点，将需要遮罩的节点都设置为半透明，引导蒙层显现内容则完全显示出来。页面的效果和蒙层不太一样，对于空白地方，我们仍然是完全显示，只是将有内容的元素给半透明，类似骨架屏的效果。为了演示效果，我们看如下例子：页面设置6个元素。 12345678&lt;div class=\"wrap\"&gt; &lt;div class=\"z z1\"&gt;&lt;/div&gt; &lt;div class=\"z z2\"&gt;&lt;/div&gt; &lt;div class=\"z z3\"&gt;&lt;/div&gt; &lt;div class=\"z z4\"&gt;&lt;/div&gt; &lt;div class=\"z z5\"&gt;&lt;/div&gt; &lt;div class=\"z z6\"&gt;&lt;/div&gt; &lt;/div&gt; 将元素内容用flex并排布局。 12345678910111213141516171819202122232425262728.wrap{ display:flex; flex-wrap:wrap; width:150px;}.z{ width:50px; height:50px; transition:all 1s;}.z1{ background:blue;}.z2{ background:black;}.z3{ background:yellow;}.z4{ background:red;}.z5{ background:green;}.z6{ background:orange;} 使用js操作，依次半透明其他元素，显示当前元素来模拟蒙层。 1234567891011121314151617let arry = Array.from(document.querySelectorAll(\".z\"));let index = -1;let direct = 1;setInterval(()=&gt;{ if(index&gt;=5) direct = -1; else if(index&lt;=0) direct = 1; index = index+direct; arry.forEach((d,i)=&gt;{ d.style.opacity = 1; }); setTimeout(()=&gt;{ arry.forEach((d,i)=&gt;{ if(i==index) return; d.style.opacity = 0.1; }); },1000);},2000) 看了这个例子，我们清晰的看到这个引导蒙层的实现过程。这种引导蒙层其实更好玩有趣，有点类似当前流行的骨架屏，其他已有元素需要遮罩的内容就是骨架屏的灰色部分，需要显现的就是重点的蒙层内容。有趣！！！ 思路三：使用border的方式来实现没错，就是普遍不能在普遍的border了，且看如下： 123div { border:1px solid #red;} 那用border怎么实现引导蒙层呢？ 1、先了解下三角形先看一个简单的例子： 1&lt;div class=\"border_1\"&gt;&lt;/div&gt; 123456789.border_1{ width: 100px; height: 100px; border-top:50px solid red; border-right: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid transparent; box-sizing:border-box;} 实现了一个倒三角,这个应用场景是不是就比较多了，很多tips的指引，标注等都会用到。我就看到过这种倒三角使用一张图片代替的做法。仔细看这段代码，主要有实现了三点： 四边都设置了边框 宽高都为100px,即上下、左右表框之和，其实小于等于这个值都行。 只有顶部边框是红色，其他边框是透明的。 为了理解上面的实现，我们来看下如下代码： 123456789101112131415161718.border_2{ width: 100px; height: 100px; background-color:green; border-style:solid; border-color:red yellow blue black; border-width:50px; animation:border_ani 2s linear infinite alternate; box-sizing:border-box;}@keyframes border_ani { from { border-width:50px; } to { border-width:0; } } 从图中我们可以清晰的看到，随着border-width的变化，整个div的绿色背景在跟随变化。 当border-width=0的时候，整个页面只有绿色背景，即都是内容的大小 当border-width=50的时候，整个div的大小都被border给充满了，上下左右均分1/4，就是四个倒三角。 这样我们就清晰的能得到: 当border-right,border-left,border-bottom都transparent透明，border-top是红色的时候，所看到的就是一个倒三角。 同理我们还可以设置边框的大小不一致，可以实现斜三角： 123456789.border_3{ width: 0; height: 0; border-top:30px solid red; border-right: 10px solid transparent; border-bottom: 20px solid transparent; border-left: 100px solid transparent; box-sizing:border-box;} 还可以实现工作中经常碰到的梯形： 123456789.border_4{ width: 150px; height: 150px; border-top:50px solid red; border-right: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid transparent; box-sizing:border-box;} 好了，这里不累赘了，感兴趣的可以各种尝试。遇到这种简单边线图，就不要动不动使用图片了。 2、再看实现引导蒙层 新增一个div，作为蒙层元素 div中间大小和引导内容元素大小完全一致，且位置恰好重叠 div的border设置为半透明且无限放大 了解了上面的三角形的实现之后，估计你也能想出怎么做引导蒙层了。一个div有四个边框，如果我们把边框都设置成半透明，然后中间的区域（上面border_2的green）设置成全透明会不就可以实现区域引导蒙层了吗？然后再把边框设置成超过屏幕的大小呢，就是全景引导蒙层了！ 123456789.border_5{ width: 150px; height: 150px; border-top:50px solid rgba(0,0,0,.5); border-right: 50px solid rgba(0,0,0,.5); border-bottom: 50px solid rgba(0,0,0,.5); border-left: 50px solid rgba(0,0,0,.5); box-sizing:border-box;} 这是一个150px的区域蒙层，我们看下如下示例就能很明白了： 1234567891011121314151617.border_6{ width: 20px; height: 20px; border-style:solid; border-color:rgba(0,0,0,.5); border-width:20px; animation:border_ani 2s linear infinite alternate; box-sizing:content-box;}@keyframes border_ani { from { border-width:20px; } to { border-width:100px; } } 当然，我们还可以设置border-radius来实现圆形的蒙层区域，如下： 当然，这里的边框大小值都是写死的，具体实现需要根据页面内容修改或者动态修改即可。 如果是椭圆呢？ 总结： border可以实现各种边线的形状，可以实现引导蒙层，页面指定区域透明，之外的都半透明来实现即可。 思路四、使用box-shadow来实现 新增一个div，作为蒙层元素 div大小和内容元素大小完全一致，且位置恰好重叠 div的box-shadow的阴影尺寸设置为半透明且设置为比较大的约2000px大小 box-shadow，大伙都不陌生，就是盒子的阴影，我们先来了解下它的基本用法： 123456.boxshadow_1{ width:50px; height:50px; background:blue; box-shadow: 10px 10px 5px 4px #000;} 在宽高为50px的div,它的阴影水平和垂直都是10px，阴影模糊距离是5px,阴影的尺寸是4px,阴影是#000的颜色(这里给body增加了一个yellow的背景色以便于区分)。 首先我们把阴影透明： 123456.boxshadow_2{ width:50px; height:50px; background:blue; box-shadow: 10px 10px 5px 4px rgba(0,0,0,.5);} 那怎么让阴影遮盖整个页面呢？ 阴影的水平和垂直距离是指距离原dev的距离，这个调整达不到效果，只会让阴影更多的偏离元素。 阴影的模糊距离指阴影的边缘渐变模糊的距离，距离越长，只会让渐变模糊加长，蒙层大小不会变。 阴影的尺寸，这个是指多大的阴影，那我们将阴影尺寸设置很大呢？是的，就是这个了 看如下的例子，我们调整阴影的尺寸： 123456789101112131415.boxshadow_3 { width:50px; height:50px; background:blue; box-shadow: 0px 0px 5px 0px rgba(0,0,0,.5); animation:box_ani 2s linear infinite alternate;}@keyframes box_ani { from { box-shadow: 10px 10px 5px 0px rgba(0,0,0,.5); } to { box-shadow: 10px 10px 5px 100px rgba(0,0,0,.5); } } 如上，我们只需要把阴影尺寸加大就可以实现引导蒙层了。如果需要引导蒙层状态下还能响应事件呢？只需要加一个pointer-events属性即可。 box-shadow的阴影距离切勿盲目设置过大，经过测试这个值如果过大，比如4000px，在部分手机上阴影无法显示出来。经过实践，设置为2000px为佳。 思路五：使用页面节点复制 新增两个div，一个半透明蒙层元素和一个蒙层内容区域 将页面节点引导内容拷贝到蒙层内容区域 将蒙层内容区域的大小和位置与原节点引导内容完全重合 页面内容已经做好了，我们需要引导蒙层来显示某个元素，那么将元素复制到最外层，顶层增加一层蒙层来实现,需要突出的引导内容在蒙层之上即可实现。 123456&lt;div class=\"content one\"&gt;我是第一个div，我是第一个div&lt;/div&gt;&lt;div class=\"content two\"&gt;我是第二个div，我是第二个div&lt;/div&gt;&lt;div class=\"content three\"&gt;我是第三个div，我是第三个div&lt;/div&gt;&lt;div class=\"content four\"&gt;我是第四个div，我是第四个div&lt;/div&gt;&lt;div class=\"mask\"&gt;&lt;/div&gt;&lt;div id=\"maskContent\"&gt;&lt;/div&gt; 这里设置了一个固定蒙层，和一个固定的蒙层内容元素，我们只需要填充即可。 12345678910111213141516171819.content{ padding:10px; z-index:0;}.mask{ position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,.8); z-index:900 } #maskContent{ position:fixed; z-index:999; display:inline-block; background-color: #fff; } 这里内容区域都是0，然后mask是900，我们的蒙层元素是999，就是最上层了。 123456789101112131415function renderContent(cls){ let targetNode = document.querySelector(`.${cls}`); let maskContent = document.getElementById(\"maskContent\"); maskContent.innerHTML = targetNode.outerHTML; let pos = targetNode.getBoundingClientRect(); maskContent.style.top=pos.top+\"px\"; maskContent.style.left=pos.left+\"px\"; maskContent.style.width=pos.width+\"px\"; maskContent.style.height=pos.height+\"px\"; }let i = 0;setInterval(()=&gt;{ renderContent(['one','two','three','four'][i]); if(++i&gt;=4) i = 0;},1000) 这里为了演示效果，增加了一个定时器改变不同的遮罩层。易于理解，看下效果： 思路六：使用canvas实现 新增一个canvas，绘制两次图形 第一次：绘制一个全屏的半透明阴影 第二次：使用xor绘制一个和引导内容区域的大小位置完全重合的区域 第二次绘制的内容区域和第一次重叠，使用xor，所以会透明，该引导内容区域就会完全显示出来，这就是我们想要的效果了。 使用canvas的globalCompositeOperation属性来实现,内容参考http://www.tutorialspoint.com/html5/canvas_composition.htm 重点看xor：Shapes are made transparent where both overlap and drawn normal everywhere else.翻译： canvas绘制的形状在重叠处都会变成透明的，非重叠处的其他任何地方都正常绘制内容。 所以我们就可以在canvas里面绘制一个canvas蒙层，然后在蒙层中需要显示的内容用xor来绘制重叠，然后重叠内容就会被透明，那么这个透明区域的内容就是我们想要的引导蒙层突出内容区域。具体看实例： 12345 &lt;div class=\"content one\"&gt;我是第一个div，我是第一个div&lt;/div&gt;&lt;div class=\"content two\"&gt;我是第二个div，我是第二个div&lt;/div&gt;&lt;div class=\"content three\"&gt;我是第三个div，我是第三个div&lt;/div&gt;&lt;div class=\"conteent four\"&gt;我是第四个div，我是第四个div&lt;/div&gt;&lt;canvas id=\"mask\"&gt;&lt;/canvas&gt; 页面增加一个canvas节点。将canvas整体设置成半透明，然后再用xor来实现内容的绘制。 12345678910111213141516171819202122232425 function mask(cls){ let targetNode = document.querySelector(`.${cls}`); let pos = targetNode.getBoundingClientRect(); let canvas = document.getElementById(\"mask\"); let width = window.innerWidth; let height = window.innerHeight;; canvas.setAttribute(\"width\", width); canvas.setAttribute(\"height\",height); var ctx = canvas.getContext(\"2d\"); ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle ='rgba(255, 255, 255, 0.9)'; ctx.fillRect(0, 0, width, height); ctx.fill(); ctx.fillStyle ='white'; ctx.globalCompositeOperation=\"xor\"; ctx.fillRect(pos.left,pos.top,pos.width,pos.height); ctx.fill(); }let array = ['one','two','three','four'];let i = 0;setInterval(()=&gt;{ mask(array[i]); i++; if(i&gt;=4) i = 0;},1000) 看完以上实现，你最喜欢哪种实现方式呢？","link":"/2019/09/20/guid-mask/"},{"title":"【译】在生产环境中使用原生JavaScript模块","text":"原文地址：https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/原文作者：PHILIP WALTON译者：龚亮 ，校对：刘辉声明：本翻译仅做学习交流使用，转载请注明来源 两年前，我写了一篇有关module/nomodule技术的文章，这项技术允许你在编写ES2015+代码时，使用打包器和转换器生成两个版本的代码库，一个具有现代语法的版本（通过&lt;script type=&quot;module&quot;&gt;加载）和一个使用ES5语法的版本（通过&lt;script nomodule&gt;加载）。该技术允许你向支持模块（译者注：指ECMA制定的标准的export/import模块语法及其加载机制，又称为ES Module、ESM、ES6 Module、ES2015 Module，下文中将出现很多”模块”一词，都是这个含义）的浏览器发送更少的代码，现在大多数Web框架和CLI都支持它。 但是那时候，尽管能够在生产中部署现代JavaScript，大多数浏览器也都支持模块，我仍然建议打包你的代码。 为什么？主要是因为我觉得在浏览器中加载模块很慢。尽管像HTTP/2这样的新协议理论上有效地支持加载大量小文件，但当时的所有性能研究都认为使用打包器更有效。 其实当时的研究是不完整的。该研究所使用的模块测试示例由部署到生产环境中未优化和未缩小的源文件组成。它并没有将优化后的模块包与优化后的原始脚本进行比较。 不过，当时并没有更好的方法来部署模块(译者注：指遵循ES2015模块规范的文件)。但是现在，打包技术取得了一些最新进展，可以将生产代码部署为ES2015模块(包含静态导入和动态导入)，从而获得比非模块(译者注：指除ES2015模块外的传统部署方式)更好的性能。实际上，这个站点(译者注：指原文章所在的网站)已经在生产环境中使用原生模块好几个月了。 对模块的误解与我交流过的很多人都认为模块（译者注：指遵循ES2015模块规范的部署方式）是大规模生产环境下应用程序的一个选择罢了。他们中的许多人引用了我刚刚提到的研究，并建议不要在生产环境中使用模块，除非: …小型web应用程序，总共只有不到100个模块，依赖树相对较浅(即最大深度小于5)。 如果你曾经查看过node_modules目录，可能知道即使是小型应用程序也很容易有超过100个模块依赖项。我们来看看npm上一些流行的工具包有多少个模块依赖项吧： 包 模块数量 date-fns 729 lodash-es 643 rxjs 226 人们对模块的主要误解是，在生产环境中使用模块时只有两个选择：(1)按原样部署所有源代码(包括node_modules目录)，(2)完全不使用模块。 如果你仔细考虑我所引用研究给出的建议，它没有说加载模块比普通加载脚本慢，也没有说你不应该使用模块。它只是说，如果你将数百个未经过压缩的模块文件部署到生产环境中，Chrome将无法像加载单个经过压缩的模块一样快速的加载它们。所以建议继续使用打包器、编译器和压缩器（译者注：原文是minifier，指去除空格注释等）。 实际情况是，你可以在生产环境中使用上面所有技术的同时，也可以使用ES2015模块！ 事实上，因为浏览器已经知道如何加载模块（对不支持模块的浏览器可以做降级处理），所以模块才是我们应该打包出的格式。如果你检查大多数流行的打包器生成的输出代码，你会发现很多样板代码（译者注：指rollup和webpack中的runtime的代码），其唯一的目的是动态加载其它代码并管理依赖，但如果我们只使用带有import和export语句的模块，则不需要这些代码！ 幸运的是，今天至少有一个流行的打包器（Rollup）支持模块作为输出格式，这意味着可以打包代码并在生产环境中部署模块（没有加载器样板代码）。由于Rollup（根据我的经验，这是最好的打包器）具有出色的tree-shaking，使得Rollup打包出的模块是目前所有打包器输出模块中代码最少的。 更新： Parcel计划在下一版本中添加模块支持。Webpack目前不支持模块输出格式，但这里有一些相关讨论＃2933，＃8895，＃8896。 另一个误解是，除非你的所有依赖项都使用模块，否则你不能使用模块。不幸的是大多数npm包仍然以CommonJS的形式发布(甚至有些包以ES2015编写，但在发布到npm之前转换为CommonJS)！ 尽管如此，Rollup有一个插件（rollup-plugin-commonjs），它可以将CommonJS源代码转换为ES2015。如果一开始你的依赖项采用ES2015模块管理肯定会更好，但是有一些依赖关系不是这样管理的并不会阻止你部署模块。 在本文的剩余部分，我将向你展示如何打包到模块（包括使用动态导入和代码拆分的粒度），解释为什么它通常比原始脚本更高效，并展示如何处理不支持模块的浏览器。 最优打包策略打包生产代码一直是需要权衡利弊。一方面，希望代码尽快加载和执行。另一方面，又不希望加载用户实际用不到的代码。 同时，还希望代码尽可能地被缓存。打包的一个大问题是，即使只是一行代码有修改也会使整个打包后的包缓存失效。如果直接使用ES2015模块部署应用程序（就像它们在源代码中一样），那么你可以自由地进行小的更改，同时让应用程序的大部分代码仍然保留在缓存中。但就像我已经指出的那样，这也意味着你的代码需要更长时间才能被新用户的浏览器加载完成。 因此，找到最优打包粒度的挑战是在加载性能和长期缓存之间取得适当的平衡。 默认情况下，大多数打包器在动态导入时进行代码拆分，但我认为仅动态导入的代码拆分粒度不够细，特别是对于拥有大量留存用户的站点（缓存很重要）。 在我看来，你应该尽可能细粒度地拆分代码，直到开始显著地影响加载性能为止。虽然我强烈建议你自己动手进行分析，但是查阅上文引用的研究可以得出一个大致的结论。当加载少于100个模块时，没有明显的性能差异。针对HTTP/2性能的研究发现，加载少于50个文件时没有明显的差异(尽管他们只测试了1、6、50和1000，所以100个文件可能就可以了)。 那么，最好的代码拆分方法是什么呢？除了通过动态导入做代码拆分外，我还建议以npm包为粒度做代码拆分，node_modules中的模块都合并到以其包名命名的文件中。 包级别的代码拆分如上所述，打包技术的一些最新进展使得高性能模块部署成为可能。我提到的增强是指Rollup的两个新功能：通过动态import()时自动代码拆分（在v1.0.0中添加）和通过manualChunks选项进行可编程的手动代码拆分（在v1.11.0中添加）。 有了这两个功能，现在很容易在包级别进行代码拆分的构建配置。 这是一个使用manualChunks选项配置的例子，每个位于node_module里的模块将被合并到以包名命名的文件里(当然，这种模块路径里肯定包含node_modules) 1234567891011121314151617181920export default { input: { main: &apos;src/main.mjs&apos;, }, output: { dir: &apos;build&apos;, format: &apos;esm&apos;, entryFileNames: &apos;[name].[hash].mjs&apos;, }, manualChunks(id) { if (id.includes(&apos;node_modules&apos;)) { // Return the directory name following the last `node_modules`. // 返回最后一个node_modules后面跟着的目录名 // Usually this is the package, but it could also be the scope. // 通常都会是一个包名，也有可能是一个私有域 const dirs = id.split(path.sep); return dirs[dirs.lastIndexOf(&apos;node_modules&apos;) + 1]; } },} manualChunks选项接收一个函数，该函数将模块文件路径作为惟一的参数，也可以返回一个文件名，参数中的模块将被加入到这个文件里。如果没有返回任何内容，参数中的模块将被添加到默认文件中。 考虑从lodash-es包中导入cloneDeep()、debounce()和find()模块的一个应用程序。上面的配置将把各个模块(以及它们导入的任何其它lodash模块)一起放入一个名为npm.lodash-es.XXXX.mjs的输出文件中，(其中XXXX是lodash-es模块文件的哈希值)。 在该文件的末尾，你会看到这样的导出语句(注意，它只包含添加到块中模块的导出语句，而不是所有lodash模块): 1export {cloneDeep, debounce, find}; 希望这个例子能清楚地说明使用Rollup手动拆分代码的工作原理。就我个人而言，我认为使用import和export语句的代码拆分比使用非标准的、特定于打包器实现的代码拆分更容易阅读和理解。 例如，跟踪这个文件中发生了什么很难(我以前使用webpack对一个项目做代码拆分后的实际输出)，而且在支持模块的浏览器中其实不需要这些代码: 12345678910111213141516171819(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[&quot;import1&quot;],{/***/ &quot;tLzr&quot;:/*!*********************************!*\\ !*** ./app/scripts/import-1.js ***! \\*********************************//*! exports provided: import1 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;import1&quot;, function() { return import1; });/* harmony import */ var _dep_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dep-1 */ &quot;6xPP&quot;);const import1 = &quot;imported: &quot; + _dep_1__WEBPACK_IMPORTED_MODULE_0__[&quot;dep1&quot;];/***/ })}]); 如果你有数百个npm依赖项怎么办？我在上面说过，我认为包级别上的代码拆分是站点代码拆分的最佳状态，而又不会太激进。 当然，如果你的应用程序从数百个不同的npm包中导入模块，那么浏览器可能无法有效地加载所有模块。 但是，如果你确实有很多npm依赖项，那么先不要完全放弃这个策略。请记住，你可能不会在每个页面上加载所有的npm依赖项，因此检查实际加载了多少依赖项非常重要。 尽管如此，确实有一些非常大的应用程序具有如此多的npm依赖关系，以至于它们不能实际地对其中的每一个应用程序进行代码拆分。如果你是这种情况，我建议你找出一种方法来将一些依赖项分组到公共文件中。一般来说，你可以将可能在同一时间发生变化的包(例如，React和react-dom)分组，因为它们必须一起失效(例如，我稍后展示的示例应用程序将所有React依赖项分组为同一个文件)。 动态导入使用原生import语句进行代码拆分和模块加载的一个缺点是，需要开发人员对不支持模块的浏览器做兼容处理。 如果你想使用动态import()懒加载代码，那么你还必须处理这样一个事实：有些浏览器支持模块，但不支持动态import()（Edge 16–18, Firefox 60–66, Safari 11, Chrome 61–63）。 幸运的是，一个很小的(~400字节)、非常高性能的polyfill可用于动态import()。 向站点添加polyfill很容易。你所要做的是导入它并在应用程序的主入口点初始化它(在调用import()之前): 12345import dynamicImportPolyfill from &apos;dynamic-import-polyfill&apos;;// This needs to be done before any dynamic imports are used. And if your// modules are hosted in a sub-directory, the path must be specified here.dynamicImportPolyfill.initialize({modulePath: &apos;/modules/&apos;}); 最后要做的是告诉Rollup将输出代码中的动态import()重命名为你指定的另一个名称(通过output.dynamicImportFunction选项配置)。动态导入polyfill默认使用名称为import，但是可以配置它。 需要重命名import()语句的原因是import是JavaScript中的一个关键字。这意味着不可能使用相同的名称来填充原生import()，因为这样做会导致语法错误。 让Rollup在构建时重命名它是很好的，这意味着你的源代码可以使用标准版本，并且在将来不再需要polyfill时，你将不必重新更改它。 高效加载JavaScript模块当你使用代码拆分的时候，最好预加载所有马上要使用的模块(即主入口模块导入图中的所有模块)。 但是，当你加载实际的JavaScript模块（通过&lt;script type=&quot;module&quot;&gt;以及随后import语句引用的模块时），你将希望使用modulepreload而不是传统的preload(仅适用于原始脚本)。 123456&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-one.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-two.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-three.XXXX.mjs&quot;&gt;&lt;!-- ... --&gt;&lt;script type=&quot;module&quot; src=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;/script&gt; 实际上，对于预加载原生的模块，modulepreload实际上比传统的preload要严格得多，它不仅下载文件，而且在主线程之外立即开始解析和编译文件。传统的预加载无法做到这一点，因为它不知道在预加载时该文件将用作模块脚本还是原始脚本。 这意味着通过modulepreload加载模块通常会更快，而且在实例化时不太可能导致主线程卡顿。 生成modulepreload列表Rollup的bundle对象中的每个入口文件在其静态依赖关系图中包含完整的导入列表，因此在Rollup的generateBundle钩子中很容易获得需要预加载哪些文件的列表。 虽然在npm上确实存在一些modulepreload插件，但是为图中的每个入口点生成一个modulepreload列表只需要几行代码，所以我更愿意像这样手动创建它: 123456789101112131415{ generateBundle(options, bundle) { // A mapping of entry chunk names to their full dependency list. const modulepreloadMap = {}; for (const [fileName, chunkInfo] of Object.entries(bundle)) { if (chunkInfo.isEntry || chunkInfo.isDynamicEntry) { modulepreloadMap[chunkInfo.name] = [fileName, ...chunkInfo.imports]; } } // Do something with the mapping... console.log(modulepreloadMap); }} 例如，这里是我如何为这个站点以及我的demo应用生成modulepreload列表的。 注意：虽然对于模块脚本来说，modulepreload绝对比原始的preload更好，但它对浏览器的支持更差(目前只支持chrome)。如果你的流量中有相当一部分是非chrome流量，那么使用classic preload是有意义的。 与使用modulepreload不同，使用preload时需要注意的一点是，预加载脚本不会放在浏览器的模块映射中，这意味着可能会不止一次地处理预加载的请求(例如，如果模块在浏览器完成预加载之前导入文件)。 为什么要部署原生模块？如果你已经在使用像webpack这样的打包器，并且已经在使用细粒度代码拆分和预加载这些文件(与我在这里描述的类似)，那么你可能想知道是否值得改变策略，使用原生模块。下面是我认为你应该考虑它的几个原因，以及为什么打包到原生模块比使用带有模块加载代码的原始脚本要好。 更小的代码总量当使用原生模块时，现代浏览器不必为用户加载任何不必要的模块加载或依赖关系管理代码。例如，如果使用原生模块，则根本不需要webpack运行时和清单。 更好的预加载正如我在前一节中提到的，使用modulepreload允许你加载代码并在主线程之外解析/编译代码。在其他条件相同的情况下，这意味着页面的交互速度更快，并且主线程在用户交互期间不太可能被阻塞。 因此，无论你如何细粒度地对应用程序进行代码拆分，使用import语句和modulepreload加载模块要比通过原始script标签和常规preload加载更有效(特别是如果这些标签是动态生成的，并在运行时添加到DOM中)。 换句话说，由Rollup打包出的20个模块文件将比由webpack打包出的20个原始脚本文件加载得更快(不是因为webpack，而是因为它不是原生模块)。 更面向未来许多最令人兴奋的新浏览器特性都是构建在模块之上的，而不是原始的脚本。这意味着，如果你想使用这些特性中的任何一个，你的代码需要作为原生模块部署，而不是转换为ES5并通过原始的script标签加载(我在尝试使用实验性KV存储API时曾提到过这个问题)。 以下是一些仅限模块才有的最令人兴奋的新功能： 内置模块 HTML模块 CSS模块 JSON模块 导入地图 workers、service workers和window之间共享模块 支持旧版浏览器在全球范围内，超过83%的浏览器原生支持JavaScript模块(包括动态导入)，因此对于你的大多数用户来说，不需要做任何处理就可以使用这项技术。 对于支持模块但不支持动态导入的浏览器，可以使用上面提到的dynamic-import-polyfill。由于polyfill非常小，并且在可用时将使用浏览器的原生动态import()，因此添加这个polyfill几乎没有大小或性能成本。 对于根本不支持模块的浏览器，可以使用我前面提到的module/nomodule技术。 一个实际的例子由于谈论跨浏览器兼容性总是比实际实现它要容易，所以我构建了一个演示应用程序，它使用了我在这里阐述的所有技术。 这个演示程序可以在不支持动态import()的浏览器中运行(如Edge 18和Firefox ESR)，也可以在不支持模块的浏览器中运行(如Internet Explorer 11)。 为了说明这个策略不仅适用于简单的用例，我还包含了当今复杂的JavaScript应用程序需要的许多特性: Babel转换（包括JSX） CommonJS的依赖关系（例如react，react-dom） CSS依赖项 Asset hashing 代码拆分 动态导入（带有polyfill降级机制） module/nomodule降级机制 代码托管在GitHub上(因此你可以派生repo并自己构建它)，而演示则托管在Glitch上，因此你可以重新组合代码并使用这些特性。 最重要的是查看示例中使用的Rollup配置，因为它定义了如何生成最终模块。 总结希望这篇文章让你相信，现在不仅可以在生产环境中部署原生JavaScript模块，而且这样做可以提高站点的加载和运行时性能。 以下是快速完成此工作所需步骤的摘要： 使用打包器，但要确保输出格式为ES2015模块 积极地进行代码拆分(如果可能的话，一直到node包) 预加载静态依赖关系图中的所有模块(通过modulepreload) 使用polyfill来支持不支持动态import()的浏览器 使用&lt;script nomodule&gt;支持根本不支持模块的浏览器 如果你已经在构建设置中使用了Rollup，我希望你尝试这里介绍的技术，并在生产环境中部署原生模块(带有代码拆分和动态导入)。如果你这样做了，请告诉我进展如何，因为我既想听你的问题，也想听你的成功故事！ 模块是JavaScript的明确未来，我希望我们所有的工具和依赖都能尽快包含模块。希望本文能在这个方向上起到一点推动作用。 译者评：1.作者上一篇文章的译文：https://jdc.jd.com/archives/49112.另外一篇讲JavaScript原生模块的文章：https://www.jianshu.com/p/9aae3884b05b","link":"/2019/09/10/【译】在生产环境中使用原生JavaScript模块/"}],"tags":[{"name":"AST","slug":"AST","link":"/tags/AST/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS Houdini","slug":"CSS-Houdini","link":"/tags/CSS-Houdini/"},{"name":"碰撞检测","slug":"碰撞检测","link":"/tags/碰撞检测/"},{"name":"向量","slug":"向量","link":"/tags/向量/"},{"name":"webpack loader","slug":"webpack-loader","link":"/tags/webpack-loader/"},{"name":"工程化","slug":"工程化","link":"/tags/工程化/"},{"name":"web内容","slug":"web内容","link":"/tags/web内容/"},{"name":"电池电量","slug":"电池电量","link":"/tags/电池电量/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"},{"name":"引导蒙层","slug":"引导蒙层","link":"/tags/引导蒙层/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"type=\"module\"","slug":"type-module","link":"/tags/type-module/"},{"name":"代码拆分","slug":"代码拆分","link":"/tags/代码拆分/"},{"name":"rollup打包","slug":"rollup打包","link":"/tags/rollup打包/"},{"name":"modulepreload","slug":"modulepreload","link":"/tags/modulepreload/"}],"categories":[{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"Web开发","slug":"Web开发","link":"/categories/Web开发/"}]}