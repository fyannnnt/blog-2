{"pages":[{"title":"WecTeam | 京东社交电商前端团队","text":"维C团简介维C团(WecTeam)是京东社交电商部跨多个业务团队的前端工程师自发成立的一个前端技术团队，我们热爱技术，乐于分享，希望通过技术实践总结、新技术探秘、Bug深度分析、优质英文资料引入等方式，参与和推动前端技术的发展，为公司及行业带来价值！ 联系我们","link":"/about/index.html"}],"posts":[{"title":"Javascript抽象语法树上篇(基础篇)","text":"一、基础为什么要了解抽象语法树日常工作中，我们会碰到js代码解析的场景，比如分析代码中require了哪些包，有些什么关键API调用，大部分情况使用正则表达式来处理，可一旦场景复杂，或者依赖于代码上下文时，正则就很难处理了，这时候就要用到抽象语法树。常见的uglify、eslint、babel、webpack等等都是基于抽象语法树来处理的，如此强大，有必要好好了解一下。 什么是抽象语法树抽象语法树即：Abstract Syntax Tree。简称AST，见下图。 图中code先经过parse转换成一个树状数据结构 接着对树中节点进行转换，图中将叶子节点对换位置 将树状结构通过generate再生成code 图中树状数据结构即AST，从这个过程可以看到将代码转成AST后，通过操作节点来改变代码。 如何获得抽象语法树获得抽象语法树的过程为：代码 =&gt; 词法分析 =&gt; 语法分析 =&gt; AST词法分析：把字符串形式的代码转换为令牌（tokens）流。语法分析：把一个令牌流转换成 AST 的形式。这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。如下图，代码为一个简单的函数声明。词法分析阶段，将代码作为字符串输入获得关键词，图中function、square、(、)、{、}等都被识别为关键词(稍微回忆下编译原理，字符挨个入栈，符合一定规则即出栈)。语法分析阶段，对关键词的组合形成一个个节点，如n*n这3个关键词组合成二元表达式，关键词return与二元表达式组合成return语句。最后组合成一个函数声明语句。 二、规范如何获得AST已经简单介绍了，那AST最终应该以什么样的数据结构存在呢，先看看上述函数声明的AST结构 那解析的依据是什么，为什么要以上图的结构出现，业界已经有了一套成熟的规范。 规范起源在v8引擎之前，最早js引擎是SpiderMonkey，第一个版本由js作者Brendan Eich设计，后交给Mozilla组织维护。js引擎在执行js文件时，都会先将js代码转换成抽象语法树(AST)。有一天，一位Mozilla工程师在FireFox中公开了这个将代码转成AST的解析器Api，也就是Parser_API[1]，后来被人整理到github项目estree[2]，慢慢的成了业界的规范。 规范解读上面提到的Parser_API是规范的原文，中文版:Parser_API[3]，但读起来并不太友好，推荐直接读整理后的git项目estree，打开项目地址，如下图其中最下面的es5.md为ES5规范，仅列出ES5的内容，es2015.md为ES6规范，但只列出了针对ES5新增的内容，依次类推，最后的es2019.md即ES10是对ES9的补充，仅有一条规则。 打开最基础的es5.md，可以看到所有语法基础，这里跟大家一起读一下大类，细分类别就略过了。读规范时可以使用https://astexplorer.net/ 辅助阅读，可以实时输出AST。 Node objects Programs Identifier Literal Functions Statements Declarations Expressions Patterns Node objects1234interface Node { type: string; loc: SourceLocation | null;} 定义AST中节点基本类型，其他所有具体节点都需要实现以上接口，即每个节点都必须包含type、loc两个字段 type字段表示不同的节点类型，下边会再讲一下各个类型的情况，分别对应了 JavaScript 中的什么语法。你可以从这个字段看出这个节点实现了哪个接口loc字段表示源码的位置信息，如果没有相关信息的话为 null，否则是一个对象，包含了开始和结束的位置。接口如下 12345interface SourceLocation { source: string | null; start: Position; end: Position;} 每个 Position 对象包含了行（从1开始）和列（从0开始）信息，接口如下 1234interface Position { line: number; // &gt;= 1 column: number; // &gt;= 0} Programs1234interface Program &lt;: Node { type: \"Program\"; body: [ Directive | Statement ];} 一棵完整的程序代码树，一般作为根节点 Identifier1234interface Identifier &lt;: Expression, Pattern { type: \"Identifier\"; name: string;} 标识符，我们写代码时自定义的名称，如变量名、函数名、属性名。 Literal1234interface Literal &lt;: Expression { type: \"Literal\"; value: string | boolean | null | number | RegExp;} 字面量，如“hello”、true、null、100、/\\d/这些，注意字面量本身也是一个表达式语句(ExpressionStatement) Functions12345interface Function &lt;: Node { id: Identifier | null; params: [ Pattern ]; body: FunctionBody;} 一个函数声明或者表达式，id是函数名，params是标识符数组，body是函数体，也是一个语句块。 Statements1interface Statement &lt;: Node { } 语句，子类有很多，块语句、if/switch语句、return语句、for/while语句、with语句等等 Declarations1interface Declaration &lt;: Statement { } 声明，子类主要有变量申明、函数声明。 Expressions1interface Expression &lt;: Node { } 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式(a = 1)等等 Patterns1interface Pattern &lt;: Node { } 模式，主要在 ES6 的解构赋值中有意义(let {name} = user，其中{name}部分为ObjectPattern)，在 ES5 中，可以理解为和Identifier 差不多的东西。 三、现状通过以上规范解读，知道了最终要生成的AST以什么样的结构存在，对于javascript的解析，业界已经有很多成熟的解析器，可以将js代码转换成符合规范的AST Esprima，比较经典，出现的比较早 Acorn，fork自Esprima，代码更精简。webpack使用acorn进行模块解析 UglifyJS2，主要用于代码压缩 babylon，babel解析器，fork自Acorn，目前最新版本是babylon7,对应npm包@babel/parser Espree，eslint默认的解析器，由于遵循同一套规范，也可以使用babel的解析器替代 flow、shift等等 AST基础篇介绍完毕，下篇将从实践的角度继续介绍 References[1] Parser_API：https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API[2] estree：https://github.com/estree/estree[3] Parser_API(中文)：https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API","link":"/2019/07/19/Javascript抽象语法树上篇(基础篇)/"},{"title":"碰撞检测的向量实现","text":"注：1、本文只讨论2d图形碰撞检测。2、本文讨论圆形与圆形，矩形与矩形、圆形与矩形碰撞检测的向量实现 前言2D游戏中，通常使用矩形、圆形等来代替复杂图形的相交检测。因为这两种形状的碰撞检测速度是最快的。其中矩形包围盒又可以分为轴对齐包围盒（AABB, Axis Aligned Bounding Box）与转向包围盒（OBB, Oriented Bounding Box）。AABB与OBB的区别在于，AABB中的矩形的其中一条边和坐标轴平行，OBB的计算复杂度要高于AABB。根据不同的使用场景，可以用不同的方案。 如上图，明显皮卡超适合用包围盒，精灵球适合用包围球。 向量向量作为一种数学工具，在碰撞检测中发挥很大作用，后面的计算都是通过向量来完成，所以先来复习一下向量。 向量的代数表示向量的代数表示指在指定了一个坐标系之后，用一个向量在该坐标系下的坐标来表示该向量，兼具了符号的抽象性和几何形象性，因而具有最高的实用性，被广泛采用于需要定量分析的情形。 对于自由向量，将向量的起点平移到坐标原点后，向量就可以用一个坐标系下的一个点来表示，该点的坐标值即向量的终点坐标。 123456789// 二维平面向量class Vector2d{ constructor(vx=1,vy=1){ this.vx = vx; this.vy = vy; }}const vecA = new Vector2d(1,2);const vecB = new Vector2d(3,1); 向量运算加法：向量的加法满足平行四边形法则和三角形法则。具体的，两向量相加还是一个向量，分别是x与y两个分量的相加。 123456// 向量的加法运算static add(vec,vec2){ const vx = vec.vx + vec2.vx; const vy = vec.vy + vec2.vy; return new Vector2d(vx,vy);} 减法：两个向量a和b的相减得到的向量可以表示为a和b的起点重合后，从b的终点指向a的终点的向量： 123456// 向量的减法运算static sub(vec,vec2){ const vx = vec.vx - vec2.vx; const vy = vec.vy - vec2.vy; return new Vector2d(vx,vy);} 大小：向量的大小，是其各个分量的平方和开方。 1234// 获取向量长度length(){ return Math.sqrt(this.vx * this.vx + this.vy * this.vy);} 点积：从代数角度看，先对两个数字序列中的每组对应元素求积，再对所有积求和，结果即为点积。 1234// 向量的数量积static dot(vec,vec2){ return vec.vx * vec2.vx + vec.vy * vec2.vy;} 旋转：向量的旋转可以用旋转矩阵求解 12345678//向量的旋转 static rotate(vec,angle){ const cosVal = Math.cos(angle); const sinVal = Math.sin(angle); const vx = vec.vx * cosVal - vec.vy * sinVal; const vy = vec.vx * sinVal + vec.vy * cosVal; return new Vector2d(vx,vy);} 圆圆形比较简单，只要确认圆心x,y和半径r就行了,然后推导出圆心向量。 123456789class Circle{ // x,y是圆的圆心 r是半径 constructor(x=0,y=0,r=1){ this.x = x; this.y = y; this.r = r; } get P(){ return new Vector2d(this.x,this.y) } // 圆心向量} 矩形矩形就较为复杂，定义一个矩形需要中心坐标的x,y、两边长w和h，还有根据中心的旋转角度rotation 12345678910export class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; }} 两圆相交 两圆相交比较简单，只需判断两圆心之间的距离小于两圆的半径之和。 两圆心距离可以用圆心向量相减，然后求相减向量的长度。 12345678circleCircleIntersect(circle1,circle2){ const P1 = circle1.P; const P2 = circle2.P; const r1 = circle1.r; const r2 = circle2.r; const u = Vector2d.sub(P1,P2); return u.length() &lt;= r1 + r2 ;} 圆和矩形相交涉及到矩形的相交问题都先要判断是否轴对称。 矩形轴对称 先看轴对称的情况，下面是来自知乎问题怎样判断平面上一个矩形和一个圆形是否有重叠？「Milo Yip」的回答搬运： 设c为矩形中心，h为矩形半長，p为圆心，r为半径。 方法是计算圆心与矩形的最短距离 u，若 u 的长度小于 r 则两者相交。 首先利用绝对值把 p - c 转移到第一象限，下图显示不同象限的圆心也能映射至第一象限，这不影响相交测试的结果： 然后，把 v 减去 h，负数的分量设置为0，就得到圆心与矩形最短距离的矢量 u。下图展示了4种情况，红色的u是结果。 最后要比较 u 和 r 的长度，若距离少于 r，则两者相交。可以只求 u 的长度平方是否小于 r 的平方。 下面我用js实现一下： 其中矩形的四个顶点命名为A1，A2，A3，A4，矩形在第一象限的半長h等于CA3 1234567891011121314151617181920212223class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量}rectCircleIntersect(rect,circle){ const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = circle.P; const h = Vector2d.sub(A3,C); // 矩形半长 const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 矩形非轴对称 这个问题其实也很好解决，将矩形中心视为旋转中心，将矩形和圆形一起反向旋转将矩形转为轴对称，然后就可以套用上面的解法。 矩形中心到圆心向量为是CP 反向旋转θ度得向量CP’ 然后根据向量得三角形定律得OP’ = OC + CP’ 后面就代入矩形是轴对称的公式进行计算 12345678910111213141516171819202122232425262728293031323334353637class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}p(rect,circle){ const rotation = rect.rotation; const C = rect.C; let P; if (rotation % 360 === 0) { P = circle.P; // 轴对称直接输出P } else { P = Vector2d.add(C,Vector2d.rotate(Vector2d.sub(circle.P,C),rect._rotation*-1)); // 非轴对称，计算P‘ } return P;}rectCircleIntersect(rect,circle){ const rotation = rect.rotation; const C = rect.C; const r = circle.r; const A3 = rect.A3; const P = p(rect,circle); const h = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - h.vx,0),Math.max(v.vy - h.vy,0)); return u.lengthSquared() &lt;= r * r;} 查看Demo1 https://rococolate.github.io/blog/gom/test1.html 两矩形相交两矩形都轴对称AABB 想象一下两个矩形A和B，B贴着A的边走了一圈，B的矩形中心的轨迹是一个新的矩形，这样就简化成新矩形与B中心点这一点的相交问题，又因为点可以看成是半径为0的圆，所以问题又转换为圆形和矩形相交。 1234567891011121314151617181920212223242526class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } // 矩形中心向量 get A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } // 顶点A3向量 get _rotation(){ return this.rotation / 180 * Math.PI; } // 角度单位转换}AABBrectRectIntersect(rect1,rect2){ const P = rect2.C; const w2 = rect2.w; const h2 = rect2.h; const {w,h,x,y} = rect1; const C = rect1.C; const A3 = new Vector2d(x+w/2+w2/2,y+h/2+h2/2); // 新矩形的半长 const H = Vector2d.sub(A3,C); const v = new Vector2d(Math.abs(P.vx - C.vx),Math.abs(P.vy - C.vy)); const u = new Vector2d(Math.max(v.vx - H.vx,0),Math.max(v.vy - H.vy,0)); return u.lengthSquared() === 0; // 点可以看成是半径为0的圆} 两矩形相交非轴对称OBB 两个矩形的OBB检测使用分离轴定理（Separating Axis Theorem） 分离轴定理：通过判断任意两个矩形 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 因为矩形的对边平行，所以只要判断四条对称轴上的投影即可。 如何投影？这里补充一下向量点积的几何意义。 在欧几里得空间中，点积可以直观地定义为 A·B = |A||B|cosθ ,其中|A|cosθ是A到B的投影，如果B是单位向量，那么A·B就是A到单位向量B的投影 回到矩形，将矩形4个顶点都投影到对称轴上，我们分别将其点乘即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Rect{ // x,y是矩形中心的坐标 w是宽 h是高 rotation是角度单位deg constructor(x=0,y=0,w=1,h=1,rotation=0){ this.x = x; this.y = y; this.w = w; this.h = h; this.rotation = rotation; } get C(){ return new Vector2d(this.x,this.y); } get _A1(){ return new Vector2d(this.x-this.w/2,this.y-this.h/2); } // 4角顶点 get _A2(){ return new Vector2d(this.x+this.w/2,this.y-this.h/2); } get _A3(){ return new Vector2d(this.x+this.w/2,this.y+this.h/2); } get _A4(){ return new Vector2d(this.x-this.w/2,this.y+this.h/2); } get _axisX(){ return new Vector2d(1,0); } // 未旋转时的对称轴X get _axisY(){ return new Vector2d(0,1); } // 未旋转时的对称轴Y get _CA1(){ return Vector2d.sub(this._A1,this.C); } get _CA2(){ return Vector2d.sub(this._A2,this.C); } get _CA3(){ return Vector2d.sub(this._A3,this.C); } get _CA4(){ return Vector2d.sub(this._A4,this.C); } get _rotation(){ return this.rotation / 180 * Math.PI; } get A1(){ return this.rotation % 360 === 0 ? this._A1 : Vector2d.add(this.C,Vector2d.rotate(this._CA1,this._rotation)); } // 计算上旋转后4角顶点 get A2(){ return this.rotation % 360 === 0 ? this._A2 : Vector2d.add(this.C,Vector2d.rotate(this._CA2,this._rotation)); } get A3(){ return this.rotation % 360 === 0 ? this._A3 : Vector2d.add(this.C,Vector2d.rotate(this._CA3,this._rotation)); } get A4(){ return this.rotation % 360 === 0 ? this._A4 : Vector2d.add(this.C,Vector2d.rotate(this._CA4,this._rotation)); } get axisX(){ return this.rotation % 360 === 0 ? this._axisX : Vector2d.rotate(this._axisX,this._rotation); } // 计算上旋转后的对称轴X get axisY(){ return this.rotation % 360 === 0 ? this._axisY : Vector2d.rotate(this._axisY,this._rotation); } // 计算上旋转后的对称轴Y get _vertexs(){ return [this._A1,this._A2,this._A3,this._A4]; } get vertexs(){ return [this.A1,this.A2,this.A3,this.A4]; } // 4角顶点数组}OBBrectRectIntersect(rect1,rect2){ const rect1AxisX = rect1.axisX; const rect1AxisY = rect1.axisY; const rect2AxisX = rect2.axisX; const rect2AxisY = rect2.axisY; if (!cross(rect1,rect2,rect1AxisX)) return false; // 一旦有不相交的轴就可以return false if (!cross(rect1,rect2,rect1AxisY)) return false; if (!cross(rect1,rect2,rect2AxisX)) return false; if (!cross(rect1,rect2,rect2AxisY)) return false; return true; // 4轴投影都相交 return true}cross(rect1,rect2,axis){ const vertexs1ScalarProjection = rect1.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形1的4个顶点投影并排序 const vertexs2ScalarProjection = rect2.vertexs.map(vex =&gt; Vector2d.dot(vex,axis)).sort((a,b)=&gt;a-b); // 矩形2的4个顶点投影并排序 const rect1Min = vertexs1ScalarProjection[0]; // 矩形1最小长度 const rect1Max = vertexs1ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形1最大长度 const rect2Min = vertexs2ScalarProjection[0]; // 矩形2最小长度 const rect2Max = vertexs2ScalarProjection[vertexs1ScalarProjection.length - 1]; // 矩形2最大长度 return rect1Max &gt;= rect2Min &amp;&amp; rect2Max &gt;= rect1Min; // 相交判断 } 最后放上一个相交的应用Demo https://rococolate.github.io/blog/gom/test2.html,Demo里的形状都可以拖拽，当碰到其他形状时会变透明。 参考文章第十五章：碰撞检测 http://blog.jmecn.net/chapter-15-collision-detection/ 方块的战争：浅谈格斗游戏的精髓 http://daily.zhihu.com/story/4761397 怎样判断平面上一个矩形和一个圆形是否有重叠？ https://www.zhihu.com/question/24251545 “等一下，我碰！”——常见的2D碰撞检测 https://aotu.io/notes/2017/02/16/2d-collision-detection/index.html 码农干货系列【1】–方向包围盒(OBB)碰撞检测 https://www.cnblogs.com/iamzhanglei/archive/2012/06/07/2539751.html Rotation matrix https://en.wikipedia.org/wiki/Rotation_matrix 数量积 https://zh.wikipedia.org/wiki/%E7%82%B9%E7%A7%AF 向量 https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F","link":"/2019/06/27/collision-detection/"},{"title":"Javascript抽象语法树下篇(实践篇)","text":"上篇已经对AST基础做了介绍，本篇介绍AST的运用 AST应用的三个要点 需要一个解析器，将代码转换为AST 需要一个遍历器，能够遍历AST,并能够方便的对AST节点进行增删改查等操作 需要一个代码生成器，能够将AST转换为代码 esprima与babel常用的满足上述3个要点的工具包有两个，一个是esprima，一个是babel esprima相关包及使用如下 1234567891011const esprima = require('esprima'); // code =&gt; astconst estraverse = require('estraverse'); //ast遍历const escodegen = require('escodegen'); // ast =&gt; codelet code = 'const a = 1';const ast = esprima.parseScript(code);estraverse.traverse(ast, { enter: function (node) { //节点操作 }});const transformCode = escodegen.generate(ast); babel相关包及使用如下 123456789101112const parser = require('@babel/parser'); //code =&gt; astconst traverse = require('@babel/traverse').default; // ast遍历，节点增删改查，作用域处理等const generate = require('@babel/generator').default; // ast =&gt; codeconst t = require('@babel/types'); // 用于AST节点的Lodash式工具库,各节点构造、验证等let code = 'const a = 1';let ast = parser.parse(sourceCode);traverse(ast, { enter (path) { //节点操作 }})const transformCode = escodegen.generate(ast); 目前babel不管是从生态上还是文档上比esprima要好很多，因此推荐大家使用babel工具，本文示例也使用babel来做演示。 使用babel工具操作AST如上一章节所示 @babel/parser用于将代码转换为AST @babel/traverse用于对AST的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将AST转换成代码 @babel/types 用于AST节点操作的Lodash式工具库,各节点构造、验证等 更多api详见babel手册[1] 下面通过简单案例来介绍如何操作AST，注意案例只是示例，由于篇幅对部分边界问题只会注释说明，实际开发过程中需要考虑周全。 案例1:去掉代码中的console.log()实现代码 123456789101112131415161718192021const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types'); let sourceCode = `function square(n) { console.log(n); console.warn(n); return n * n;}`let ast = parser.parse(sourceCode); traverse(ast, { CallExpression(path) { let { callee } = path.node; if (callee.type === ‘MemberExpression’ &amp;&amp; callee.object.name === ‘console’ &amp;&amp; callee.property.name === ‘log’ ) { path.remove(); // 注意考虑对象挂载的识别，如global.console.log()，此时remove后剩下global.,会导致语法错误，此时可以判断父节点类型来排除 } }}) console.log(generate(ast).code); 处理结果 12345function square(n) {- console.log(n); console.warn(n); return n * n;} 此案例涉及知识点 如何通过 traverse遍历特定节点 识别出console.log()在规范中属于函数调用表达式,节点类型为CallExpression。 console.log本身即callee是在对象console上的一个方法，因此console.log是一个成员表达式，类型为MemberExpression。 MemberExpression根据规范有一个object属性代表被访问的对象，有一个property代表访问的成员。 通过path.remove()api可以对节点进行删除。 可以通过https://astexplorer.net/ 来辅助对代码节点的识别。注意选择babylon7，即babe7,对应@babel/parser 案例2:变量混淆实现代码 12345678910111213141516171819const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types'); let sourceCode = `function square(number) { console.warn(number); return number * number;}`let ast = parser.parse(sourceCode);traverse(ast, { FunctionDeclaration(path) { let unia = path.scope.generateUidIdentifier(\"a\"); path.scope.rename(\"number\",unia.name); }})console.log(generate(ast).code); 处理结果 1234567-function square(number) {+ function square(_a) {- console.warn(number);+ console.warn(_a);- return number * number;+ return _a * _a;} 此案例涉及知识点 path.scope保存了当前作用域的相关信息 可以通过api对作用域内的变量名进行批量修改操作 通过path.scope可以获得当前作用域唯一标识符，避免变量名冲突 案例3:转换箭头函数并去掉未使用参数实现代码 123456789101112131415161718192021222324252627const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types'); let sourceCode = `new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(1); },200)});`let ast = parser.parse(sourceCode);traverse(ast, { ArrowFunctionExpression (path) { let { id, params, body } = path.node; for(let key in path.scope.bindings){ //注意考虑箭头函数的this特性，若发现函数体中有this调用，则需要在当前作用域绑定其父作用域的this if(!path.scope.bindings[key].referenced){ params = params.filter(param=&gt;{ return param.name!==key; }) } } path.replaceWith(t.functionExpression(id, params, body)); }})console.log(generate(ast).code); 处理结果 1234567-new Promise((resolve,reject)=&gt;{+new Promise(function(resolve){- setTimeout(()=&gt;{+ setTimeout(function(){ resolve(1); },200)}); 此案例涉及知识点 箭头函数节点：ArrowFunctionExpression 通过path.scope可以识别变量引用情况，是否有被引用，被哪些路径引用 通过@babel/types可以很方便的构建任意类型节点 通过path.replaceWith()可以进行节点替换 案例4:京东购物小程序的Tree-shaking删掉小程序中的冗余代码，部分实现代码示例如下 1234567891011121314151617181920212223242526272829const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types'); let sourceCode = `export function square (x) { return x * x;}export function cube (x) { return x * x * x;}`let ast = parser.parse(sourceCode);traverse(ast, { ExportNamedDeclaration (path) { let unused = ['cube'] // 借助webpack，我们能获得导出的方法中，哪些是没有被使用过的 let { declaration = {} } = path.node; if (declaration.type === 'FunctionDeclaration') { unused.forEach(exportItem =&gt; { // references=1表示仅有一次引用，即export的引用，没有在别处调用 if (declaration.id.name === exportItem &amp;&amp; path.scope.bindings[exportItem].references === 1) { path.remove(); } }); } }})console.log(generate(ast).code); 处理结果 123456export function square (x) { return x * x;}-export function cube (x) {- return x * x * x;-} 此案例涉及知识点 export节点：ExportNamedDeclaration 案例5:将代码转换成svg流程图此案例是git上一个比较有意思的开源项目，通过AST将代码转换为svg流程图，详见js-code-to-svg-flowchart[2] 可以体验一下：demo[3] 通过以上示例，可以看到通过AST我们可以对代码任意蹂躏，做出很多有意思的事情 AST在其他语言的应用除了Javascript，其他语言如HTML、CSS、SQL等也有广泛的AST应用。如下图，可以在这里找到对应语言的解析器，开启AST之门。 结语在上述AST网站中，可以看到HTML的解析器有个vue选项，读过vue源码的同学应该知道vue模板在转换成HTML之前会先将模板转换成AST然后生成render function进而生成VirtualDOM。我们平时开发对AST使用比较少，但其实到处都能见到AST的影子：babel、webpack、eslint、taro等等。希望能抛砖引玉，使同学们在各自团队产出更多基于AST的优秀工具、项目。 References[1] babel手册：https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md[2] js-code-to-svg-flowchart：https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart[3] demo：https://bogdan-lyashenko.github.io/js-code-to-svg-flowchart/docs/live-editor/index.html","link":"/2019/07/20/Javascript抽象语法树下篇(实践篇)/"},{"title":"CSS Houdini实现动态波浪纹","text":"CSS Houdini 号称 CSS 领域最令人振奋的革新。CSS 本身长期欠缺语法特性，可拓展性几乎为零，并且新特性的支持效率太低，兼容性差。而 Houdini 直接将 CSS 的 API 暴露给开发者，以往完全黑盒的浏览器解析流开始对外开放，开发者可以自定义属于自己的 CSS 属性，从而定制和扩展浏览器的展示行为。 背景我们知道，浏览器在渲染页面时，首先会解析页面的 HTML 和 CSS，生成渲染树（rendering tree），再经由布局（layout）和绘制（painting），呈现出整个页面内容。在 Houdini 出现之前，这个流程上我们能操作的空间少之甚少，尤其是 layout 和 painting 环节，可以说是完全封闭，使得我们很难通过 polyfill 等类似的手段为欠支持的 CSS 特性提供兼容。而另一方面，语法特性的缺失也极大地限制了 CSS 的编程灵活性，社区中 sass、less、stylus 等 CSS 预处理技术的出现大多都源于这个原因，它们都希望通过预编译，突破 CSS 的局限性，让 CSS 拥有更强大的组织和编写能力。所以慢慢地，我们都不再手写 CSS，更方便、更灵活的 CSS 扩展语言成了 web 开发的主角。看到这样的情况，CSS Houdini 终于坐不住了。 什么是 CSS Houdini？CSS Houdini 对外开放了浏览器解析流程的一系列 API，这些 API 允许开发者介入浏览器的 CSS engine 运作，带来了更多的 CSS 解决方案。 CSS Houdini 目前主要提供了以下几个 API： CSS Properties and Values API 允许在 CSS 中定义变量和使用变量，是目前支持程度最高的一个 API。CSS 变量以 -- 开头，通过 var() 调用： 1234div { --font-color: #9e4a9b; color: var(--font-color);} 此外，CSS 变量也可以在其他节点中使用，只不过是有作用域限制的，也就是说自身定义的 CSS 变量只能被自身或自身的子节点使用： 123456.container { --font-color: #9e4a9b;}.container .text { color: var(--font-color);} 定义和使用 CSS 变量可以让我们的 CSS 代码变得更加简洁明了，比如我们可以单纯通过改变变量来改变 box-shadow 的颜色： 1234567.text { --box-shadow-color: #3a4ba2; box-shadow: 0 0 30px var(--box-shadow-color);}.text:hover { --box-shadow-color: #7f2c2b;} Painting API 允许开发者编写自己的 Paint Module，自定义诸如 background-image 这类的绘制属性。自定义的重点在于，”怎么画” 的逻辑需要我们来描述，因此我们利用 registerPaint 来描述我们的绘制逻辑： 12345registerPaint('rect', class { paint(ctx, size, properties, args) { // @TODO }}); registerPaint 方法注册了一个 Paint 类 rect 以供调用，这个类的核心在于它的 paint 方法。paint 方法用于描述自定义的绘制逻辑，它接收四个参数： ctx：一个 Canvas 的 Context 对象，因此 paint 中的绘制方式跟 canvas 绘制是一样的。 size：包含节点的尺寸信息，同时也是 canvas 可绘制范围（画板）的尺寸信息。 properties：包含节点的 CSS 属性，需要调用静态方法 inputProperties 声明注入。 args: CSS 中调用 Paint 类时传入的参数，需要调用静态方法 inputArguments 声明注入。 编写完 Paint 类之后，我们在 CSS 中只需要这样调用，就能应用到我们自定义的绘制逻辑： 123.wrapper { background-image: paint(rect);} Painting API 目前在高版本 Chrome、Opera 浏览器已有支持，且实现起来比较简单，后边我们还将通过 demo 进一步演示。 Layout API允许开发者编写自己的 Layout Module，自定义诸如 display 这类的布局属性。同样的，”如何布局” 的逻辑需要我们自己编写： 1234567891011registerLayout('block-like', class { layout(children, edges, constraints, properties, breakToken) { // @TODO return { // inlineSize: number, // blockSize: number, // autoBlockSize: number, // childFragments: sequence&lt;LayoutFragment&gt; } }}) registerLayout 方法用于注册一个 Layout 类以供调用，它的 layout 方法用于描述自定义的布局逻辑，最终返回一个包含布局后的位置尺寸信息和子节点序列信息的对象，引擎将根据这个对象进行布局渲染。 同样的，调用时只需： 123.wrapper { display: layout('block-like');} 因此利用 Layout API，你完全可以实现对 flex 布局的手工兼容。相比 Painting，Layout 的编写显得更加复杂，涉及到盒模型的深入概念，且支持度不高，这里就不细讲了。 WorkletsregisterPaint、registerLayout 这些 API 在全局上并不存在，为什么可以直接调用呢？这是因为上述的 JS 代码并不是直接执行的，而是通过 Worklets 载入执行的。Worklets 类似于 Web Worker，是一个运行于主代码之外的独立工作进程，但比 Worker 更为轻量，负责 CSS 渲染任务是最合适的了。和 Web Worker 一样，Worklets 拥有一个隔离于主进程的全局空间，在这个空间里，没有 window 对象，却有 registerPaint、registerLayout 这些全局 API。因此，我们需要这样引入自定义 JS 代码： 123if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\");} 123if (\"layoutWorklet\" in CSS) { CSS.layoutWorklet.addModule(\"layoutworklet.js\");} 基础：三步用上 Painting API我们来自定义 background-image 属性，它将用于给作用节点绘制一个矩形背景，背景色值由该节点上的一个 CSS 变量 --rect-color 指定。 1、编写一个 Paint 类：新建一个 paintworklet.js，利用 registerPaint 方法注册一个 Paint 类 rect，定义属性的绘制逻辑： 12345678910registerPaint(\"rect\", class { static get inputProperties() { return [\"--rect-color\"]; } paint(ctx, geom, properties) { const color = properties.get(\"--rect-color\")[0]; ctx.fillStyle = color; ctx.fillRect(0, 0, geom.width, geom.height); }}); 上边定义了一个名为 rect 的 Paint 类，当 rect 被使用时，会实例化 rect 并自动触发 paint 方法执行渲染。paint 方法中，我们获取节点 CSS 定义的 --rect-color 变量，并将元素的背景填充为指定颜色。由于需要使用属性 --rect-color，我们需要在静态方法 inputProperties 中声明。 2、Worklets 加载 Paint 类：HTML 中通过 Worklets 载入上一步骤实现的 paintworklet.js 并注册 Paint 类： 123456&lt;div class=\"rect\"&gt;&lt;/div&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); }&lt;/script&gt; 3、使用 Paint 类：CSS 中使用的时候，只需要调用 paint 方法： 123456.rect { width: 100vw; height: 100vh; background-image: paint(rect); --rect-color: rgb(255, 64, 129);} 可以看得出利用 CSS Houdini，我们可以像操作 canvas 一样灵活自如地实现我们想要的样式功能。 进阶：实现动态波纹根据上述步骤，我们演示一下如何用 CSS Painting API 实现一个动态波浪的效果： 1234567891011121314151617181920212223242526&lt;!-- index.html --&gt;&lt;div id=\"wave\"&gt;&lt;/div&gt;&lt;style&gt; #wave { width: 20%; height: 70vh; margin: 10vh auto; background-color: #ff3e81; background-image: paint(wave); }&lt;/style&gt;&lt;script&gt; if (\"paintWorklet\" in CSS) { CSS.paintWorklet.addModule(\"paintworklet.js\"); const wave = document.querySelector(\"#wave\"); let tick = 0; requestAnimationFrame(function raf(now) { tick += 1; wave.style.cssText = `--animation-tick: ${tick};`; requestAnimationFrame(raf); }); }&lt;/script&gt; 12345678910111213141516171819202122232425262728// paintworklet.jsregisterPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { let tick = Number(properties.get('--animation-tick')); const { width, height } = geom; const initY = height * 0.4; tick = tick * 2; ctx.beginPath(); ctx.moveTo(0, initY + Math.sin(tick / 20) * 10); for (let i = 1; i &lt;= width; i++) { ctx.lineTo(i, initY + Math.sin((i + tick) / 20) * 10); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + Math.sin(tick / 20) * 10); ctx.closePath(); ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fill(); }}) paintworklet 中，利用 sin 函数绘制波浪线，由于 AnimationWorklets 尚处于实验阶段，开放较少，这里我们在 worklet 外部用 requestAnimationFrame API 来做动画驱动，让波浪纹动起来。完成后能看到下边这样的效果。 然而事实上这个效果略显僵硬，sin 函数太过于规则了，现实中的波浪应该是不规则波动的，这种不规则主要体现在两个方面： 1）波纹高度（Y）随位置（X）变化而不规则变化 把图按照 x-y 正交分解之后，我们希望的不规则，可以认为是固定某一时刻，随着 x 轴变化，波纹高度 y 呈现不规则变化； 2）固定某点（X 固定），波纹高度（Y）随时间推进而不规则变化动态过程需要考虑时间维度，我们希望的不规则，还需要体现在时间的影响中，比如风吹过的前一秒和后一秒，同一个位置的波浪高度肯定是不规则变化的。 提到不规则，有朋友可能想到了用 Math.random 方法，然而这里的不规则并不适合用随机数来实现，因为前后两次取的随机数是不连续的，而前后两个点的波浪是连续的。这个不难理解，你见过长成锯齿状的波浪吗？又或者你见过上一刻 10 米高、下一刻就掉到 2 米的波浪吗？ 为了实现这种连续不规则的特征，我们弃用 sin 函数，引入了一个包 simplex-noise。由于影响波高的有两个维度，位置 X 和时间 T，这里需要用到 noise2D 方法，它提前在一个三维的空间中，构建了一个连续的不规则曲面： 123456789101112131415161718192021222324252627282930313233343536373839404142// paintworklet.jsimport SimplexNoise from 'simplex-noise';const sim = new SimplexNoise(() =&gt; 1);registerPaint('wave', class { static get inputProperties() { return ['--animation-tick']; } paint(ctx, geom, properties) { const tick = Number(properties.get('--animation-tick')); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.4)', 0.004, tick, 15, 0.4); this.drawWave(ctx, geom, 'rgba(255, 255, 255, 0.5)', 0.006, tick, 12, 0.4); } /** * 绘制波纹 */ drawWave(ctx, geom, fillColor, ratio, tick, amp, ih) { const { width, height } = geom; const initY = height * ih; const speedT = tick * ratio; ctx.beginPath(); for (let x = 0, speedX = 0; x &lt;= width; x++) { speedX += ratio * 1; var y = initY + sim.noise2D(speedX, speedT) * amp; ctx[x === 0 ? 'moveTo' : 'lineTo'](x, y); } ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.lineTo(0, initY + sim.noise2D(0, speedT) * amp); ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill(); }}) 修改峰值和偏置项等参数，可以再画多一个不一样的波浪纹，效果如下，完工！ 参考文章 CSS Painting API Level 1CSS Layout API Level 1CSS 魔術師 Houdini API 介紹","link":"/2019/07/12/CSS Houdini实现动态波浪纹/"},{"title":"【译】在生产环境中使用原生JavaScript模块","text":"原文地址：https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/原文作者：PHILIP WALTON译者：龚亮 ，校对：刘辉声明：本翻译仅做学习交流使用，转载请注明来源 两年前，我写了一篇有关module/nomodule技术的文章，这项技术允许你在编写ES2015+代码时，使用打包器和转换器生成两个版本的代码库，一个具有现代语法的版本（通过&lt;script type=&quot;module&quot;&gt;加载）和一个使用ES5语法的版本（通过&lt;script nomodule&gt;加载）。该技术允许你向支持模块（译者注：指ECMA制定的标准的export/import模块语法及其加载机制，又称为ES Module、ESM、ES6 Module、ES2015 Module，下文中将出现很多”模块”一词，都是这个含义）的浏览器发送更少的代码，现在大多数Web框架和CLI都支持它。 但是那时候，尽管能够在生产中部署现代JavaScript，大多数浏览器也都支持模块，我仍然建议打包你的代码。 为什么？主要是因为我觉得在浏览器中加载模块很慢。尽管像HTTP/2这样的新协议理论上有效地支持加载大量小文件，但当时的所有性能研究都认为使用打包器更有效。 其实当时的研究是不完整的。该研究所使用的模块测试示例由部署到生产环境中未优化和未缩小的源文件组成。它并没有将优化后的模块包与优化后的原始脚本进行比较。 不过，当时并没有更好的方法来部署模块(译者注：指遵循ES2015模块规范的文件)。但是现在，打包技术取得了一些最新进展，可以将生产代码部署为ES2015模块(包含静态导入和动态导入)，从而获得比非模块(译者注：指除ES2015模块外的传统部署方式)更好的性能。实际上，这个站点(译者注：指原文章所在的网站)已经在生产环境中使用原生模块好几个月了。 对模块的误解与我交流过的很多人都认为模块（译者注：指遵循ES2015模块规范的部署方式）是大规模生产环境下应用程序的一个选择罢了。他们中的许多人引用了我刚刚提到的研究，并建议不要在生产环境中使用模块，除非: …小型web应用程序，总共只有不到100个模块，依赖树相对较浅(即最大深度小于5)。 如果你曾经查看过node_modules目录，可能知道即使是小型应用程序也很容易有超过100个模块依赖项。我们来看看npm上一些流行的工具包有多少个模块依赖项吧： 包 模块数量 date-fns 729 lodash-es 643 rxjs 226 人们对模块的主要误解是，在生产环境中使用模块时只有两个选择：(1)按原样部署所有源代码(包括node_modules目录)，(2)完全不使用模块。 如果你仔细考虑我所引用研究给出的建议，它没有说加载模块比普通加载脚本慢，也没有说你不应该使用模块。它只是说，如果你将数百个未经过压缩的模块文件部署到生产环境中，Chrome将无法像加载单个经过压缩的模块一样快速的加载它们。所以建议继续使用打包器、编译器和压缩器（译者注：原文是minifier，指去除空格注释等）。 实际情况是，你可以在生产环境中使用上面所有技术的同时，也可以使用ES2015模块！ 事实上，因为浏览器已经知道如何加载模块（对不支持模块的浏览器可以做降级处理），所以模块才是我们应该打包出的格式。如果你检查大多数流行的打包器生成的输出代码，你会发现很多样板代码（译者注：指rollup和webpack中的runtime的代码），其唯一的目的是动态加载其它代码并管理依赖，但如果我们只使用带有import和export语句的模块，则不需要这些代码！ 幸运的是，今天至少有一个流行的打包器（Rollup）支持模块作为输出格式，这意味着可以打包代码并在生产环境中部署模块（没有加载器样板代码）。由于Rollup（根据我的经验，这是最好的打包器）具有出色的tree-shaking，使得Rollup打包出的模块是目前所有打包器输出模块中代码最少的。 更新： Parcel计划在下一版本中添加模块支持。Webpack目前不支持模块输出格式，但这里有一些相关讨论＃2933，＃8895，＃8896。 另一个误解是，除非你的所有依赖项都使用模块，否则你不能使用模块。不幸的是大多数npm包仍然以CommonJS的形式发布(甚至有些包以ES2015编写，但在发布到npm之前转换为CommonJS)！ 尽管如此，Rollup有一个插件（rollup-plugin-commonjs），它可以将CommonJS源代码转换为ES2015。如果一开始你的依赖项采用ES2015模块管理肯定会更好，但是有一些依赖关系不是这样管理的并不会阻止你部署模块。 在本文的剩余部分，我将向你展示如何打包到模块（包括使用动态导入和代码拆分的粒度），解释为什么它通常比原始脚本更高效，并展示如何处理不支持模块的浏览器。 最优打包策略打包生产代码一直是需要权衡利弊。一方面，希望代码尽快加载和执行。另一方面，又不希望加载用户实际用不到的代码。 同时，还希望代码尽可能地被缓存。打包的一个大问题是，即使只是一行代码有修改也会使整个打包后的包缓存失效。如果直接使用ES2015模块部署应用程序（就像它们在源代码中一样），那么你可以自由地进行小的更改，同时让应用程序的大部分代码仍然保留在缓存中。但就像我已经指出的那样，这也意味着你的代码需要更长时间才能被新用户的浏览器加载完成。 因此，找到最优打包粒度的挑战是在加载性能和长期缓存之间取得适当的平衡。 默认情况下，大多数打包器在动态导入时进行代码拆分，但我认为仅动态导入的代码拆分粒度不够细，特别是对于拥有大量留存用户的站点（缓存很重要）。 在我看来，你应该尽可能细粒度地拆分代码，直到开始显著地影响加载性能为止。虽然我强烈建议你自己动手进行分析，但是查阅上文引用的研究可以得出一个大致的结论。当加载少于100个模块时，没有明显的性能差异。针对HTTP/2性能的研究发现，加载少于50个文件时没有明显的差异(尽管他们只测试了1、6、50和1000，所以100个文件可能就可以了)。 那么，最好的代码拆分方法是什么呢？除了通过动态导入做代码拆分外，我还建议以npm包为粒度做代码拆分，node_modules中的模块都合并到以其包名命名的文件中。 包级别的代码拆分如上所述，打包技术的一些最新进展使得高性能模块部署成为可能。我提到的增强是指Rollup的两个新功能：通过动态import()时自动代码拆分（在v1.0.0中添加）和通过manualChunks选项进行可编程的手动代码拆分（在v1.11.0中添加）。 有了这两个功能，现在很容易在包级别进行代码拆分的构建配置。 这是一个使用manualChunks选项配置的例子，每个位于node_module里的模块将被合并到以包名命名的文件里(当然，这种模块路径里肯定包含node_modules) 1234567891011121314151617181920export default { input: { main: &apos;src/main.mjs&apos;, }, output: { dir: &apos;build&apos;, format: &apos;esm&apos;, entryFileNames: &apos;[name].[hash].mjs&apos;, }, manualChunks(id) { if (id.includes(&apos;node_modules&apos;)) { // Return the directory name following the last `node_modules`. // 返回最后一个node_modules后面跟着的目录名 // Usually this is the package, but it could also be the scope. // 通常都会是一个包名，也有可能是一个私有域 const dirs = id.split(path.sep); return dirs[dirs.lastIndexOf(&apos;node_modules&apos;) + 1]; } },} manualChunks选项接收一个函数，该函数将模块文件路径作为惟一的参数，也可以返回一个文件名，参数中的模块将被加入到这个文件里。如果没有返回任何内容，参数中的模块将被添加到默认文件中。 考虑从lodash-es包中导入cloneDeep()、debounce()和find()模块的一个应用程序。上面的配置将把各个模块(以及它们导入的任何其它lodash模块)一起放入一个名为npm.lodash-es.XXXX.mjs的输出文件中，(其中XXXX是lodash-es模块文件的哈希值)。 在该文件的末尾，你会看到这样的导出语句(注意，它只包含添加到块中模块的导出语句，而不是所有lodash模块): 1export {cloneDeep, debounce, find}; 希望这个例子能清楚地说明使用Rollup手动拆分代码的工作原理。就我个人而言，我认为使用import和export语句的代码拆分比使用非标准的、特定于打包器实现的代码拆分更容易阅读和理解。 例如，跟踪这个文件中发生了什么很难(我以前使用webpack对一个项目做代码拆分后的实际输出)，而且在支持模块的浏览器中其实不需要这些代码: 12345678910111213141516171819(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[&quot;import1&quot;],{/***/ &quot;tLzr&quot;:/*!*********************************!*\\ !*** ./app/scripts/import-1.js ***! \\*********************************//*! exports provided: import1 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;import1&quot;, function() { return import1; });/* harmony import */ var _dep_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dep-1 */ &quot;6xPP&quot;);const import1 = &quot;imported: &quot; + _dep_1__WEBPACK_IMPORTED_MODULE_0__[&quot;dep1&quot;];/***/ })}]); 如果你有数百个npm依赖项怎么办？我在上面说过，我认为包级别上的代码拆分是站点代码拆分的最佳状态，而又不会太激进。 当然，如果你的应用程序从数百个不同的npm包中导入模块，那么浏览器可能无法有效地加载所有模块。 但是，如果你确实有很多npm依赖项，那么先不要完全放弃这个策略。请记住，你可能不会在每个页面上加载所有的npm依赖项，因此检查实际加载了多少依赖项非常重要。 尽管如此，确实有一些非常大的应用程序具有如此多的npm依赖关系，以至于它们不能实际地对其中的每一个应用程序进行代码拆分。如果你是这种情况，我建议你找出一种方法来将一些依赖项分组到公共文件中。一般来说，你可以将可能在同一时间发生变化的包(例如，React和react-dom)分组，因为它们必须一起失效(例如，我稍后展示的示例应用程序将所有React依赖项分组为同一个文件)。 动态导入使用原生import语句进行代码拆分和模块加载的一个缺点是，需要开发人员对不支持模块的浏览器做兼容处理。 如果你想使用动态import()懒加载代码，那么你还必须处理这样一个事实：有些浏览器支持模块，但不支持动态import()（Edge 16–18, Firefox 60–66, Safari 11, Chrome 61–63）。 幸运的是，一个很小的(~400字节)、非常高性能的polyfill可用于动态import()。 向站点添加polyfill很容易。你所要做的是导入它并在应用程序的主入口点初始化它(在调用import()之前): 12345import dynamicImportPolyfill from &apos;dynamic-import-polyfill&apos;;// This needs to be done before any dynamic imports are used. And if your// modules are hosted in a sub-directory, the path must be specified here.dynamicImportPolyfill.initialize({modulePath: &apos;/modules/&apos;}); 最后要做的是告诉Rollup将输出代码中的动态import()重命名为你指定的另一个名称(通过output.dynamicImportFunction选项配置)。动态导入polyfill默认使用名称为import，但是可以配置它。 需要重命名import()语句的原因是import是JavaScript中的一个关键字。这意味着不可能使用相同的名称来填充原生import()，因为这样做会导致语法错误。 让Rollup在构建时重命名它是很好的，这意味着你的源代码可以使用标准版本，并且在将来不再需要polyfill时，你将不必重新更改它。 高效加载JavaScript模块当你使用代码拆分的时候，最好预加载所有马上要使用的模块(即主入口模块导入图中的所有模块)。 但是，当你加载实际的JavaScript模块（通过&lt;script type=&quot;module&quot;&gt;以及随后import语句引用的模块时），你将希望使用modulepreload而不是传统的preload(仅适用于原始脚本)。 123456&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-one.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-two.XXXX.mjs&quot;&gt;&lt;link rel=&quot;modulepreload&quot; href=&quot;/modules/npm.pkg-three.XXXX.mjs&quot;&gt;&lt;!-- ... --&gt;&lt;script type=&quot;module&quot; src=&quot;/modules/main.XXXX.mjs&quot;&gt;&lt;/script&gt; 实际上，对于预加载原生的模块，modulepreload实际上比传统的preload要严格得多，它不仅下载文件，而且在主线程之外立即开始解析和编译文件。传统的预加载无法做到这一点，因为它不知道在预加载时该文件将用作模块脚本还是原始脚本。 这意味着通过modulepreload加载模块通常会更快，而且在实例化时不太可能导致主线程卡顿。 生成modulepreload列表Rollup的bundle对象中的每个入口文件在其静态依赖关系图中包含完整的导入列表，因此在Rollup的generateBundle钩子中很容易获得需要预加载哪些文件的列表。 虽然在npm上确实存在一些modulepreload插件，但是为图中的每个入口点生成一个modulepreload列表只需要几行代码，所以我更愿意像这样手动创建它: 123456789101112131415{ generateBundle(options, bundle) { // A mapping of entry chunk names to their full dependency list. const modulepreloadMap = {}; for (const [fileName, chunkInfo] of Object.entries(bundle)) { if (chunkInfo.isEntry || chunkInfo.isDynamicEntry) { modulepreloadMap[chunkInfo.name] = [fileName, ...chunkInfo.imports]; } } // Do something with the mapping... console.log(modulepreloadMap); }} 例如，这里是我如何为这个站点以及我的demo应用生成modulepreload列表的。 注意：虽然对于模块脚本来说，modulepreload绝对比原始的preload更好，但它对浏览器的支持更差(目前只支持chrome)。如果你的流量中有相当一部分是非chrome流量，那么使用classic preload是有意义的。 与使用modulepreload不同，使用preload时需要注意的一点是，预加载脚本不会放在浏览器的模块映射中，这意味着可能会不止一次地处理预加载的请求(例如，如果模块在浏览器完成预加载之前导入文件)。 为什么要部署原生模块？如果你已经在使用像webpack这样的打包器，并且已经在使用细粒度代码拆分和预加载这些文件(与我在这里描述的类似)，那么你可能想知道是否值得改变策略，使用原生模块。下面是我认为你应该考虑它的几个原因，以及为什么打包到原生模块比使用带有模块加载代码的原始脚本要好。 更小的代码总量当使用原生模块时，现代浏览器不必为用户加载任何不必要的模块加载或依赖关系管理代码。例如，如果使用原生模块，则根本不需要webpack运行时和清单。 更好的预加载正如我在前一节中提到的，使用modulepreload允许你加载代码并在主线程之外解析/编译代码。在其他条件相同的情况下，这意味着页面的交互速度更快，并且主线程在用户交互期间不太可能被阻塞。 因此，无论你如何细粒度地对应用程序进行代码拆分，使用import语句和modulepreload加载模块要比通过原始script标签和常规preload加载更有效(特别是如果这些标签是动态生成的，并在运行时添加到DOM中)。 换句话说，由Rollup打包出的20个模块文件将比由webpack打包出的20个原始脚本文件加载得更快(不是因为webpack，而是因为它不是原生模块)。 更面向未来许多最令人兴奋的新浏览器特性都是构建在模块之上的，而不是原始的脚本。这意味着，如果你想使用这些特性中的任何一个，你的代码需要作为原生模块部署，而不是转换为ES5并通过原始的script标签加载(我在尝试使用实验性KV存储API时曾提到过这个问题)。 以下是一些仅限模块才有的最令人兴奋的新功能： 内置模块 HTML模块 CSS模块 JSON模块 导入地图 workers、service workers和window之间共享模块 支持旧版浏览器在全球范围内，超过83%的浏览器原生支持JavaScript模块(包括动态导入)，因此对于你的大多数用户来说，不需要做任何处理就可以使用这项技术。 对于支持模块但不支持动态导入的浏览器，可以使用上面提到的dynamic-import-polyfill。由于polyfill非常小，并且在可用时将使用浏览器的原生动态import()，因此添加这个polyfill几乎没有大小或性能成本。 对于根本不支持模块的浏览器，可以使用我前面提到的module/nomodule技术。 一个实际的例子由于谈论跨浏览器兼容性总是比实际实现它要容易，所以我构建了一个演示应用程序，它使用了我在这里阐述的所有技术。 这个演示程序可以在不支持动态import()的浏览器中运行(如Edge 18和Firefox ESR)，也可以在不支持模块的浏览器中运行(如Internet Explorer 11)。 为了说明这个策略不仅适用于简单的用例，我还包含了当今复杂的JavaScript应用程序需要的许多特性: Babel转换（包括JSX） CommonJS的依赖关系（例如react，react-dom） CSS依赖项 Asset hashing 代码拆分 动态导入（带有polyfill降级机制） module/nomodule降级机制 代码托管在GitHub上(因此你可以派生repo并自己构建它)，而演示则托管在Glitch上，因此你可以重新组合代码并使用这些特性。 最重要的是查看示例中使用的Rollup配置，因为它定义了如何生成最终模块。 总结希望这篇文章让你相信，现在不仅可以在生产环境中部署原生JavaScript模块，而且这样做可以提高站点的加载和运行时性能。 以下是快速完成此工作所需步骤的摘要： 使用打包器，但要确保输出格式为ES2015模块 积极地进行代码拆分(如果可能的话，一直到node包) 预加载静态依赖关系图中的所有模块(通过modulepreload) 使用polyfill来支持不支持动态import()的浏览器 使用&lt;script nomodule&gt;支持根本不支持模块的浏览器 如果你已经在构建设置中使用了Rollup，我希望你尝试这里介绍的技术，并在生产环境中部署原生模块(带有代码拆分和动态导入)。如果你这样做了，请告诉我进展如何，因为我既想听你的问题，也想听你的成功故事！ 模块是JavaScript的明确未来，我希望我们所有的工具和依赖都能尽快包含模块。希望本文能在这个方向上起到一点推动作用。 译者评：1.作者上一篇文章的译文：https://jdc.jd.com/archives/49112.另外一篇讲JavaScript原生模块的文章：https://www.jianshu.com/p/9aae3884b05b","link":"/2019/09/10/【译】在生产环境中使用原生JavaScript模块/"}],"tags":[{"name":"AST","slug":"AST","link":"/tags/AST/"},{"name":"碰撞检测","slug":"碰撞检测","link":"/tags/碰撞检测/"},{"name":"向量","slug":"向量","link":"/tags/向量/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS Houdini","slug":"CSS-Houdini","link":"/tags/CSS-Houdini/"},{"name":"type=\"module\"","slug":"type-module","link":"/tags/type-module/"},{"name":"代码拆分","slug":"代码拆分","link":"/tags/代码拆分/"},{"name":"rollup打包","slug":"rollup打包","link":"/tags/rollup打包/"},{"name":"modulepreload","slug":"modulepreload","link":"/tags/modulepreload/"}],"categories":[{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"Web开发","slug":"Web开发","link":"/categories/Web开发/"}]}